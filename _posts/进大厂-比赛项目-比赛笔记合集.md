# seaborn.pairplot[¶](https://seaborn.pydata.org/generated/seaborn.pairplot.html#seaborn-pairplot)

[Python可视化 | Seaborn5分钟入门(七)——pairplot](https://zhuanlan.zhihu.com/p/98729226)

- pairplot主要展现的是**变量两两之间的关系**（线性或非线性，有无较为明显的相关关系），照例来总览一下pairplot的API。

- `seaborn.pairplot`(*data*, *hue=None*, *hue_order=None*, *palette=None*, *vars=None*, *x_vars=None*, *y_vars=None*, *kind='scatter'*, *diag_kind='auto'*, *markers=None*, *height=2.5*, *aspect=1*, *corner=False*, *dropna=True*, *plot_kws=None*, *diag_kws=None*, *grid_kws=None*, *size=None*)

  Plot pairwise relationships in a dataset.
  - kind：用于控制非对角线上的图的类型，可选"scatter"与"reg"

    diag_kind：控制对角线上的图的类型，可选"hist"与"kde”

  - `hue` ：针对某一字段进行分类

  - `palette`：控制色调

  - `markers`：控制散点的样式

  - 

# n折交叉验证

n 折交叉验证, 按照比例选择索引

```python
# n 折交叉验证
>>> import numpy as np
>>> from sklearn.model_selection import KFold
# >>> X = np.array([[1, 2], [3, 4], [1, 2], [3, 4]])
>>> X = np.array([[1, 1], [2, 2], [3, 3], [4, 4], [4, 4]])
>>> y = np.array([1, 2, 3, 4,5])
>>> kf = KFold(n_splits=5)
>>> kf.get_n_splits(X)
print(kf)
>>> for train_index, test_index in kf.split(X):
...     print("TRAIN:", train_index, "TEST:", test_index)
...     X_train, X_test = X[train_index], X[test_index]
...     y_train, y_test = y[train_index], y[test_index]
```

out

```
KFold(n_splits=5, random_state=None, shuffle=False)
TRAIN: [1 2 3 4] TEST: [0]
TRAIN: [0 2 3 4] TEST: [1]
TRAIN: [0 1 3 4] TEST: [2]
TRAIN: [0 1 2 4] TEST: [3]
TRAIN: [0 1 2 3] TEST: [4]
```

# np转一维函数 — ravel()、flatten()、squeeze()

numpy中的ravel()、flatten()、squeeze()都有将多维数组转换为一维数组的功能，区别：
ravel()：如果没有必要，不会产生源数据的副本
flatten()：返回源数据的副本
squeeze()：只能对维数为1的维度降维

# numpy 数组属性查看

```python

print("数据类型",type(a1))           #打印数组数据类型  
print("数组元素数据类型：",a1.dtype) #打印数组元素数据类型  
print("数组元素总数：",a1.size)      #打印数组尺寸，即数组元素总数  
print("数组形状：",a1.shape)         #打印数组形状  
print("数组的维度数目",a1.ndim)      #打印数组的维度数目

```

# pandas数据处理三板斧 — map、apply、applymap

在日常的数据处理中，经常会对一个`DataFrame`进行**逐行、逐列和逐元素的操作**，对应这些操作，Pandas中的`map`、`apply`和`applymap`可以解决绝大部分这样的数据处理需求。



# 保存模型

```python
# 保存模型
import pickle
s = pickle.dumps(clf)
clf2 = pickle.loads(s)
```
# 保存最佳模型(早停加lr衰减) — deepshare_nlp_ch4(bert)

`save_model = './bert.bin'`

```python
	"""
	如果: 模型在验证集效果比最佳的好,则保存模型
            否则, early_stop+=1,
            如果early_stop`3:停止训练
	"""
	def train(self):
        logging.info('Start training...')
        for epoch in range(1, epochs + 1):
            train_f1 = self._train(epoch)

            dev_f1 = self._eval(epoch)
		
            if self.best_dev_f1 <= dev_f1:
                logging.info(
                    "Exceed history dev = %.2f, current dev = %.2f" % (self.best_dev_f1, dev_f1))
                torch.save(self.model.state_dict(), save_model)

                self.best_train_f1 = train_f1
                self.best_dev_f1 = dev_f1
                self.early_stop = 0
            else:
                self.early_stop += 1
                if self.early_stop ` early_stops:
                    logging.info(
                        "Eearly stop in epoch %d, best train: %.2f, dev: %.2f" % (
                            epoch - early_stops, self.best_train_f1, self.best_dev_f1))
                    self.last_epoch = epoch
                    break
     """测试函数, 加载保存的模型并使用验证函数"""
    def test(self):
        self.model.load_state_dict(torch.load(save_model))
        self._eval(self.last_epoch + 1, test=True)
```

# 日志式输出

```python
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)-15s %(levelname)s: %(message)s')

logging.info("Use cuda: %s, gpu id: %d.", use_cuda, gpu)
```

# 数组索引不到右边界

```python
a = [0,1,2,3,4,5,6]
len(a[:-1]) # 6
len(a[:len(a)]) #7

```

























