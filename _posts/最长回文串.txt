class Solution:
    def longestPalindrome(self, s: str) -> str:
        if len(s) <= 1: return s # 长度为1一定为回文串
        max_length = 1  # 长度至少为1，故应该存最小长度为1
        res_x = 0
        # 1. 初始化basecase，对角线元素（长度为1）为回文，标记为True
        dp = [[False] * len(s) for _ in range(len(s))]
        for i in range(len(s)):
            dp[i][i] = True
        # 2. 其中状态为：i，j索引之间的字符串是否是回文串
        # 3. 其中选择为：不同的起始和结束索引i，j
        # 4. 斜向遍历进行状态转移。因为每次计算dp[i][j]需要左、下、右位置的状态（dp[i+1][j]、dp[i][j-1]、dp[i+1][j-1]）已知，所以只能选择斜向或者反向遍历。
        for length in range(2, len(s) + 1):
            for i in range(len(s)):
                j = length + i - 1
                if j >= len(s):
                    break
                # 4.1 如果两侧字符不相等则一定不是回文串
                if s[i] != s[j]:
                    dp[i][j] = False
                # 4.2 否则，如果子串长度小于等于3（即j - i <= 2），则一定为回文子串；如果大于3，则状态等于其子问题dp[i + 1][j - 1]的状态。
                else:
                    if j - i <= 2 :
                        dp[i][j] = True
                    else:
                        dp[i][j] = dp[i + 1][j - 1]
                if dp[i][j] and j-i+1 > max_length:
                    max_length = j-i+1
                    res_x = i
        # 5. 返回所保存的max_length最大的回文子串
        return s[res_x: res_x+max_length]
