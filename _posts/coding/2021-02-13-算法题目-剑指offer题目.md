# 按书内容做题

## LCOF

### ✅ 03数组中重复的数字

找出数组中重复的数字。


在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

```
示例 1：

输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 
```

限制：

2 <= n <= 100000

**回溯算法(回溯搜索算法)**   

1. 深度优先遍历的特有的现象，节约空间  
   全排列思路：  
   在枚举第一位的时候，有 3 种情况。  
   在枚举第二位的时候，前面已经出现过的数字就不能再被选取了；  
   在枚举第三位的时候，前面 2 个已经选择过的数字就不能再被选取了。  

```python
# 自己做的: 排序后前后对比
# 90％ 100％
nums = [2, 3, 1, 0, 2, 5, 3]

def findRepeatNumber(nums) -> int:
    nums_sorted = sorted(nums)
    length = len(nums_sorted)
    for i in range(length-1):
        if nums_sorted[i] == nums_sorted[i+1]:
            return nums_sorted[i]
        
findRepeatNumber(nums)
```


```python
# 法2: 原地替换 不如我的高
nums = [2, 3, 1, 0, 2, 5, 3]

def findRepeatNumber(nums) -> int:
    nums_sorted = sorted(nums)
    length = len(nums_sorted)
    for i in range(length):
        while nums_sorted[i] != i:
            if nums_sorted[i] == nums_sorted[nums_sorted[i]]:
                return nums_sorted[i]
            temp = nums_sorted[i]
            nums_sorted[i] = nums_sorted[temp]
            nums_sorted[temp] = temp
            
findRepeatNumber(nums)
```


```python
# 法3: hash表
nums = [2, 3, 1, 0, 2, 5, 3]

def findRepeatNumber(nums) -> int:
    hashlist = [False for i in range(len(nums))]
    for i in range(len(nums)):
        if hashlist[nums[i]] == True:
            return nums[i]
        else: 
            hashlist[nums[i]] = True
        
findRepeatNumber(nums)
```



### ✅ 04. 二维数组中的查找

在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

示例:

现有矩阵 matrix 如下：

```
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
```

给定 target = 5，返回 true。
给定 target = 20，返回 false。


```python
matrix = [
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]]

matrix = [[5]]

def findNumberIn2DArray(matrix, target):
    if len(matrix)==0 or len(matrix[0])==0:
        return False  
    
    row = 0
    col = len(matrix[0])-1
    while True:
        if matrix[row][col]==target:
            return True

        if matrix[row][col]>target:
            if (col==0): 
                return False
            else: 
                col -= 1
        elif matrix[row][col]<target:
            if (row==len(matrix)-1):
                return False
            else: 
                row += 1
findNumberIn2DArray(matrix, 5)
```

#### C++

### ✅ 05. 替换空格

请实现一个函数，把字符串 s 中的每个空格替换成"%20"。



示例 1：

```
输入：s = "We are happy."
输出："We%20are%20happy."
```


```python
s = "We are happy."
```


```python
# 90 100 
# 注意replace() 不改变原str内容能提高, 
# 在 Python 和 Java 等语言中，字符串都被设计成不可变的类型，
# 即无法直接修改字符串的某一位字符，需要新建一个字符串实现。
class Solution:
    def replaceSpace(s: str) -> str:        
        return s.replace(' ','%20')

Solution.replaceSpace(s)
```


```python
# 切割拼接法
class Solution:
    def replaceSpace(s: str) -> str:    
        lst = s.split(' ')
        return '%20'.join(lst)
Solution.replaceSpace(s)
```

###  ✅06. 从尾到头打印链表

#### 自制链表及其函数

输入一个链表的头节点，从尾到头反过来返回每个节点的值(用数组返回)。


```
示例 1：

输入：head = [1,3,2]
输出：[2,3,1]	
```


```python
head = [1,3,2]
```


```python
class Solution:
    def reversePrint(head):
        res = []
        while head:
            res.append(head.val)
            head = head.next
        return res[::-1]

head = l1
Solution.reversePrint(head)
```

#### 2️⃣ 

### ✅ （20m）07. 重建二叉树

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。


```
例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7
```

#### 2️⃣

**细节**

在中序遍历中对根节点进行定位时，一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，但这样做的时间复杂度较高。我们可以考虑使用哈希表来帮助我们快速地定位根节点。对于**哈希映射**中的每个键值对，键表示一个元素（节点的值），值表示其在中序遍历中的出现位置。在构造二叉树的过程之前，我们可以对中序遍历的列表进行一遍扫描，就可以构造出这个哈希映射。在此后构造二叉树的过程中，我们就只需要 ***O(1)* 的时间对根节点进行定位了**。


```python
preorder = [3,9,20,15,7]
inorder = [9,3,15,20,7]
```


```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        if not preorder or not inorder:
            return None
        root_val = preorder[0]
        ind = inorder.index(root_val)
        print(ind)
        root = TreeNode(root_val)
        root.left = self.buildTree(preorder[1:ind+1], inorder[:ind])
        root.right = self.buildTree(preorder[ind+1:], inorder[ind+1:])
        return root
```

官解（使用了set）：

```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        def recur(root, left, right):
            if left > right: return                               # 递归终止
            node = TreeNode(preorder[root])                       # 建立根节点
            i = dic[preorder[root]]                               # 划分根节点、左子树、右子树
            node.left = recur(root + 1, left, i - 1)              # 开启左子树递归
            node.right = recur(i - left + root + 1, i + 1, right) # 开启右子树递归
            return node                                           # 回溯返回根节点

        dic, preorder = {}, preorder
        for i in range(len(inorder)):
            dic[inorder[i]] = i
        return recur(0, 0, len(inorder) - 1)
```



### ✅（20m）09. 用两个栈实现队列

用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )

```
示例 1：

输入：
["CQueue","appendTail","deleteHead","deleteHead"]
[[],[3],[],[]]
输出：[null,null,3,-1]
示例 2：

输入：
["CQueue","deleteHead","appendTail","appendTail","deleteHead","deleteHead"]
[[],[],[5],[2],[],[]]
输出：[null,-1,null,null,5,2]
```


```python
class CQueue:

    def __init__(self):
        self.A, self.B = [], []
        
    def appendTail(self, value: int) -> None:
        self.A.append(value)

    def deleteHead(self) -> int:
        if self.B: return self.B.pop()
        if not self.A: return -1        
        while self.A:
            self.B.append(self.A.pop())
        return self.B.pop()


# Your CQueue object will be instantiated and called as such:
# obj = CQueue()
# obj.appendTail(value)
# param_2 = obj.deleteHead()

```

#### 2️⃣

```python
class CQueue:
    def __init__(self):
        self.s1 = []
        self.s2 = []

    def appendTail(self, value: int) -> None:
        self.s1.append(value)

    def deleteHead(self) -> int:
        if len(self.s2) == 0:
            if len(self.s1) == 0:
                return -1
            while self.s1:
                self.s2.append(self.s1.pop())
        return self.s2.pop()
```

### ✅10- I. 斐波那契数列

写一个函数，输入 n ，求斐波那契（Fibonacci)数列的第 n 项。斐波那契数列的定义如下：

F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

答案需要取模 1e9+7（1000000007)，如计算初始结果为：1000000008，请返回 1。

```
示例 1：输入：n = 2输出：1示例 2：输入：n = 5输出：5
```

尝试动态规划方法

```python
n = 43
```


```python
class Solution:    def fib(self, n: int) -> int:        if n == 0: return 0        if n == 1: return 1        fiblist = [0,1]        for i in range(2,n+1):            fiblist.append((fiblist[i-1]+fiblist[i-2])% 1000000007)        return fiblist.pop()                                
```


```python
# 动态规划方法class Solution:    def fib(self, n: int) -> int:        if n == 0: return 0        if n == 1: return 1        a, b = 0, 1        for _ in range(n):            a, b = b, a+b        return a % 1000000007
```


```python
solution = Solution()
result = solution.fib(n)
result
```

#### 2️⃣(32m)

```
class Solution:
    def fib(self, n: int) -> int:
        if n == 0: return 0
        if n == 1 or n == 2:
            return 1
        # 1
        # dp = [0 for i in range(n+1)]
        # dp[1], dp[2] = 1, 1
        
        # # 2
        # for i in range(3,n+1):
        #     dp[i] = dp[i-1] + dp[i-2]
        
        # return dp[n] % (10**9+7)

        pre, cur = 1, 1
        for i in range(n-2):
            sum = pre + cur 
            pre, cur = cur, sum
        
        return cur % (10**9+7)

```



### ✅ 10- II. 青蛙跳台阶问题

一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

答案需要取模 1e9+7（1000000007)，如计算初始结果为：1000000008，请返回 1。

```
示例 1：

输入：n = 2
输出：2
示例 2：

输入：n = 7
输出：21
```


```python
n = 7
```


```python
class Solution:
    def numWays(self, n: int) -> int:
        if n == 0: return 0
        if n == 1: return 1
        if n == 2: return 2
        a, b = 1, 2
        for _ in range(n-1):
            a, b = b, a+b
        return a%1000000007
```


```python
solution = Solution()
result = solution.numWays(n)
result
```

### 🚩11. 旋转数组的最小数字

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  

```
示例 1：

输入：[3,4,5,1,2]
输出：1
示例 2：

输入：[2,2,2,0,1]
输出：0
```

#### 2️⃣

```python
class Solution:
    def minArray(self, numbers: List[int]) -> int:
        l, r = 0, len(numbers)-1
        if numbers[0] < numbers[-1]:
            return numbers[0]
        while l <= r:
            mid = (l+r)//2
            if numbers[mid] > numbers[r]:
                l = mid + 1
            elif numbers[mid] < numbers[r]:
                r = mid  # 不同之处， 要保留右边界
            elif numbers[mid] == numbers[r]:  
                r -= 1  # 不同之处，相同需要一步一步走
        if l > len(numbers) - 1 or numbers[l] > numbers[r]:
            return -1
        return numbers[l]
```

### 🚩12. 矩阵中的路径

请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径(路径中的字母用加粗标出)。

[["a","b","c","e"],
["s","f","c","s"],
["a","d","e","e"]]

但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。


```
示例 1：输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"输出：true示例 2：输入：board = [["a","b"],["c","d"]], word = "abcd"输出：false
```


```python
board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]]word = "ABCCED"
```

#### 2️⃣

```python
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        def dfs(i, j, k):
            if not 0 <= i < len(board) or not 0 <= j < len(board[0]) or board[i][j] != word[k] or (i,j) in visited: return False
            if k == len(word) - 1: return True
            visited.add((i,j))
            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)
            visited.remove((i,j))
            return res

        for i in range(len(board)):
            for j in range(len(board[0])):
                visited = set()
                if dfs(i, j, 0): return True
        return False
```

### 🚩13. 机器人的运动范围

地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格(不能移动到方格外)，也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

```
示例 1：

输入：m = 2, n = 3, k = 1
输出：3
示例 2：

输入：m = 3, n = 1, k = 0
输出：1
```


```python
m = 2
n = 3
k = 1
```


```python
m = 38
n = 12
k = 9
```


```python
# copy
def digitsum(n):
    ans = 0
    while n:
        ans += n % 10
        n //= 10
    return ans

class Solution:
    def movingCount(self, m: int, n: int, k: int) -> int:
        from queue import Queue
        q = Queue()
        q.put((0, 0))
        s = set()
        while not q.empty():
            x, y = q.get()
            if (x, y) not in s and 0 <= x < m and 0 <= y < n and digitsum(x) + digitsum(y) <= k:
                s.add((x, y))
                for nx, ny in [(x + 1, y), (x, y + 1)]:
                    q.put((nx, ny))
        return len(s)
        
```


```python
solution = Solution()
solution.movingCount(m,n,k)
```

####  2️⃣

### ✅（20m）[剑指 Offer 14- I. 剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/)

难度中等265收藏分享切换为英文接收动态反馈

给你一根长度为 `n` 的绳子，请把绳子剪成整数长度的 `m` 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 `k[0],k[1]...k[m-1]` 。请问 `k[0]*k[1]*...*k[m-1]` 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

**示例 1：**

```
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1
```

**示例 2:**

```
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
```

 

```python
class Solution:
    def cuttingRope(self, n: int) -> int:
        dp = [0] * (n + 1)
        dp[2] = 1
        for i in range(3, n + 1):
            for j in range(2, i):
                dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))
        return dp[n]
```

### ✅（20m）[剑指 Offer 14- 2 剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/)

### ✅（10m）15 二进制中1的个数

```
# 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为 汉明重量).）。 
```

### 🚩（30m）16 数值的整数次方

 实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。 

```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if x == 0:
            return 0
        if n < 0:
            x, n = 1 / x, -n
        res = 1
        while n:
            if n & 1:
                res *= x
            x *= x
            n >>= 1
        return res
```

#### 2️⃣

### ✅（5m）17 打印1到最大的n位数

### ✅(10m)[18. 删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

难度简单97

给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

**注意：**此题对比原题有改动

**示例 1:**

```
输入: head = [4,5,1,9], val = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
```

**示例 2:**

```
输入: head = [4,5,1,9], val = 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.
```

### 🚩（30m）19 正则表达式匹配

```python
# 请实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配
# 是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但与"aa.a"和"ab*a"均不匹配。 
# 
#  示例 1: 
# 
#  输入:
# s = "aa"
# p = "a"
# 输出: false
# 解释: "a" 无法匹配 "aa" 整个字符串。
```

1. 初始化：   行是s，列是匹配符p

   ```python
           m, n = len(s) + 1, len(p) + 1
           dp = [[False] * n for _ in range(m)]
           dp[0][0] = True
           for j in range(2, n, 2):
               dp[0][j] = dp[0][j - 2] and p[j - 1] == '*'
   ```

2. 状态转移方程：

   1. 展开来看，假设 s[:i]s[:i] 与 p[:j]p[:j] 可以匹配，那么下一状态有两种：

      ```
      添加一个字符 s_{i+1}后是否能匹配？
      添加字符 p_{j+1}后是否能匹配？
      ```

   2.  p[j - 1] == '*'

      ```
                      if p[j - 1] == '*':
                          if dp[i][j - 2]: dp[i][j] = True                              # 1.0个
                          elif dp[i - 1][j] and s[i - 1] == p[j - 2]: dp[i][j] = True   # 2.多1次
                          elif dp[i - 1][j] and p[j - 2] == '.': dp[i][j] = True        # 3.
      ```

   3.  p[j - 1] != '*'

      ```
                      else:
                          if dp[i - 1][j - 1] and s[i - 1] == p[j - 1]: dp[i][j] = True # 1.
                          elif dp[i - 1][j - 1] and p[j - 1] == '.': dp[i][j] = True    # 2.
      ```

   

#### 2️⃣

### 🚩[20. 表示数值的字符串](https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/)

难度中等154

请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100"、"5e2"、"-123"、"3.1416"、"-1E-16"、"0123"都表示数值，但"12e"、"1a3.14"、"1.2.3"、"+-5"及"12e+5.4"都不是。

#### 2️⃣

```python
class Solution:
    def isNumber(self, s: str) -> bool:
        import re
        pattern = '\s*[+-]?((\d*\.?\d+)|(\d+\.))([Ee][+-]?\d+)?\s*'
        # pattern = "\\s*[+-]?((\\d*\\.?\\d+)|(\\d+\\.?))([eE][+-]?\\d+)?\\s*"
        # pattern = "\\s*[+-]?((\\d+)|(\\d*\\.\\d+)|(\\d+\\.\\d*))([eE][+-]?\\d+)?\\s*"
        sm = re.fullmatch(pattern, s)
        print(sm)
        if sm:
            return True
        else:
            return False
```

注意：

要用全匹配 `fullmatch()`



### ✅(20m) [21. 调整数组顺序使奇数位于偶数前面](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)

### ✅(15m) [22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)





### ✅(10m) [24. 反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)

### ✅(15m) [25. 合并两个排序的链表](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

核心代码：

```python
        while l1 and l2:            if l1.val <= l2.val:                cur.next = ListNode(l1.val)                l1 = l1.next            else:                cur.next = ListNode(l2.val)                l2 = l2.next            cur = cur.next  # 注意要往下走了！
```



### 🚩(30m)[剑指 Offer 26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)



```python
class Solution:
    def isSubStructure(self, A: TreeNode, B: TreeNode) -> bool:
        def compare(nodeA,nodeB):
            # B 被遍历空，返回True
            if not nodeB:
                return True
            # 防止 A.val 报错, 值不同，返回False
            if not nodeA or nodeA.val != nodeB.val:
                return False
            # 继续递归遍历后续子树是否相同
            return compare(nodeA.left, nodeB.left) or compare(nodeA.right, nodeB.right)
        if not A or not B:
            return False
        # 通过递归将A的结点分别和B进行比较，这里的 or 具有阻断效应，后面的递归调用不执行，直接向上返回
        return compare(A,B) or self.isSubStructure(A.left,B) or self.isSubStructure(A.right, B) 
```

#### 2️⃣ 注意：

**这里的 or 具有阻断效应，后面的递归调用不执行，直接向上返回**

### ✅(10m) [剑指 Offer 27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

### ✅（20m）[剑指 Offer 28. 对称的二叉树](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)

请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

```python
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        def isSym(left,right):
            if not left and not right:
                return True
            if not left or not right or left.val != right.val:
                return False
            return isSym(left.left, right.right) and isSym(left.right, right.left)
        if not root:
            return True
        return isSym(root.left,root.right)
```

#### 2️⃣

### 🚩(60m) [剑指 Offer 29. 顺时针打印矩阵](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)

#### 2️⃣

```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        l,r,t,b,res = 0, len(matrix[0])-1, 0, len(matrix)-1, []  # 注意减1啊
        while True :
            print(l,r,t,b,res)
            for i in range(l, r+1):
                res.append(matrix[t][i])
            t += 1
            if t > b: break
            for i in range(t, b+1):
                res.append(matrix[i][r])
            r -= 1
            if r < l: break
            for i in range(r, l-1, -1):
                res.append(matrix[b][i])
            b -= 1  
            if b < t: break          
            for i in range(b, t-1, -1):
                res.append(matrix[i][l])
            l += 1  
            if l > r: break          
        return res
```

```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        res = []
        while matrix:
            res += matrix.pop(0)
            # print(matrix)
            # 逆时针旋转（这里通过转置+倒序实现）
            matrix = list(zip(*matrix))[::-1]
            # print(matrix)
        return res
```

**注意： 矩阵逆时针旋转**

            # 逆时针旋转（这里通过转置+倒序实现）
            matrix = list(zip(*matrix))[::-1]

### ✅(30m) [剑指 Offer 30. 包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)

难度简单102

定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。

**示例:**

```
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.min();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.min();   --> 返回 -2.
```

**提示：**

1. 各函数的调用总次数不超过 20000 次



### 🚩(40m) [剑指 Offer 31. 栈的压入、弹出序列](https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)

```python
class Solution:
    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:        
        stack, i = [], 0
        for num in pushed:
            stack.append(num) # num 入栈
            while stack and stack[-1] == popped[i]: # 循环判断与出栈
                stack.pop()
                i += 1
        return not stack
```



### ✅(10m) [剑指 Offer 32 - I. 从上到下打印二叉树](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)

### ✅(10m) [剑指 Offer 32 - II. 从上到下打印二叉树 II](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

### ✅(10m) [剑指 Offer 32 - III. 从上到下打印二叉树 III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

注意：

1. ​      temp = collections.deque()

​      res.append(list(temp))  *# 注意要先转化为list*

2. 双端队列

   1.  if len(res)%2==0: temp.appendleft(node.val)

   ​        else: temp.append(node.val)

   2. ​        node = deque.popleft(0) *# 注意*

### ✅(20m) [剑指 Offer 42. 连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)

### ✅(20m) [剑指 Offer 46. 把数字翻译成字符串](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)

### ✅(15m) [剑指 Offer 47. 礼物的最大价值](https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/)

### ✅(15m) [剑指 Offer 50. 第一个只出现一次的字符](https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)

字典有序且效率高

[为什么Python 3.6以后字典有序并且效率更高？](https://www.cnblogs.com/xieqiankun/p/python_dict.html)

```
for key in 字典

for value in 字典.values()

for key, value in 字典.items()
```

### ✅(30m) [剑指 Offer 52. 两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

### ✅(15m) [剑指 Offer 53 - I. 在排序数组中查找数字 I](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)

### 🚩(30m) [剑指 Offer 53 - II. 0～n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)

### 🚩(30m) [剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

### ✅(40m) [剑指 Offer 55 - I. 二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)

#### C++ queue

初始化：`    queue<TreeNode*> q;`

判断为空：`while(!q.empty())`

取第一个元素：

```c++
                TreeNode* node = q.front;
                q.pop();
```

#### C++ 二叉树

初始化：`    queue<TreeNode*> q;`    

左右节点：

```c++
                if(node->left)   q.push(node->left);
                if(node->right)  q.push(node->right);
```

### 🚩(60m) [剑指 Offer 55 - II. 平衡二叉树](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/)



### 🚩(30m) [剑指 Offer 56 - I. 数组中数字出现的次数](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)

### 🚩(20m) [剑指 Offer 57. 和为s的两个数字](https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/)

#### **排序数组** —》 想 

**双指针法** 

#### 常数空间复杂度 想—》 

1、想原地inplace操作 

2、想用异或操作

### 🚩(20m) [剑指 Offer 57 - II. 和为s的连续正数序列](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)

解方程法

### ✅(10m) [剑指 Offer 58 - I. 翻转单词顺序](https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/)

### ✅(10m) [剑指 Offer 58 - II. 左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

### 🚩(10m) [剑指 Offer 59 - I. 滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)





### 🚩(20m) [剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)

#### ✅(20m) [剑指 Offer 63. 股票的最大利润](https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/)

C++ for循环时，记得初始化

```
        for(int i=0; i<prices.size(); i++){
        // do sth;
        }
```







### 🚩(20m) [剑指 Offer 64. 求1+2+…+n](https://leetcode-cn.com/problems/qiu-12n-lcof/)

#### 利用逻辑运算符的短路效应模拟条件表达式

逻辑运算符的短路效应：
常见的逻辑运算符有三种，即 “与 \&\& ”，“或 || ”，“非 ! ” ；而其有重要的短路效应，如下所示：

```
if(A && B)  // 若 A 为 false ，则 B 的判断不会执行（即短路），直接判定 A && B 为 false

if(A || B) // 若 A 为 true ，则 B 的判断不会执行（即短路），直接判定 A || B 为 true
本题需要实现 “当 n = 1n=1 时终止递归” 的需求，可通过短路效应实现。

n > 1 && sumNums(n - 1) // 当 n = 1 时 n > 1 不成立 ，此时 “短路” ，终止后续递归
```



```c++
class Solution {
public:
    int sumNums(int n) {
        // return n==0 ? 0 : n + sumNums(n-1);
        n && (n += sumNums(n-1));
        return n;
    }
};
```

### 🚩(30m) [剑指 Offer 65. 不用加减乘除做加法](https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/)

### 🚩(40m) [剑指 Offer 66. 构建乘积数组](https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/)

### 🚩(10m) [剑指 Offer 67. 把字符串转换成整数](https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/)

### 🚩 [剑指 Offer 68 - II. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

## 
