# leetcodeé¢˜ç›®æŒ‰ç±»å‹

## æ·±åº¦ä¼˜å…ˆæœç´¢DFS+é€’å½’

### dfsï¼ˆå›æº¯ï¼‰ç®—æ³•æ¡†æ¶

1. <font color="red">**æ ¸å¿ƒ**</font>ï¼šforå¾ªç¯é‡Œé¢çš„é€’å½’ï¼Œåœ¨é€’å½’è°ƒç”¨ä¹‹å‰åšé€‰æ‹©ï¼Œåœ¨è°ƒç”¨ä¹‹åæ’¤é”€é€‰æ‹©ã€‚
2. **<font color="red">3ä¸ªé—®é¢˜ï¼š</font>**
   1. è·¯å¾„ï¼š**å·²ç»åšçš„é€‰æ‹©**
   2. é€‰æ‹©åˆ—è¡¨ï¼šå½“å‰**å¯åšçš„é€‰æ‹©**
   3. ç»“æŸæ¡ä»¶ï¼šåˆ°è¾¾å†³ç­–æ ‘åº•å±‚ï¼Œ**æ— æ³•å†åšé€‰æ‹©çš„æ¡ä»¶**

```python
def backtrack(é€‰æ‹©åˆ—è¡¨, path):
	if æ»¡è¶³ç»“æŸæ¡ä»¶:
    result.add(path)
    return 
  
  for é€‰æ‹© in é€‰æ‹©åˆ—è¡¨:
    path.append(é€‰æ‹©)
    backtrack(é€‰æ‹©åˆ—è¡¨, path)
    path.pop()

result = []
path = []
backtrack(é€‰æ‹©åˆ—è¡¨, path)
return result
```

3. å¸¦æœ‰visitedçš„dfsæ¡†æ¶ï¼š

```python
def DFS(é€‰æ‹©åˆ—è¡¨, path):
	if æ»¡è¶³ç»“æŸæ¡ä»¶:
    result.add(path)
    return 
  
  visited.add(start)
  for é€‰æ‹© in é€‰æ‹©åˆ—è¡¨:
    path.append(é€‰æ‹©)
    backtrack(é€‰æ‹©åˆ—è¡¨, path)
    path.pop()
  visited.remove(start)

visited = set()
result = []
path = []
DFS(é€‰æ‹©åˆ—è¡¨, path)
return result
```

### äºŒå‰æ ‘çš„dfsï¼ˆè·¯å¾„æ€»å’Œ2ï¼‰

1. é€‰æ‹©åªæœ‰å·¦å­æ ‘å’Œå³å­æ ‘
2. æ— éœ€ visited

```python
def dfs(root, targetSum):        
    if not root:
        return   # æ³¨æ„ return  
    
    path.append(root.val)  # æ·»åŠ è·¯å¾„
    
    targetSum -= root.val
    if not root.left and not root.right and targetSum == 0: # å¦‚æœæ»¡è¶³æ¡ä»¶
        res.append(path[:])        
    
    dfs(root.left, targetSum)
    dfs(root.right, targetSum)
    
    path.pop()  						# æ³¨æ„è¦ å»æ‰è·¯å¾„

res = []
path = []
dfs(root,targetSum)
return res
```



### æ€»ç»“

[leetcodeå…¨æ’åˆ—è§£æ+å›æº¯äººä»¬è¯¦è§£+ç»ƒä¹ ](https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/)

### DFS ã€åŠ¨æ€è§„åˆ’ã€å›æº¯æ³•ã€é€’å½’ä¹‹é—´çš„å…³ç³»æ˜¯ä»€ä¹ˆï¼Ÿ

**å›æº¯æœç´¢**æ˜¯æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰çš„ä¸€ç§ã€‚å¯¹äºæŸä¸€ä¸ªæœç´¢æ ‘æ¥è¯´ï¼ˆæœç´¢æ ‘æ˜¯èµ·è®°å½•è·¯å¾„å’ŒçŠ¶æ€åˆ¤æ–­çš„ä½œç”¨ï¼‰ï¼Œå›æº¯å’ŒDFSï¼Œå…¶**ä¸»è¦çš„åŒºåˆ«**æ˜¯ï¼Œ**å›æº¯æ³•**åœ¨æ±‚è§£è¿‡ç¨‹ä¸­**ä¸ä¿ç•™å®Œæ•´çš„æ ‘ç»“æ„**ï¼Œè€Œ**æ·±åº¦ä¼˜å…ˆæœç´¢**åˆ™**è®°ä¸‹å®Œæ•´çš„æœç´¢æ ‘ã€‚**ä¸ºäº†å‡å°‘å­˜å‚¨ç©ºé—´ï¼Œåœ¨æ·±åº¦ä¼˜å…ˆæœç´¢ä¸­ï¼Œç”¨**æ ‡å¿—çš„æ–¹æ³•è®°å½•è®¿é—®è¿‡çš„çŠ¶æ€**ï¼Œè¿™ç§å¤„ç†æ–¹æ³•ä½¿å¾—æ·±åº¦ä¼˜å…ˆæœç´¢æ³•ä¸å›æº¯æ³•æ²¡ä»€ä¹ˆåŒºåˆ«äº†ã€‚

**é€’å½’**å°±æ˜¯**è‡ªæˆ‘è°ƒç”¨**ï¼Œç»å¸¸ä½œä¸ºä¸€ç§ç¼–ç¨‹çš„å®ç°æ–¹å¼ï¼Œæ¯”å¦‚é¢˜ä¸»é—®é¢˜ä¸­çš„DFS ã€åŠ¨æ€è§„åˆ’ã€å›æº¯æ³•éƒ½å¯ä»¥ç”¨é€’å½’æ¥å®ç°ï¼Œå½“ç„¶ä¹Ÿå¯ä»¥ç”¨éé€’å½’æ¥å®ç°ã€‚å¾ˆå¤šæ—¶å€™ä¸€ä¸ªæ¦‚å¿µä¹Ÿå¯ä»¥ç”¨é€’å½’çš„æ–¹å¼æ¥å®šä¹‰ï¼ˆæ¯”å¦‚gnuï¼‰ã€‚

**å›æº¯**æ˜¯ä¸€ç§**é€šç”¨çš„ç®—æ³•**ï¼ŒæŠŠé—®é¢˜åˆ†æ­¥è§£å†³ï¼Œåœ¨æ¯ä¸€æ­¥éƒ½è¯•éªŒæ‰€æœ‰çš„å¯èƒ½ï¼Œå½“å‘ç°å·²ç»æ‰¾åˆ°ä¸€ç§æ–¹å¼æˆ–è€…ç›®å‰è¿™ç§æ–¹å¼ä¸å¯èƒ½æ˜¯ç»“æœçš„æ—¶å€™ï¼Œé€€å›ä¸Šä¸€æ­¥ç»§ç»­å°è¯•å…¶ä»–å¯èƒ½ã€‚å¾ˆå¤šæ—¶å€™æ¯ä¸€æ­¥çš„å¤„ç†éƒ½æ˜¯ä¸€è‡´çš„ï¼Œè¿™æ—¶å€™ç”¨é€’å½’æ¥å®ç°å°±å¾ˆè‡ªç„¶ã€‚

**æ·±åº¦ä¼˜å…ˆæœç´¢**æ˜¯å½“**å›æº¯ç”¨äºæ ‘**çš„æ—¶å€™ã€‚å½“ç„¶äº†ï¼Œå‡ ä¹æ‰€æœ‰å¯ä»¥ç”¨å›æº¯è§£å†³çš„é—®é¢˜éƒ½å¯ä»¥è¡¨ç¤ºä¸ºæ ‘ã€‚é‚£ä¹ˆè¿™ä¿©åœ¨è¿™é‡Œå°±å‡ ä¹åŒä¹‰äº†ã€‚å¦‚æœä¸€ä¸ªé—®é¢˜è§£å†³çš„æ—¶å€™æ˜¾å¼åœ°ä½¿ç”¨äº†æ ‘ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å«å®ƒdfsã€‚å¾ˆå¤šæ—¶å€™æ²¡æœ‰ç”¨æ ‘æˆ‘ä»¬ä¹Ÿç®¡å®ƒå«dfsä¸¥æ ¼åœ°è¯´æ˜¯ä¸å¯¹çš„ï¼Œä½†æ˜¯dfsæ¯”å›æº¯æ‰“å­—çš„æ—¶å€™å¥½è¾“å…¥ã€‚åˆ«çš„å›ç­”é‡Œæåˆ°äº†ç æï¼Œå®é™…ä¸Šè¿™äºŒè€…éƒ½å¯ä»¥ç æã€‚

**åŠ¨æ€è§„åˆ’**ï¼Œå›æº¯å¯ä»¥ç”¨äºæ‰€æœ‰ç”¨ç©·ä¸¾æ³•å¯ä»¥è§£å†³çš„é—®é¢˜ï¼Œè€Œ<u>DPåªç”¨äº**å…·æœ‰æœ€ä¼˜å­ç»“æ„çš„é—®é¢˜**</u>ã€‚æ‰€ä»¥ä¸æ˜¯æ‰€æœ‰é—®é¢˜éƒ½é€‚åˆç”¨dpæ¥è§£å†³ï¼Œæ¯”å¦‚å…«çš‡åã€‚dpéœ€è¦å­˜è´®å­é—®é¢˜çš„è§£ï¼Œå›æº¯ä¸éœ€è¦ã€‚

#### å›æº¯ç®—æ³•

1. æ·±åº¦ä¼˜å…ˆéå†çš„ç‰¹æœ‰çš„ç°è±¡ï¼ŒèŠ‚çº¦ç©ºé—´  
   å…¨æ’åˆ—æ€è·¯ï¼š  
   åœ¨æšä¸¾ç¬¬ä¸€ä½çš„æ—¶å€™ï¼Œæœ‰ 3 ç§æƒ…å†µã€‚  
   åœ¨æšä¸¾ç¬¬äºŒä½çš„æ—¶å€™ï¼Œå‰é¢å·²ç»å‡ºç°è¿‡çš„æ•°å­—å°±ä¸èƒ½å†è¢«é€‰å–äº†ï¼›  
   åœ¨æšä¸¾ç¬¬ä¸‰ä½çš„æ—¶å€™ï¼Œå‰é¢ 2 ä¸ªå·²ç»é€‰æ‹©è¿‡çš„æ•°å­—å°±ä¸èƒ½å†è¢«é€‰å–äº†ã€‚  
   ![image.png](/img/in-post/20_07/0bf18f9b86a2542d1f6aa8db6cc45475fce5aa329a07ca02a9357c2ead81eec1-image.png)

ç¬¬ 1 æ­¥éƒ½æ˜¯å…ˆç”»å›¾ï¼Œç”»å›¾æ˜¯éå¸¸é‡è¦çš„ï¼Œåªæœ‰ç”»å›¾æ‰èƒ½å¸®åŠ©æˆ‘ä»¬æƒ³æ¸…æ¥šé€’å½’ç»“æ„ï¼Œæƒ³æ¸…æ¥šå¦‚ä½•å‰ªæ

æ­¥éª¤ï¼Œå³åœ¨ç”»å›¾çš„è¿‡ç¨‹ä¸­æ€è€ƒæ¸…æ¥šï¼š

1ã€åˆ†æ”¯å¦‚ä½•äº§ç”Ÿï¼›

2ã€é¢˜ç›®éœ€è¦çš„è§£åœ¨å“ªé‡Œï¼Ÿæ˜¯åœ¨å¶å­ç»“ç‚¹ã€è¿˜æ˜¯åœ¨éå¶å­ç»“ç‚¹ã€è¿˜æ˜¯åœ¨ä»è·Ÿç»“ç‚¹åˆ°å¶å­ç»“ç‚¹çš„è·¯å¾„ï¼Ÿ

3ã€å“ªäº›æœç´¢æ˜¯ä¼šäº§ç”Ÿä¸éœ€è¦çš„è§£çš„ï¼Ÿä¾‹å¦‚ï¼šäº§ç”Ÿé‡å¤æ˜¯ä»€ä¹ˆåŸå› ï¼Œå¦‚æœåœ¨æµ…å±‚å°±çŸ¥é“è¿™ä¸ªåˆ†æ”¯ä¸èƒ½äº§ç”Ÿéœ€è¦çš„ç»“æœï¼Œåº”è¯¥æå‰å‰ªæï¼Œå‰ªæçš„æ¡ä»¶æ˜¯ä»€ä¹ˆï¼Œä»£ç æ€ä¹ˆå†™ï¼Ÿ

ç»™å®šä¸€ä¸ª æ²¡æœ‰é‡å¤ æ•°å­—çš„åºåˆ—ï¼Œè¿”å›å…¶æ‰€æœ‰å¯èƒ½çš„å…¨æ’åˆ—ã€‚

#### æ•°ç»„æ·±æ‹·è´ã€æµ…æ‹·è´

    res.append(path[:])  # æ³¨æ„ç›¸å½“äºè¿™é‡Œåšä¸€æ¬¡æ‹·è´ã€‚å¦åˆ™è¾“å‡ºä¸ºå…¨ç©º


```python
# æµ…æ‹·è´, æŒ‡å‘åŒä¸€åœ°å€a = [2,3,34,4]b = aa.append(222)a, b
```


```python
# æ·±æ‹·è´ï¼Œ ä¸åŒåœ°å€a = [2,3,34,4]b = a[:]c = list(a)d = a*1import copye = copy.copy(a)a.append(222)a, b, c, d, e
```

#### æ­¥éª¤

1. æ²¿ç€æ ‘çš„æ·±åº¦éå†æ ‘çš„èŠ‚ç‚¹ï¼Œå°½å¯èƒ½æ·±çš„æœç´¢æ ‘çš„åˆ†æ”¯ã€‚
2. å½“èŠ‚ç‚¹vçš„æ‰€åœ¨è¾¹éƒ½å·±è¢«æ¢å¯»è¿‡ï¼Œæœç´¢å°†å›æº¯åˆ°å‘ç°èŠ‚ç‚¹vçš„é‚£æ¡è¾¹çš„èµ·å§‹èŠ‚ç‚¹ã€‚
3. å¦‚æœè¿˜å­˜åœ¨æœªè¢«å‘ç°çš„èŠ‚ç‚¹ï¼Œåˆ™é€‰æ‹©å…¶ä¸­ä¸€ä¸ªä½œä¸ºæºèŠ‚ç‚¹å¹¶é‡å¤ä»¥ä¸Šè¿‡ç¨‹ï¼Œæ•´ä¸ªè¿›ç¨‹åå¤è¿›è¡Œç›´åˆ°æ‰€æœ‰èŠ‚ç‚¹éƒ½è¢«è®¿é—®ä¸ºæ­¢ã€‚

#### æ¦‚æ‹¬

æ·±åº¦ä¼˜å…ˆæœç´¢çš„æ­¥éª¤åˆ†ä¸º 

1. é€’å½’ä¸‹å» 
2. å›æº¯ä¸Šæ¥ã€‚

é¡¾åæ€ä¹‰ï¼Œæ·±åº¦ä¼˜å…ˆï¼Œåˆ™æ˜¯ä»¥æ·±åº¦ä¸ºå‡†åˆ™ï¼Œå…ˆ**ä¸€æ¡è·¯èµ°åˆ°åº•**ï¼Œç›´åˆ°è¾¾åˆ°ç›®æ ‡ã€‚è¿™é‡Œç§°ä¹‹ä¸ºé€’å½’ä¸‹å»ã€‚

å¦åˆ™æ—¢æ²¡æœ‰è¾¾åˆ°ç›®æ ‡åˆæ— è·¯å¯èµ°äº†ï¼Œé‚£ä¹ˆåˆ™**é€€å›åˆ°ä¸Šä¸€æ­¥çš„çŠ¶æ€**ï¼Œèµ°å…¶ä»–è·¯ã€‚è¿™ä¾¿æ˜¯å›æº¯ä¸Šæ¥ã€‚

### ğŸš©(20m)  101. å¯¹ç§°äºŒå‰æ ‘

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ£€æŸ¥å®ƒæ˜¯å¦æ˜¯é•œåƒå¯¹ç§°çš„ã€‚

```
ä¾‹å¦‚ï¼ŒäºŒå‰æ ‘ [1,2,2,3,4,4,3] æ˜¯å¯¹ç§°çš„ã€‚    1   / \  2   2 / \ / \3  4 4  3 ä½†æ˜¯ä¸‹é¢è¿™ä¸ª [1,2,2,null,3,null,3] åˆ™ä¸æ˜¯é•œåƒå¯¹ç§°çš„:    1   / \  2   2   \   \   3    3  è¿›é˜¶ï¼šä½ å¯ä»¥è¿ç”¨é€’å½’å’Œè¿­ä»£ä¸¤ç§æ–¹æ³•è§£å†³è¿™ä¸ªé—®é¢˜å—ï¼Ÿ
```

#### 2ï¸âƒ£ä½¿ç”¨é€’å½’çš„æ€æƒ³

 å¦‚æœåŒæ—¶æ»¡è¶³ä¸‹é¢çš„æ¡ä»¶ï¼Œä¸¤ä¸ªæ ‘äº’ä¸ºé•œåƒï¼š

1. å®ƒä»¬çš„ä¸¤ä¸ªæ ¹ç»“ç‚¹å…·æœ‰ç›¸åŒçš„å€¼
2. æ¯ä¸ªæ ‘çš„å³å­æ ‘éƒ½ä¸å¦ä¸€ä¸ªæ ‘çš„å·¦å­æ ‘é•œåƒå¯¹ç§°


```python
# guanjieclass Solution:    def isSymmetric(self, root: TreeNode) -> bool:        if not root: return         return self.check(root.left, root.right)            def check(self, left, right):        if left is None and right is None: return True        if left is None or right is None: return False        if left.val != right.val : return False        return self.check(left.left, right.right) and self.check(left.right, right.left)                            
```

### ğŸš©(60m)  394. å­—ç¬¦ä¸²è§£ç 

ç»™å®šä¸€ä¸ªç»è¿‡ç¼–ç çš„å­—ç¬¦ä¸²ï¼Œè¿”å›å®ƒè§£ç åçš„å­—ç¬¦ä¸²ã€‚

ç¼–ç è§„åˆ™ä¸º: k[encoded_string]ï¼Œè¡¨ç¤ºå…¶ä¸­æ–¹æ‹¬å·å†…éƒ¨çš„ encoded_string æ­£å¥½é‡å¤ k æ¬¡ã€‚æ³¨æ„ k ä¿è¯ä¸ºæ­£æ•´æ•°ã€‚

ä½ å¯ä»¥è®¤ä¸ºè¾“å…¥å­—ç¬¦ä¸²æ€»æ˜¯æœ‰æ•ˆçš„ï¼›è¾“å…¥å­—ç¬¦ä¸²ä¸­æ²¡æœ‰é¢å¤–çš„ç©ºæ ¼ï¼Œä¸”è¾“å…¥çš„æ–¹æ‹¬å·æ€»æ˜¯ç¬¦åˆæ ¼å¼è¦æ±‚çš„ã€‚

æ­¤å¤–ï¼Œä½ å¯ä»¥è®¤ä¸ºåŸå§‹æ•°æ®ä¸åŒ…å«æ•°å­—ï¼Œæ‰€æœ‰çš„æ•°å­—åªè¡¨ç¤ºé‡å¤çš„æ¬¡æ•° k ï¼Œä¾‹å¦‚ä¸ä¼šå‡ºç°åƒ 3a æˆ– 2[4] çš„è¾“å…¥ã€‚

 

```
ç¤ºä¾‹ 1ï¼šè¾“å…¥ï¼šs = "3[a]2[bc]"è¾“å‡ºï¼š"aaabcbc"ç¤ºä¾‹ 2ï¼šè¾“å…¥ï¼šs = "3[a2[c]]"è¾“å‡ºï¼š"accaccacc"ç¤ºä¾‹ 3ï¼šè¾“å…¥ï¼šs = "2[abc]3[cd]ef"è¾“å‡ºï¼š"abcabccdcdcdef"ç¤ºä¾‹ 4ï¼šè¾“å…¥ï¼šs = "abc3[cd]xyz"è¾“å‡ºï¼š"abccdcdcdxyz"
```

#### 2ï¸âƒ£æ ˆå’Œé€’å½’ä½¿ç”¨


```python
class Solution:    def decodeString(self, s: str) -> str:        def dfs(i):            res, multi = "", 0            while i<len(s):                if '0' <= s[i] <= '9':                    multi = multi*10 + s[i]                elif s[i] == '[':                    # æ³¨æ„ï¼Œè¿”å›içš„å«ä¹‰æ˜¯æ›´æ–°ä¸Šå±‚é€’å½’æŒ‡é’ˆä½ç½®ï¼Œå› ä¸ºå†…å±‚é€’å½’å·²ç»åƒæ‰ä¸€ä¸²strï¼Œè‹¥ä¸è·Ÿæ–°iï¼Œ                    # å¤–å±‚ä»ç„¶ä»i+1å¼€å§‹ï¼Œåˆ™ä¼šé‡å¤å¤„ç†å†…å±‚å¤„ç†è¿‡çš„ä¸€ä¸²strã€‚                    i, tmp = dfs(i+1)                      res += multi * tmp                    multi = 0                elif s[i] == ']':                    return i,res                else: res += s[i]                i+=1            return res        return dfs(0)
```

###  ğŸš©105. ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘

æ ¹æ®ä¸€æ£µæ ‘çš„å‰åºéå†ä¸ä¸­åºéå†æ„é€ äºŒå‰æ ‘ã€‚

æ³¨æ„:

ä½ å¯ä»¥å‡è®¾æ ‘ä¸­æ²¡æœ‰é‡å¤çš„å…ƒç´ ã€‚

ä¾‹å¦‚ï¼Œç»™å‡º

```
å‰åºéå† preorder = [3,9,20,,7]ä¸­åºéå† inorder = [9,3,15,20,7]è¿”å›å¦‚ä¸‹çš„äºŒå‰æ ‘ï¼š    3   / \  9  20    /  \   15   7
```

#### 2ï¸âƒ£


```python
class Solution:    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:        # def helper():            if not preorder:                return None            root = TreeNode(preorder[0])            mid = inorder.index(preorder[0])            root.left = self.buildTree(preorder[1:mid+1], inorder[:mid]) # ä¸»è¦è¦+1            root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])                        return root
```

###  ğŸš©114. äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼ŒåŸåœ°å°†å®ƒå±•å¼€ä¸ºä¸€ä¸ªå•é“¾è¡¨ã€‚


```
ä¾‹å¦‚ï¼Œç»™å®šäºŒå‰æ ‘    1   / \  2   5 / \   \3   4   6å°†å…¶å±•å¼€ä¸ºï¼š1 \  2   \    3     \      4       \        5         \          6
```


```python
# å‰åºéå†class Solution:    def flatten(self, root: TreeNode) -> None:        """        Do not return anything, modify root in-place instead.        """        if root.left:            root.next = root.left        elif root.right:            root.next = flatten(root.left)
```


###   ğŸš©ï¼ˆå›°éš¾ï¼‰679. 24 ç‚¹æ¸¸æˆ

ä½ æœ‰ 4 å¼ å†™æœ‰ 1 åˆ° 9 æ•°å­—çš„ç‰Œã€‚ä½ éœ€è¦åˆ¤æ–­æ˜¯å¦èƒ½é€šè¿‡ *ï¼Œ/ï¼Œ+ï¼Œ-ï¼Œ(ï¼Œ) çš„è¿ç®—å¾—åˆ° 24ã€‚

```python
ç¤ºä¾‹ 1:è¾“å…¥: [4, 1, 8, 7]è¾“å‡º: Trueè§£é‡Š: (8-4) * (7-1) = 24ç¤ºä¾‹ 2:è¾“å…¥: [1, 2, 1, 2]è¾“å‡º: Falseæ³¨æ„:é™¤æ³•è¿ç®—ç¬¦ / è¡¨ç¤ºå®æ•°é™¤æ³•ï¼Œè€Œä¸æ˜¯æ•´æ•°é™¤æ³•ã€‚ä¾‹å¦‚ 4 / (1 - 2/3) = 12 ã€‚æ¯ä¸ªè¿ç®—ç¬¦å¯¹ä¸¤ä¸ªæ•°è¿›è¡Œè¿ç®—ã€‚ç‰¹åˆ«æ˜¯æˆ‘ä»¬ä¸èƒ½ç”¨ - ä½œä¸ºä¸€å…ƒè¿ç®—ç¬¦ã€‚ä¾‹å¦‚ï¼Œ[1, 1, 1, 1] ä½œä¸ºè¾“å…¥æ—¶ï¼Œè¡¨è¾¾å¼ -1 - 1 - 1 - 1 æ˜¯ä¸å…è®¸çš„ã€‚ä½ ä¸èƒ½å°†æ•°å­—è¿æ¥åœ¨ä¸€èµ·ã€‚ä¾‹å¦‚ï¼Œè¾“å…¥ä¸º [1, 2, 1, 2] æ—¶ï¼Œä¸èƒ½å†™æˆ 12 + 12 ã€‚
```


```python
class Solution:    def judgePoint24(self, nums: List[int]) -> bool:        for i in range(4):            if         def dfs(nums, depth):            
```


```python
from typing import Listnums = [4, 1, 8, 7]solution = Solution()result = solution.judgePoint24(nums)result
```

### âœ…(20m)[79. å•è¯æœç´¢](https://leetcode-cn.com/problems/word-search/)

ç»™å®šä¸€ä¸ªäºŒç»´ç½‘æ ¼å’Œä¸€ä¸ªå•è¯ï¼Œæ‰¾å‡ºè¯¥å•è¯æ˜¯å¦å­˜åœ¨äºç½‘æ ¼ä¸­ã€‚

å•è¯å¿…é¡»æŒ‰ç…§å­—æ¯é¡ºåºï¼Œé€šè¿‡ç›¸é‚»çš„å•å…ƒæ ¼å†…çš„å­—æ¯æ„æˆï¼Œå…¶ä¸­â€œç›¸é‚»â€å•å…ƒæ ¼æ˜¯é‚£äº›æ°´å¹³ç›¸é‚»æˆ–å‚ç›´ç›¸é‚»çš„å•å…ƒæ ¼ã€‚åŒä¸€ä¸ªå•å…ƒæ ¼å†…çš„å­—æ¯ä¸å…è®¸è¢«é‡å¤ä½¿ç”¨ã€‚

```
# ç¤ºä¾‹board =[  ['A','B','C','E'],  ['S','F','C','S'],  ['A','D','E','E']]ç»™å®š word = "ABCCED", è¿”å› trueç»™å®š word = "SEE", è¿”å› trueç»™å®š word = "ABCB", è¿”å› false
```

#### â‘£

```python
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

        def check(i: int, j: int, k: int) -> bool:
            if board[i][j] != word[k]:
                return False
            if k == len(word) - 1:
                return True
            
            visited.add((i, j))
            result = False
            for di, dj in directions:
                newi, newj = i + di, j + dj
                if 0 <= newi < len(board) and 0 <= newj < len(board[0]):
                    if (newi, newj) not in visited:
                        if check(newi, newj, k + 1):
                            result = True
                            break
            
            visited.remove((i, j))
            return result

        h, w = len(board), len(board[0])
        visited = set()
        for i in range(h):
            for j in range(w):
                if check(i, j, 0):
                    return True
        
        return False
```



#### 2ï¸âƒ£

### âœ… (20m) [46. å…¨æ’åˆ—](https://leetcode-cn.com/problems/permutations/)

ç»™å®šä¸€ä¸ª **æ²¡æœ‰é‡å¤** æ•°å­—çš„åºåˆ—ï¼Œè¿”å›å…¶æ‰€æœ‰å¯èƒ½çš„å…¨æ’åˆ—ã€‚

**ç¤ºä¾‹:**

```
è¾“å…¥: [1,2,3]è¾“å‡º:[  [1,2,3],  [1,3,2],  [2,1,3],  [2,3,1],  [3,1,2],  [3,2,1]] 
```

#### 2ï¸âƒ£   


```python
class Solution:    
  def permute(self, nums: List[int]) -> List[List[int]]:        
    if depth == size:            
      res.append(path[:])            
      return                 
    for i in range(size):            
      if not used[i]:                
        used[i] = True                
        path.append(nums[i])                                
        dfs(nums, size, depth+1, path, used, res)                                
        used[i] = False                
        path.pop()                        
        size = len(nums)        
        if size == 0:            
          return []                
        used = [False for _ in range(size)]        
        res = []        
        dfs(nums, size, 0, [], used, res)        
        return res        
```


```python
from typing import Listnums = [1,2,4]solution = Solution()result = solution.permute(nums)result
```

#### 3ï¸âƒ£

```python
class Solution:    def __init__(self):        self.result = []     def permute(self, nums: List[int]) -> List[List[int]]:        def permute_sub(nums,path):            if len(path) == len(nums):                self.result.append(path[:])            for num in nums:                if num not in path:                    path.append(num) # åšé€‰æ‹©                    permute_sub(nums,path) # é€’å½’                    path.pop() # æ’¤é”€é€‰æ‹©                permute_sub(nums,[])        return self.result
```

#### â‘£

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        def helper(path, nums):
            if len(path) == len(nums):
                res.append(path)
            for i in nums:
                if i not in path:
                    helper(path+[i], nums)
        
        res = []
        path = []   
        helper(path, nums)     
        return res
```

æ€»ç»“ï¼š

1. åœ¨basecaseé‡Œï¼Œæ³¨æ„ï¼Œæ»¡è¶³æ¡ä»¶äº†å°±è¦returnå‡ºå»
2. ç»„åˆé—®é¢˜éœ€è¦åšé€‰æ‹©å‰æ·»åŠ åˆ¤æ–­ï¼Œ**è·³è¿‡ä¸æ»¡è¶³æ¡ä»¶çš„é€‰æ‹©**



### âœ…(60m) [51. N çš‡å](https://leetcode-cn.com/problems/n-queens/)

éš¾åº¦å›°éš¾725

**n çš‡åé—®é¢˜** ç ”ç©¶çš„æ˜¯å¦‚ä½•å°† `n` ä¸ªçš‡åæ”¾ç½®åœ¨ `nÃ—n` çš„æ£‹ç›˜ä¸Šï¼Œå¹¶ä¸”ä½¿çš‡åå½¼æ­¤ä¹‹é—´ä¸èƒ½ç›¸äº’æ”»å‡»ã€‚

ç»™ä½ ä¸€ä¸ªæ•´æ•° `n` ï¼Œè¿”å›æ‰€æœ‰ä¸åŒçš„ **n çš‡åé—®é¢˜** çš„è§£å†³æ–¹æ¡ˆã€‚

æ¯ä¸€ç§è§£æ³•åŒ…å«ä¸€ä¸ªä¸åŒçš„ **n çš‡åé—®é¢˜** çš„æ£‹å­æ”¾ç½®æ–¹æ¡ˆï¼Œè¯¥æ–¹æ¡ˆä¸­ `'Q'` å’Œ `'.'` åˆ†åˆ«ä»£è¡¨äº†çš‡åå’Œç©ºä½ã€‚

 

**ç¤ºä¾‹ 1ï¼š**

<img src="/img/in-post/20_07/queens.jpg" alt="img" style="zoom:50%;" />

```
è¾“å…¥ï¼šn = 4
è¾“å‡ºï¼š[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
è§£é‡Šï¼šå¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œ4 çš‡åé—®é¢˜å­˜åœ¨ä¸¤ä¸ªä¸åŒçš„è§£æ³•ã€‚
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼šn = 1
è¾“å‡ºï¼š[["Q"]]
```

```python
class Solution:
    def __init__(self):
        self.result = [] 
    def solveNQueens(self, n: int) -> List[List[str]]:
        def solveNQueens_sub(n, path, diagonal1, diagonal2):
            if len(path) == n:
                self.result.append(path[:])
            for num in range(n):
                if num not in path and len(path) - num not in diagonal1 and len(path) + num not in diagonal2:
                    diagonal1.add(len(path) - num)
                    diagonal2.add(len(path) + num)
                    path.append(num) # åšé€‰æ‹©
                    solveNQueens_sub(n,path,diagonal1,diagonal2) # é€’å½’
                    path.pop() # æ’¤é”€é€‰æ‹©
                    diagonal1.remove(len(path) - num)  # æ³¨æ„é•¿åº¦è¦æ˜¯å½“å‰çš„é•¿åº¦ï¼Œå’Œä¸Šé¢çš„addä¿æŒä¸€è‡´
                    diagonal2.remove(len(path) + num)

        diagonal1, diagonal2 = set(), set()   # ç”¨setå®šä¹‰æ›´å®¹æ˜“ï¼Œå¤æ‚åº¦æ¯”è¾ƒä½ï¼Œä¸ºO(log(n))
        solveNQueens_sub(n,[],diagonal1,diagonal2)
        self.result.sort()
        return [["."*index + "Q" + (n-index-1)*"." for index in path] for path in self.result]
```

æ€»ç»“ï¼š

1. æŸ¥æ‰¾æ—¶å¯ä»¥è€ƒè™‘ç”¨ $set$ï¼Œå®šä¹‰æ›´å®¹æ˜“ï¼Œå¤æ‚åº¦æ¯”è¾ƒä½ï¼Œä¸º$O(log(n))$ã€‚è™½ç„¶ $dict$å¤æ‚åº¦ä¸º $O(1)$ï¼Œä½†æ˜¯ç”±äºæœ‰å“ˆå¸ŒåŒ–çš„è¿‡ç¨‹ï¼Œæ‰€ä»¥æ—¶é—´é€šå¸¸ä¹Ÿæ²¡æœ‰å°‘ã€‚

2. æ³¨æ„å›æº¯å‰åï¼Œé•¿åº¦è¦æ˜¯å½“å‰çš„é•¿åº¦ï¼Œå’Œä¸Šé¢çš„addä¿æŒä¸€è‡´

   ```python
                       diagonal1.add(len(path) - num)
                       diagonal2.add(len(path) + num)
                       path.append(num) # åšé€‰æ‹©
                       solveNQueens_sub(n,path,diagonal1,diagonal2) # é€’å½’
                       path.pop() # æ’¤é”€é€‰æ‹©
                       diagonal1.remove(len(path) - num)  # æ³¨æ„é•¿åº¦è¦æ˜¯å½“å‰çš„é•¿åº¦ï¼Œå’Œä¸Šé¢çš„addä¿æŒä¸€è‡´
                       diagonal2.remove(len(path) + num)
   ```


#### ğŸš©(30m)[78. å­é›†](https://leetcode-cn.com/problems/subsets/)

éš¾åº¦ä¸­ç­‰995

ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` ï¼Œæ•°ç»„ä¸­çš„å…ƒç´  **äº’ä¸ç›¸åŒ** ã€‚è¿”å›è¯¥æ•°ç»„æ‰€æœ‰å¯èƒ½çš„å­é›†ï¼ˆå¹‚é›†ï¼‰ã€‚

è§£é›† **ä¸èƒ½** åŒ…å«é‡å¤çš„å­é›†ã€‚ä½ å¯ä»¥æŒ‰ **ä»»æ„é¡ºåº** è¿”å›è§£é›†ã€‚

 

**ç¤ºä¾‹ 1ï¼š**

```
è¾“å…¥ï¼šnums = [1,2,3]
è¾“å‡ºï¼š[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼šnums = [0]
è¾“å‡ºï¼š[[],[0]]
```



```python
class Solution:    def subsets(self, nums: List[int]) -> List[List[int]]:        def backtrack(nums,start,track):             res.append(track[:])            for i in range(start,len(nums)): # ä»startå¼€å§‹å¯ä»¥é¿å…é‡å¤                track.append(nums[i])                backtrack(nums,i+1,track)                track.pop()        res = []        track = []        backtrack(nums,0,track)        return res
```

### âœ…(40m)[77. ç»„åˆ](https://leetcode-cn.com/problems/combinations/)

éš¾åº¦ä¸­ç­‰499

ç»™å®šä¸¤ä¸ªæ•´æ•° *n* å’Œ *k*ï¼Œè¿”å› 1 ... *n* ä¸­æ‰€æœ‰å¯èƒ½çš„ *k* ä¸ªæ•°çš„ç»„åˆã€‚

**ç¤ºä¾‹:**

```
è¾“å…¥: n = 4, k = 2
è¾“å‡º:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

æ€»ç»“ï¼š

1. å›æº¯ç®—æ³•

```python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        def backtrack(start,path): 
            if len(path) == k:
                print(path)
                result.append(path[:])
            for i in range(start,n+1):
                path.append(i)
                backtrack(i+1,path)  # æ³¨æ„è¿™é‡Œæ˜¯i+1
                path.pop()
        
        result = []
        path = []
        backtrack(1,path)
        return result
        

```

2. æ³¨æ„å¼€å§‹çš„ä½ç½®ï¼š `backtrack(i+1,path)  # æ³¨æ„è¿™é‡Œæ˜¯i+1`ï¼Œ è¿™æ ·æ‰èƒ½ä¿è¯æ¯æ¬¡éƒ½æ¯”å½“å‰å¤§ã€‚

### ğŸš© [22. æ‹¬å·ç”Ÿæˆ](https://leetcode-cn.com/problems/generate-parentheses/)

éš¾åº¦ä¸­ç­‰1566

æ•°å­— `n` ä»£è¡¨ç”Ÿæˆæ‹¬å·çš„å¯¹æ•°ï¼Œè¯·ä½ è®¾è®¡ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºèƒ½å¤Ÿç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„å¹¶ä¸” **æœ‰æ•ˆçš„** æ‹¬å·ç»„åˆã€‚

 

**ç¤ºä¾‹ 1ï¼š**

```
è¾“å…¥ï¼šn = 3
è¾“å‡ºï¼š["((()))","(()())","(())()","()(())","()()()"]
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼šn = 1
è¾“å‡ºï¼š["()"]
```



```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        def backtrack(left,right,track,res):
            if left<0 or right<0:
                return 
            if right < left:
                return 
            if left==0 and right ==0:
                res.append(track)
                return 
            
            backtrack(left-1,right,track+'(',res)
            backtrack(left,right-1,track+')',res)
        
        if n==0:
            return {}
        res = []
        track = ""
        backtrack(n,n,track,res)
        return res
```

### ğŸš©(30m) [17. ç”µè¯å·ç çš„å­—æ¯ç»„åˆ](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

ç»™å®šä¸€ä¸ªä»…åŒ…å«æ•°å­—Â `2-9`Â çš„å­—ç¬¦ä¸²ï¼Œè¿”å›æ‰€æœ‰å®ƒèƒ½è¡¨ç¤ºçš„å­—æ¯ç»„åˆã€‚

ç»™å‡ºæ•°å­—åˆ°å­—æ¯çš„æ˜ å°„å¦‚ä¸‹(ä¸ç”µè¯æŒ‰é”®ç›¸åŒ)ã€‚æ³¨æ„ 1 ä¸å¯¹åº”ä»»ä½•å­—æ¯ã€‚

![](/img/in-post/20_07/17_telephone_keypad.png)

**ç¤ºä¾‹:**

```  
    è¾“å…¥ï¼š"23" 
    è¾“å‡ºï¼š["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]. 
```

#### 2ï¸âƒ£

```python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits: return []

        phone = {'2':['a','b','c'],
                 '3':['d','e','f'],
                 '4':['g','h','i'],
                 '5':['j','k','l'],
                 '6':['m','n','o'],
                 '7':['p','q','r','s'],
                 '8':['t','u','v'],
                 '9':['w','x','y','z']}
                
        def backtrack(conbination,nextdigit):
            if len(nextdigit) == 0:
                res.append(conbination)
            else:
                for letter in phone[nextdigit[0]]:
                    backtrack(conbination + letter,nextdigit[1:])

        res = []
        backtrack('',digits)  # è·¯å¾„ï¼Œ é€‰æ‹©
        return res
```





### ğŸš©(30m) [100. ç›¸åŒçš„æ ‘](https://leetcode-cn.com/problems/same-tree/)

éš¾åº¦ç®€å•634æ”¶è—åˆ†äº«åˆ‡æ¢ä¸ºè‹±æ–‡æ¥æ”¶åŠ¨æ€åé¦ˆ

ç»™ä½ ä¸¤æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `p` å’Œ `q` ï¼Œç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥æ£€éªŒè¿™ä¸¤æ£µæ ‘æ˜¯å¦ç›¸åŒã€‚

å¦‚æœä¸¤ä¸ªæ ‘åœ¨ç»“æ„ä¸Šç›¸åŒï¼Œå¹¶ä¸”èŠ‚ç‚¹å…·æœ‰ç›¸åŒçš„å€¼ï¼Œåˆ™è®¤ä¸ºå®ƒä»¬æ˜¯ç›¸åŒçš„ã€‚

 

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        if not p and not q:
            return True
        elif not p or not q :
            return False
        elif p.val != q.val:
            return False
        else:
            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)
            
```

### ğŸš©(20m) [112. è·¯å¾„æ€»å’Œ](https://leetcode-cn.com/problems/path-sum/)

éš¾åº¦ç®€å•600æ”¶è—åˆ†äº«åˆ‡æ¢ä¸ºè‹±æ–‡æ¥æ”¶åŠ¨æ€åé¦ˆ

ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` å’Œä¸€ä¸ªè¡¨ç¤ºç›®æ ‡å’Œçš„æ•´æ•° `targetSum` ï¼Œåˆ¤æ–­è¯¥æ ‘ä¸­æ˜¯å¦å­˜åœ¨ **æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹** çš„è·¯å¾„ï¼Œè¿™æ¡è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹å€¼ç›¸åŠ ç­‰äºç›®æ ‡å’Œ `targetSum` ã€‚

**å¶å­èŠ‚ç‚¹** æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚



```python
class Solution:
    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:
        if not root:
            return False   # æ³¨æ„è¦return falseï¼ï¼ï¼ï¼Œå› ä¸ºæ˜¯or
        targetSum -= root.val
        if not root.left and not root.right:
            return targetSum == 0      
        return self.hasPathSum(root.left, targetSum) or self.hasPathSum(root.right, targetSum)

```



        if not root:
            return False   # æ³¨æ„è¦return falseï¼ï¼ï¼ï¼Œå› ä¸ºæ˜¯or

### ğŸš©(30m) [113. è·¯å¾„æ€»å’Œ II](https://leetcode-cn.com/problems/path-sum-ii/)

éš¾åº¦ä¸­ç­‰508æ”¶è—åˆ†äº«åˆ‡æ¢ä¸ºè‹±æ–‡æ¥æ”¶åŠ¨æ€åé¦ˆ

ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` å’Œä¸€ä¸ªæ•´æ•°ç›®æ ‡å’Œ `targetSum` ï¼Œæ‰¾å‡ºæ‰€æœ‰ **ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹** è·¯å¾„æ€»å’Œç­‰äºç»™å®šç›®æ ‡å’Œçš„è·¯å¾„ã€‚

**å¶å­èŠ‚ç‚¹** æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚



```python
class Solution:
    def pathSum(self, root: TreeNode, targetSum: int) -> List[List[int]]:
        res = []
        path = []
        def dfs(root, targetSum):        
            if not root:
                return   # æ³¨æ„ return  
            
            path.append(root.val)  # æ·»åŠ è·¯å¾„

            targetSum -= root.val
            if not root.left and not root.right and targetSum == 0:
                res.append(path[:])       
            dfs(root.left, targetSum)
            dfs(root.right, targetSum)
        
            path.pop()  # æ³¨æ„è¦ å»æ‰è·¯å¾„

        dfs(root,targetSum)
        return res
```

### âœ…(30m) [129. æ±‚æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹æ•°å­—ä¹‹å’Œ](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)

éš¾åº¦ä¸­ç­‰367æ”¶è—åˆ†äº«åˆ‡æ¢ä¸ºè‹±æ–‡æ¥æ”¶åŠ¨æ€åé¦ˆ

ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œæ ‘ä¸­æ¯ä¸ªèŠ‚ç‚¹éƒ½å­˜æ”¾æœ‰ä¸€ä¸ª `0` åˆ° `9` ä¹‹é—´çš„æ•°å­—ã€‚

æ¯æ¡ä»æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹çš„è·¯å¾„éƒ½ä»£è¡¨ä¸€ä¸ªæ•°å­—ï¼š

- ä¾‹å¦‚ï¼Œä»æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹çš„è·¯å¾„ `1 -> 2 -> 3` è¡¨ç¤ºæ•°å­— `123` ã€‚

è®¡ç®—ä»æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹ç”Ÿæˆçš„ **æ‰€æœ‰æ•°å­—ä¹‹å’Œ** ã€‚

**å¶èŠ‚ç‚¹** æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚

```python
class Solution:
    def sumNumbers(self, root: TreeNode) -> int:
        def dfs(root, path, res):
            if not root:
                return 

            path = path*10 + root.val
            # print(path)

            if not root.left and not root.right:
                res.append(path)

            dfs(root.left, path, res)
            dfs(root.right, path, res)

            path //= 10

        res = []  # æ³¨æ„è¦æŠŠreså®šä¹‰æˆæ•°ç»„ï¼Œæ‰ä¼šæ‰ä¼ å‚çš„è¿‡ç¨‹æ”¹å˜
        path = 0
        dfs(root, path, res)

        return sum(res)
```



æ³¨æ„è¦æŠŠreså®šä¹‰æˆæ•°ç»„ï¼Œæ‰ä¼šæ‰ä¼ å‚çš„è¿‡ç¨‹æ”¹å˜













