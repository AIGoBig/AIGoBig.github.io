# leetcodeé¢˜ç›®æŒ‰ç±»å‹

## é“¾è¡¨

### éå†æ¡†æ¶

é“¾è¡¨éå†æ¡†æ¶,å…¼å…·è¿­ä»£å’Œé€’å½’ç»“æ„: 

```C++
/* åŸºæœ¬çš„å•é“¾è¡¨èŠ‚ç‚¹ */ 
class ListNode {     
    int val;     
    ListNode next; 
} 
void traverse(ListNode head) {     
    for (ListNode p = head; p != null; p = p.next) {         
        // è¿­ä»£è®¿é—® p.val     
    } 
} 
void traverse(ListNode head) {     
    // é€’å½’è®¿é—® head.val     
    traverse(head.next)
}
```

Pythonï¼š

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
def traverse(head)ï¼š
		p = head
    while p:      
      	# è¿­ä»£è®¿é—® p.val     
      	p = p.next
def traverse(head)ï¼š
    # é€’å½’è®¿é—® head.val     
    traverse(head.next)
```

### æ€»ç»“

#### æ¦‚å¿µ

1. é“¾è¡¨å…è®¸æ’å…¥å’Œç§»é™¤è¡¨ä¸Šä»»æ„ä½ç½®ä¸Šçš„èŠ‚ç‚¹ï¼Œä½†æ˜¯ä¸å…è®¸éšæœºå­˜å–ã€‚é“¾è¡¨æœ‰å¾ˆå¤šç§ä¸åŒçš„ç±»å‹ï¼šå•å‘é“¾è¡¨ï¼ŒåŒå‘é“¾è¡¨ä»¥åŠå¾ªç¯é“¾è¡¨ã€‚
   é“¾è¡¨é€šå¸¸å¯ä»¥è¡ç”Ÿå‡ºå¾ªç¯é“¾è¡¨ï¼Œé™æ€é“¾è¡¨ï¼ŒåŒé“¾è¡¨ç­‰ã€‚å¯¹äºé“¾è¡¨ä½¿ç”¨ï¼Œéœ€è¦æ³¨æ„å¤´ç»“ç‚¹çš„ä½¿ç”¨ã€‚

2. é“¾è¡¨ä¸­çš„â€œå“¨å…µâ€èŠ‚ç‚¹æ˜¯è§£å†³è¾¹ç•Œé—®é¢˜çš„ï¼Œä¸å‚ä¸ä¸šåŠ¡é€»è¾‘ã€‚å¦‚æœæˆ‘ä»¬å¼•å…¥â€œå“¨å…µâ€èŠ‚ç‚¹ï¼Œåˆ™ä¸ç®¡é“¾è¡¨æ˜¯å¦ä¸ºç©ºï¼ŒheadæŒ‡é’ˆéƒ½ä¼šæŒ‡å‘è¿™ä¸ªâ€œå“¨å…µâ€èŠ‚ç‚¹ã€‚æˆ‘ä»¬æŠŠè¿™ç§æœ‰â€œå“¨å…µâ€èŠ‚ç‚¹çš„é“¾è¡¨ç§°ä¸ºå¸¦å¤´é“¾è¡¨ï¼Œç›¸åï¼Œæ²¡æœ‰â€œå“¨å…µâ€èŠ‚ç‚¹çš„é“¾è¡¨å°±ç§°ä¸ºä¸å¸¦å¤´é“¾è¡¨ã€‚

#### åŸºäºpythonçš„è‡ªå»ºé“¾è¡¨ç±»ï¼ˆlist to linklist)


```python
# è‡ªå»ºåº“
# Definition for singly-linked list.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
    def initList(self, data):
        # åˆ¤æ–­æ˜¯å¦ä¸ºç©º
        if len(data) == 0:
            return
        else:
            # åˆ›å»ºå¤´ç»“ç‚¹
            self.head = ListNode(data[0])
            # å¤´ç»“ç‚¹
            r = self.head  
            # æŒ‡é’ˆ 
            p = self.head   
            # é€ä¸ªä¸º data å†…çš„æ•°æ®åˆ›å»ºç»“ç‚¹, å»ºç«‹é“¾è¡¨
            for i in data[1:]:
                node = ListNode(i)
                p.next = node
                p = p.next
            return r
        
    def linklist2List(self, linklist):
        List = []

        while linklist:
            List.append(linklist.val)
            linklist = linklist.next
        return List
```


```python
# ä½¿ç”¨
l1 = [1,2,4]
l2 = [1,3,4]

List2Linklist = ListNode()
l1 = List2Linklist.initList(l1)
l2 = List2Linklist.initList(l2)

print(l1.val, "->", l1.next.val, "->", l1.next.next.val)
print(l2.val, "->", l2.next.val, "->", l2.next.next.val)
print(List2Linklist.linklist2List(l1))
# List2Linklist.printLinklist(result)
```

#### å“¨å…µèŠ‚ç‚¹ä½¿ç”¨

æŠŠ`prev`æœŸåˆæ‰€åœ¨çš„ä½ç½®å‘½åä¸º`prehead`ï¼Œè¿™æ ·`prev`å†æ€ä¹ˆå˜éƒ½å¯ä»¥æ‰¾åˆ°å…¶èµ·å§‹åœ°å€ã€‚

```python
prehead = ListNode(-1)  # å“¨å…µèŠ‚ç‚¹ï¼Œè®©æˆ‘ä»¬å®¹æ˜“çš„è¿”å›åˆå¹¶åçš„é“¾è¡¨
prev = prehead  # prevæŒ‡é’ˆï¼Œæˆ‘ä»¬è°ƒæ•´å®ƒçš„nextæŒ‡é’ˆï¼Œç›´åˆ°l1æˆ–è€…l2æŸä¸€ä¸ªæŒ‡å‘äº†NULL

Â·Â·Â·

return prehead.next # è¿”å›å…¥å£åœ°å€

```

<img src="/img/in-post/20_07/image-20210108091928739.png" alt="image-20210108091928739" style="zoom:50%;" />

#### Pythonçš„ListNodeç±»

```python
# Definition for singly-linked list.
class ListNode:
  def __init__(self, val=0, next=None):
    self.val = val
    self.next = next
```



### ğŸš©21. åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ 

å°†ä¸¤ä¸ªæœ‰åºé“¾è¡¨åˆå¹¶ä¸ºä¸€ä¸ªæ–°çš„æœ‰åºé“¾è¡¨å¹¶è¿”å›ã€‚æ–°é“¾è¡¨æ˜¯é€šè¿‡æ‹¼æ¥ç»™å®šçš„ä¸¤ä¸ªé“¾è¡¨çš„æ‰€æœ‰èŠ‚ç‚¹ç»„æˆçš„ã€‚Â 

```
ç¤ºä¾‹ï¼š

è¾“å…¥ï¼š1->2->4, 1->3->4
è¾“å‡ºï¼š1->1->2->3->4->4

```

<img src="/img/in-post/20_07/image-20210107215233267.png" alt="image-20210107215233267" style="zoom:50%;" />









#### 2ï¸âƒ£  (1.5h)


```python
# æ ‡å‡†
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        # maintain an unchanging reference to node ahead of the return node.
        prehead = ListNode(-1)  # å“¨å…µèŠ‚ç‚¹ï¼Œè®©æˆ‘ä»¬å®¹æ˜“çš„è¿”å›åˆå¹¶åçš„é“¾è¡¨

        prev = prehead  # prevæŒ‡é’ˆï¼Œæˆ‘ä»¬è°ƒæ•´å®ƒçš„nextæŒ‡é’ˆï¼Œç›´åˆ°l1æˆ–è€…l2æŸä¸€ä¸ªæŒ‡å‘äº†NULL
        while l1 and l2:
            if l1.val <= l2.val:
                prev.next = l1
                l1 = l1.next  # æ³¨æ„l1çš„æŒ‡é’ˆä¹Ÿè¦ç§»åŠ¨
            else:
                prev.next = l2
                l2 = l2.next
            prev = prev.next  # æŒ‡å‘ä¸‹ä¸€ä¸ªå€¼
        prev.next = l1 if l1 is not None else l2
        
        return prehead.next # è¿”å›å…¥å£åœ°å€
```


```python
l1 = [1,2,4]
l2 = [1,3,4]

List2Linklist = ListNode()
l1 = List2Linklist.initList(l1)
l2 = List2Linklist.initList(l2)

solution = Solution()
result = solution.mergeTwoLists(l1,l2)

print(l1.val, "->", l1.next.val, "->", l1.next.next.val)
print(l2.val, "->", l2.next.val, "->", l2.next.next.val)
print(List2Linklist.linklist2List(result))
# List2Linklist.printLinklist(result)
```

###  âœ…(10m)206. åè½¬é“¾è¡¨

åè½¬ä¸€ä¸ªå•é“¾è¡¨ã€‚

```
ç¤ºä¾‹:

è¾“å…¥: 1->2->3->4->5->NULL
è¾“å‡º: 5->4->3->2->1->NULL
```

è¿›é˜¶:
ä½ å¯ä»¥è¿­ä»£æˆ–é€’å½’åœ°åè½¬é“¾è¡¨ã€‚ä½ èƒ½å¦ç”¨ä¸¤ç§æ–¹æ³•è§£å†³è¿™é“é¢˜ï¼Ÿ

```python
class Solution(object):
	def reverseList(self, head):
		"""
		:type head: ListNode
		:rtype: ListNode
		"""
		# ç”³è¯·ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œpreå’Œ curï¼ŒpreæŒ‡å‘None
		pre = None
		cur = head
		# éå†é“¾è¡¨ï¼Œwhileå¾ªç¯é‡Œé¢çš„å†…å®¹å…¶å®å¯ä»¥å†™æˆä¸€è¡Œ
		# è¿™é‡Œåªåšæ¼”ç¤ºï¼Œå°±ä¸æé‚£ä¹ˆéªšæ°”çš„å†™æ³•äº†
		while cur:
			# è®°å½•å½“å‰èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
			tmp = cur.next
			# ç„¶åå°†å½“å‰èŠ‚ç‚¹æŒ‡å‘pre
			cur.next = pre
			# preå’ŒcurèŠ‚ç‚¹éƒ½å‰è¿›ä¸€ä½
			pre = cur
			cur = tmp
		return pre	

```

#### 2ï¸âƒ£ (1.5h) 

#### æ³¨æ„è¦è¿”å›Newhead = pre

#### 3ï¸âƒ£é€’å½’è§£æ³•(ğŸš©)

```python
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        # digui
        if not head or not head.next: # åªæœ‰å½“å‰èŠ‚ç‚¹
            return head
        last = self.reverseList(head.next) # æ‹†è§£ä¸ºå­é—®é¢˜
        head.next.next = head
        head.next = None
        return last
```

#### 3ï¸âƒ£è¿­ä»£è§£æ³•

```python
        # è¿­ä»£
        if not head: # åªæœ‰å½“å‰èŠ‚ç‚¹
            return head  
        pre, cur = None, head
        while cur:
            tmp = cur.next  
            cur.next = pre
            pre, cur = cur, tmp
        return pre
```



### âœ… (15m) åˆ é™¤é“¾è¡¨ä¸­ç»™å®šçš„èŠ‚ç‚¹

è¯·ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œä½¿å…¶å¯ä»¥åˆ é™¤æŸä¸ªé“¾è¡¨ä¸­ç»™å®šçš„(éæœ«å°¾)èŠ‚ç‚¹ï¼Œä½ å°†åªè¢«ç»™å®šè¦æ±‚è¢«åˆ é™¤çš„èŠ‚ç‚¹ã€‚

ç°æœ‰ä¸€ä¸ªé“¾è¡¨ --Â head =Â [4,5,1,9]ï¼Œå®ƒå¯ä»¥è¡¨ç¤ºä¸º:
![image.png](/img/in-post/20_07/237_example.png)




```
ç¤ºä¾‹ 1:è¾“å…¥: head = [4,5,1,9], node = 5è¾“å‡º: [4,1,9]è§£é‡Š: ç»™å®šä½ é“¾è¡¨ä¸­å€¼ä¸ºÂ 5Â çš„ç¬¬äºŒä¸ªèŠ‚ç‚¹ï¼Œé‚£ä¹ˆåœ¨è°ƒç”¨äº†ä½ çš„å‡½æ•°ä¹‹åï¼Œè¯¥é“¾è¡¨åº”å˜ä¸º 4 -> 1 -> 9.ç¤ºä¾‹ 2:è¾“å…¥: head = [4,5,1,9], node = 1è¾“å‡º: [4,5,9]è§£é‡Š: ç»™å®šä½ é“¾è¡¨ä¸­å€¼ä¸ºÂ 1Â çš„ç¬¬ä¸‰ä¸ªèŠ‚ç‚¹ï¼Œé‚£ä¹ˆåœ¨è°ƒç”¨äº†ä½ çš„å‡½æ•°ä¹‹åï¼Œè¯¥é“¾è¡¨åº”å˜ä¸º 4 -> 5 -> 9.
```


```python
class Solution:    def deleteNode(self, node):        """        :type node: ListNode        :rtype: void Do not return anything, modify node in-place instead.        """        node.val = node.next.val        node.next = node.next.next
```

### âœ…(50m) 203. ç§»é™¤é“¾è¡¨å…ƒç´ 

åˆ é™¤é“¾è¡¨ä¸­ç­‰äºç»™å®šå€¼ val çš„æ‰€æœ‰èŠ‚ç‚¹ã€‚

```
ç¤ºä¾‹:è¾“å…¥: 1->2->6->3->4->5->6, val = 6è¾“å‡º: 1->2->3->4->5
```

å“¨å…µèŠ‚ç‚¹å¹¿æ³›åº”ç”¨äºæ ‘å’Œé“¾è¡¨ä¸­ï¼Œå¦‚ä¼ªå¤´ã€ä¼ªå°¾ã€æ ‡è®°ç­‰ï¼Œå®ƒä»¬æ˜¯çº¯åŠŸèƒ½çš„ï¼Œé€šå¸¸ä¸ä¿å­˜ä»»ä½•æ•°æ®ï¼Œå…¶ä¸»è¦ç›®çš„æ˜¯ä½¿é“¾è¡¨æ ‡å‡†åŒ–ï¼Œå¦‚ä½¿é“¾è¡¨æ°¸ä¸ä¸ºç©ºã€æ°¸ä¸æ— å¤´ã€ç®€åŒ–æ’å…¥å’Œåˆ é™¤ã€‚

![image.png](/img/in-post/20_07/c650a78cb34caf9a00469651abfc14181c474e2c6152e87273092e7dfd331f19-file_1578026286317.png)

åœ¨è¿™é‡Œå“¨å…µèŠ‚ç‚¹å°†è¢«ç”¨äºä¼ªå¤´ã€‚


```python
# Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def removeElements(self, head: ListNode, val: int) -> ListNode:                if not head: return None        while head and head.val == val:            if head.next: head = head.next            else:                 head.next = None                return None        prehead = head        while head.next:            if head.next.val == val and head.next.next:                head.next = head.next.next            elif  head.next.val == val and not head.next.next:                head.next = None            else:                head = head.next        return prehead        
```


```python
# å®˜æ–¹class Solution:    def removeElements(self, head: ListNode, val: int) -> ListNode:        sentinel = ListNode(0) # å“¨å…µèŠ‚ç‚¹        sentinel.next = head                prev,curr = sentinel,head        while curr:            if curr.val == val:  #  åŒæŒ‡é’ˆï¼Œå¦‚æœcurråˆ é™¤ï¼ŒprevåŒæ—¶ç§»åŠ¨                prev.next == curr.next            else:                prev = curr            curr = curr.next                    return sentinel.next
```

### âœ…(90m)234. å›æ–‡é“¾è¡¨

è¯·åˆ¤æ–­ä¸€ä¸ªé“¾è¡¨æ˜¯å¦ä¸ºå›æ–‡é“¾è¡¨ã€‚

```
ç¤ºä¾‹ 1:è¾“å…¥: 1->2è¾“å‡º: falseç¤ºä¾‹ 2:è¾“å…¥: 1->2->2->1è¾“å‡º: trueè¿›é˜¶ï¼šä½ èƒ½å¦ç”¨ O(n) æ—¶é—´å¤æ‚åº¦å’Œ O(1) ç©ºé—´å¤æ‚åº¦è§£å†³æ­¤é¢˜ï¼Ÿ
```


```python
# Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def isPalindrome(self, head: ListNode) -> bool:                    
```


```python
# å®˜è§£ï¼Œæ•°ç»„def isPalindrome(self, head: ListNode) -> bool:    vals = []    current_node = head    while current_node is not None:        vals.append(current_node.val)        current_node = current_node.next    return vals == vals[::-1]
```


```python
# å®˜è§£ï¼Œåè½¬ååŠéƒ¨åˆ†é“¾è¡¨# æ–¹æ³•ä¸‰ï¼š# é¿å…ä½¿ç”¨ O(n)O(n) é¢å¤–ç©ºé—´çš„æ–¹æ³•å°±æ˜¯æ”¹å˜è¾“å…¥ã€‚# æˆ‘ä»¬å¯ä»¥å°†é“¾è¡¨çš„ååŠéƒ¨åˆ†åè½¬(ä¿®æ”¹é“¾è¡¨ç»“æ„)ï¼Œç„¶åå°†å‰åŠéƒ¨åˆ†å’ŒååŠéƒ¨åˆ†è¿›è¡Œæ¯”è¾ƒã€‚æ¯”è¾ƒå®Œæˆåæˆ‘ä»¬åº”è¯¥å°†é“¾è¡¨æ¢å¤åŸæ ·ã€‚è™½ç„¶ä¸éœ€è¦æ¢å¤ä¹Ÿèƒ½é€šè¿‡æµ‹è¯•ç”¨ä¾‹ï¼Œå› ä¸ºä½¿ç”¨è¯¥å‡½æ•°çš„äººä¸å¸Œæœ›é“¾è¡¨ç»“æ„è¢«æ›´æ”¹ã€‚# ç®—æ³•ï¼š# æˆ‘ä»¬å¯ä»¥åˆ†ä¸ºä»¥ä¸‹å‡ ä¸ªæ­¥éª¤ï¼š# æ‰¾åˆ°å‰åŠéƒ¨åˆ†é“¾è¡¨çš„å°¾èŠ‚ç‚¹ã€‚# åè½¬ååŠéƒ¨åˆ†é“¾è¡¨ã€‚# åˆ¤æ–­æ˜¯å¦ä¸ºå›æ–‡ã€‚# æ¢å¤é“¾è¡¨ã€‚# è¿”å›ç»“æœã€‚
```

#### 2ï¸âƒ£

On,Onç‰ˆæœ¬

```python
class Solution:    def isPalindrome(self, head: ListNode) -> bool:        prehead = head        ln = []        while head:            ln.append(head.val)            head = head.next        if len(ln) <= 1: return True        if ln[:len(ln)//2] == ln[-(len(ln)//2):][::-1]: # æ³¨æ„ï¼è´Ÿå·ä¼˜å…ˆçº§å¤§äº//            return True        else:            return False
```

#### 3ï¸âƒ£

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        if not head or not head.next: 
            return True

        # 1. Find middle node by fast and slow pointer
        slow = fast = head
        while fast and fast.next:
            p = slow
            q = fast.next
            slow = slow.next
            fast = fast.next.next
        # print(slow)

        # 2. odd case
        if fast:
            p = slow
            slow = slow.next
            q = fast
        
        # 3. reverse()
        def reverse(head):
            pre,cur = None,head
            while cur:
                tmp = cur.next
                cur.next = pre
                pre,cur = cur,tmp
            return pre

        # 4 & 5. compare ListNode and restore ListNode
        left = head
        right = reverse(slow) # middle node
        # print(p,q)
        while right != None:
            # print(left.val , right.val)
            if left.val != right.val:
                p.next = reverse(q)
                return False
            left = left.next
            right = right.next
        p.next = reverse(q)
        # print(head)
        return Trueclass Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        if not head or not head.next: 
            return True

        # 1. Find middle node by fast and slow pointer
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        # print(slow)

        # 2. odd case
        if fast:
            slow = slow.next
        
        # 3. reverse()
        def reverse(head):
            pre,cur = None,head
            while cur:
                tmp = cur.next
                cur.next = pre
                pre,cur = cur,tmp
            return pre

        # 4. compare ListNode
        left = head
        right = reverse(slow) # middle node

        while right != None:
            # print(left.val , right.val)
            if left.val != right.val:
                return False
            left = left.next
            right = right.next
        return True
```



æ³¨æ„ï¼š

1.è¿ç®—ç¬¦ä¼˜å…ˆçº§ï¼Œæ³¨æ„ç¬¦å·ä¼˜å…ˆçº§å¾ˆé«˜ï¼Œå¤§äºé™¤å·ï¼ï¼

<img src="/img/in-post/20_07/image-20210131214828448.png" alt="image-20210131214828448" style="zoom:50%;" />

2. æ³¨æ„ç”¨å¿«æ…¢æŒ‡é’ˆæ¥æ‰¾ä¸­ç‚¹

3. æ³¨æ„å¦‚æœæ˜¯å¥‡æ•°çš„è¯åˆ¤æ–­fastéNoneåˆ™è¦å†åŠ 1ä½
4. è®°å½•ä¸‹pï¼Œqå’Œ  ` p.next = reverse(q)` å¯æ¢å¤åŸé“¾è¡¨





### âœ…(50m) 2. ä¸¤æ•°ç›¸åŠ 

ç»™å‡ºä¸¤ä¸ª éç©º çš„é“¾è¡¨ç”¨æ¥è¡¨ç¤ºä¸¤ä¸ªéè´Ÿçš„æ•´æ•°ã€‚å…¶ä¸­ï¼Œå®ƒä»¬å„è‡ªçš„ä½æ•°æ˜¯æŒ‰ç…§ é€†åº çš„æ–¹å¼å­˜å‚¨çš„ï¼Œå¹¶ä¸”å®ƒä»¬çš„æ¯ä¸ªèŠ‚ç‚¹åªèƒ½å­˜å‚¨ ä¸€ä½ æ•°å­—ã€‚

å¦‚æœï¼Œæˆ‘ä»¬å°†è¿™ä¸¤ä¸ªæ•°ç›¸åŠ èµ·æ¥ï¼Œåˆ™ä¼šè¿”å›ä¸€ä¸ªæ–°çš„é“¾è¡¨æ¥è¡¨ç¤ºå®ƒä»¬çš„å’Œã€‚

æ‚¨å¯ä»¥å‡è®¾é™¤äº†æ•°å­— 0 ä¹‹å¤–ï¼Œè¿™ä¸¤ä¸ªæ•°éƒ½ä¸ä¼šä»¥ 0 å¼€å¤´ã€‚

```
ç¤ºä¾‹ï¼šè¾“å…¥ï¼š(2 -> 4 -> 3) + (5 -> 6 -> 4)è¾“å‡ºï¼š7 -> 0 -> 8åŸå› ï¼š342 + 465 = 807
```


```python
# Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:        prehead = ListNode(-1)        newlinklist = prehead        carry = 0        while l1 and l2:            newlinklist.next = ListNode((l1.val+l2.val + carry)%10)  # æ–°å»ºlinklistçš„æ–¹æ³•ï¼Œæ³¨æ„ä¸èƒ½linklist.val ==             newlinklist = newlinklist.next            carry = (l1.val+l2.val + carry)//10            l1, l2 = l1.next, l2.next        while l1 and l2 is None:            newlinklist.next = ListNode((l1.val + carry)%10)            newlinklist = newlinklist.next            carry = (l1.val + carry)            l1 = l1.next        while l2 and l1 is None:            newlinklist.next = ListNode((l2.val + carry)%10)            newlinklist = newlinklist.next            carry = (l2.val + carry)            l2 = l2.next        if carry == 1: newlinklist.next = ListNode(carry)         return prehead.next                
```




```python

```


```python

```


```python

```


```python

```

### âœ… 206. åè½¬é“¾è¡¨

åè½¬ä¸€ä¸ªå•é“¾è¡¨ã€‚

```
ç¤ºä¾‹:è¾“å…¥: 1->2->3->4->5->NULLè¾“å‡º: 5->4->3->2->1->NULL
```

è¿›é˜¶:
ä½ å¯ä»¥è¿­ä»£æˆ–é€’å½’åœ°åè½¬é“¾è¡¨ã€‚ä½ èƒ½å¦ç”¨ä¸¤ç§æ–¹æ³•è§£å†³è¿™é“é¢˜ï¼Ÿ



```python
class Solution(object):	def reverseList(self, head):		"""		:type head: ListNode		:rtype: ListNode		"""		# ç”³è¯·ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œpreå’Œ curï¼ŒpreæŒ‡å‘None		pre = None		cur = head		# éå†é“¾è¡¨ï¼Œwhileå¾ªç¯é‡Œé¢çš„å†…å®¹å…¶å®å¯ä»¥å†™æˆä¸€è¡Œ		# è¿™é‡Œåªåšæ¼”ç¤ºï¼Œå°±ä¸æé‚£ä¹ˆéªšæ°”çš„å†™æ³•äº†		while cur:			# è®°å½•å½“å‰èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹			tmp = cur.next			# ç„¶åå°†å½“å‰èŠ‚ç‚¹æŒ‡å‘pre			cur.next = pre			# preå’ŒcurèŠ‚ç‚¹éƒ½å‰è¿›ä¸€ä½			pre = cur			cur = tmp		return pre	
```

#### 2ï¸âƒ£ (30m)


```python
class Solution(object):    def reverseList(self, head):        cur = head  # æ³¨æ„æ˜¯ä»headå¼€å§‹        pre = None        while cur:            nexttmp = cur.next            cur.next = pre                        pre = cur             cur = nexttmp        return pre  # è¿”å›çš„æ˜¯èµ·å§‹ç‚¹
```

### ğŸš©25. K ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨

ç»™ä½ ä¸€ä¸ªé“¾è¡¨ï¼Œæ¯ k ä¸ªèŠ‚ç‚¹ä¸€ç»„è¿›è¡Œç¿»è½¬ï¼Œè¯·ä½ è¿”å›ç¿»è½¬åçš„é“¾è¡¨ã€‚

k æ˜¯ä¸€ä¸ªæ­£æ•´æ•°ï¼Œå®ƒçš„å€¼å°äºæˆ–ç­‰äºé“¾è¡¨çš„é•¿åº¦ã€‚

å¦‚æœèŠ‚ç‚¹æ€»æ•°ä¸æ˜¯ k çš„æ•´æ•°å€ï¼Œé‚£ä¹ˆè¯·å°†æœ€åå‰©ä½™çš„èŠ‚ç‚¹ä¿æŒåŸæœ‰é¡ºåºã€‚


```
ç¤ºä¾‹ï¼šç»™ä½ è¿™ä¸ªé“¾è¡¨ï¼š1->2->3->4->5å½“ k = 2 æ—¶ï¼Œåº”å½“è¿”å›: 2->1->4->3->5å½“ k = 3 æ—¶ï¼Œåº”å½“è¿”å›: 3->2->1->4->5
```

è¯´æ˜ï¼š

ä½ çš„ç®—æ³•åªèƒ½ä½¿ç”¨å¸¸æ•°çš„é¢å¤–ç©ºé—´ã€‚
ä½ ä¸èƒ½åªæ˜¯å•çº¯çš„æ”¹å˜èŠ‚ç‚¹å†…éƒ¨çš„å€¼ï¼Œè€Œæ˜¯éœ€è¦å®é™…è¿›è¡ŒèŠ‚ç‚¹äº¤æ¢ã€‚


```python
class Solution:
    def reverseList(self, head):

        while cur:
            nexttmp = cur.next
            cur.next = pre
            
            pre = cur 
            cur = nexttmp
        return pre  # è¿”å›çš„æ˜¯èµ·å§‹ç‚¹    
    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:
        cur = head  # æ³¨æ„æ˜¯ä»headå¼€å§‹
        pre = None
        reverseList()
```

#### 2ï¸âƒ£



### ğŸš©23. åˆå¹¶Kä¸ªæ’åºé“¾è¡¨

åˆå¹¶ k ä¸ªæ’åºé“¾è¡¨ï¼Œè¿”å›åˆå¹¶åçš„æ’åºé“¾è¡¨ã€‚è¯·åˆ†æå’Œæè¿°ç®—æ³•çš„å¤æ‚åº¦ã€‚

ç¤ºä¾‹:

```
è¾“å…¥:
[
  1->4->5,
  1->3->4,
  2->6
]
è¾“å‡º: 1->1->2->3->4->4->5->6
```

#### 2ï¸âƒ£

### âœ…(20m)[141. ç¯å½¢é“¾è¡¨](https://leetcode-cn.com/problems/linked-list-cycle/)

éš¾åº¦ç®€å•916

ç»™å®šä¸€ä¸ªé“¾è¡¨ï¼Œåˆ¤æ–­é“¾è¡¨ä¸­æ˜¯å¦æœ‰ç¯ã€‚

å¦‚æœé“¾è¡¨ä¸­æœ‰æŸä¸ªèŠ‚ç‚¹ï¼Œå¯ä»¥é€šè¿‡è¿ç»­è·Ÿè¸ª `next` æŒ‡é’ˆå†æ¬¡åˆ°è¾¾ï¼Œåˆ™é“¾è¡¨ä¸­å­˜åœ¨ç¯ã€‚ ä¸ºäº†è¡¨ç¤ºç»™å®šé“¾è¡¨ä¸­çš„ç¯ï¼Œæˆ‘ä»¬ä½¿ç”¨æ•´æ•° `pos` æ¥è¡¨ç¤ºé“¾è¡¨å°¾è¿æ¥åˆ°é“¾è¡¨ä¸­çš„ä½ç½®ï¼ˆç´¢å¼•ä» 0 å¼€å§‹ï¼‰ã€‚ å¦‚æœ `pos` æ˜¯ `-1`ï¼Œåˆ™åœ¨è¯¥é“¾è¡¨ä¸­æ²¡æœ‰ç¯ã€‚**æ³¨æ„ï¼š`pos` ä¸ä½œä¸ºå‚æ•°è¿›è¡Œä¼ é€’**ï¼Œä»…ä»…æ˜¯ä¸ºäº†æ ‡è¯†é“¾è¡¨çš„å®é™…æƒ…å†µã€‚

å¦‚æœé“¾è¡¨ä¸­å­˜åœ¨ç¯ï¼Œåˆ™è¿”å› `true` ã€‚ å¦åˆ™ï¼Œè¿”å› `false` ã€‚

 

**è¿›é˜¶ï¼š**

ä½ èƒ½ç”¨ *O(1)*ï¼ˆå³ï¼Œå¸¸é‡ï¼‰å†…å­˜è§£å†³æ­¤é—®é¢˜å—ï¼Ÿ

 

**ç¤ºä¾‹ 1ï¼š**

![img](/img/in-post/20_07/circularlinkedlist.png)

```
è¾“å…¥ï¼šhead = [3,2,0,-4], pos = 1
è¾“å‡ºï¼štrue
è§£é‡Šï¼šé“¾è¡¨ä¸­æœ‰ä¸€ä¸ªç¯ï¼Œå…¶å°¾éƒ¨è¿æ¥åˆ°ç¬¬äºŒä¸ªèŠ‚ç‚¹ã€‚
```

```python
æ³•1ï¼šæ”¾åˆ°seté‡Œclass Solution:    def hasCycle(self, head: ListNode) -> bool:        # if not head: return False        # set_node = set()        # while head:        #     if head in set_node:        #         return True        #     set_node.add(head)        #     head = head.next        # return False
```



```python
æ³•äºŒï¼šå¿«æ…¢æŒ‡é’ˆclass Solution:    def hasCycle(self, head: ListNode) -> bool:        if not head: return False        slow = fast = head        while fast and fast.next:            slow = slow.next            fast = fast.next.next            if fast == slow:                return True        return False
```

æ³¨æ„ï¼š

1. æ³¨æ„é“¾è¡¨æ˜¯å¯ä»¥æ”¾åˆ°seté‡Œçš„ï¼Œåˆ¤æ–­é“¾è¡¨ç›¸ç­‰è¦æ»¡è¶³valueå’Œnextéƒ½ç›¸ç­‰
2. setæ˜¯ç”¨addå’Œremoveçš„ï¼ŒO(1)æ—¶é—´å¤æ‚åº¦

### ğŸš©(20m) [142. ç¯å½¢é“¾è¡¨ II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

```python
class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        if not head: return None
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if fast == slow:
                fast = head
                while fast:
                    if fast == slow:  # æ³¨æ„è€ƒè™‘ç‰¹æ®Šæƒ…å†µç¬¬ä¸€ä¸ªç¯ç‚¹ä¸º0æ—¶è¦å…ˆåˆ¤æ–­ä¸¤ä¸ªæŒ‡é’ˆæ˜¯å¦ç›¸åŒ
                        return fast
                    slow = slow.next
                    fast = fast.next

```



### âœ…(10m)[86. åˆ†éš”é“¾è¡¨](https://leetcode-cn.com/problems/partition-list/)

éš¾åº¦ä¸­ç­‰357

ç»™ä½ ä¸€ä¸ªé“¾è¡¨å’Œä¸€ä¸ªç‰¹å®šå€¼ `x` ï¼Œè¯·ä½ å¯¹é“¾è¡¨è¿›è¡Œåˆ†éš”ï¼Œä½¿å¾—æ‰€æœ‰å°äº `x` çš„èŠ‚ç‚¹éƒ½å‡ºç°åœ¨å¤§äºæˆ–ç­‰äº `x` çš„èŠ‚ç‚¹ä¹‹å‰ã€‚

ä½ åº”å½“ä¿ç•™ä¸¤ä¸ªåˆ†åŒºä¸­æ¯ä¸ªèŠ‚ç‚¹çš„åˆå§‹ç›¸å¯¹ä½ç½®ã€‚

 

**ç¤ºä¾‹ï¼š**

```
è¾“å…¥ï¼šhead = 1->4->3->2->5->2, x = 3
è¾“å‡ºï¼š1->2->2->4->3->5
```

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def partition(self, head: ListNode, x: int) -> ListNode:
        node1 = ListNode(-1)
        node2 = ListNode(-1)
        prenode1 = node1
        prenode2 = node2
        while head:
            if head.val < x:
                node1.next = head
                node1 = node1.next
            else:
                node2.next = head
                node2 = node2.next
            head = head.next
        node1.next, node2.next = prenode2.next, None
        
        return prenode1.next


```

æ€»ç»“

1. éå†ç»“æŸåï¼Œæˆ‘ä»¬å°†large çš„ next æŒ‡é’ˆç½®ç©ºï¼Œè¿™æ˜¯å› ä¸ºå½“å‰èŠ‚ç‚¹å¤ç”¨çš„æ˜¯åŸé“¾è¡¨çš„èŠ‚ç‚¹ï¼Œè€Œå…¶ next æŒ‡é’ˆå¯èƒ½æŒ‡å‘ä¸€ä¸ªå°äº x çš„èŠ‚ç‚¹ï¼Œæˆ‘ä»¬éœ€è¦åˆ‡æ–­è¿™ä¸ªå¼•ç”¨ã€‚

### [160. ç›¸äº¤é“¾è¡¨](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

éš¾åº¦ç®€å•957

ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œæ‰¾åˆ°ä¸¤ä¸ªå•é“¾è¡¨ç›¸äº¤çš„èµ·å§‹èŠ‚ç‚¹ã€‚

å¦‚ä¸‹é¢çš„ä¸¤ä¸ªé“¾è¡¨**ï¼š**

[![img](/img/in-post/20_07/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

åœ¨èŠ‚ç‚¹ c1 å¼€å§‹ç›¸äº¤ã€‚

 

**ç¤ºä¾‹ 1ï¼š**

[![img](/img/in-post/20_07/160_example_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)

```
è¾“å…¥ï¼šintersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
è¾“å‡ºï¼šReference of the node with value = 8
è¾“å…¥è§£é‡Šï¼šç›¸äº¤èŠ‚ç‚¹çš„å€¼ä¸º 8 ï¼ˆæ³¨æ„ï¼Œå¦‚æœä¸¤ä¸ªé“¾è¡¨ç›¸äº¤åˆ™ä¸èƒ½ä¸º 0ï¼‰ã€‚ä»å„è‡ªçš„è¡¨å¤´å¼€å§‹ç®—èµ·ï¼Œé“¾è¡¨ A ä¸º [4,1,8,4,5]ï¼Œé“¾è¡¨ B ä¸º [5,0,1,8,4,5]ã€‚åœ¨ A ä¸­ï¼Œç›¸äº¤èŠ‚ç‚¹å‰æœ‰ 2 ä¸ªèŠ‚ç‚¹ï¼›åœ¨ B ä¸­ï¼Œç›¸äº¤èŠ‚ç‚¹å‰æœ‰ 3 ä¸ªèŠ‚ç‚¹ã€‚
```

OnOnç‰ˆæœ¬

```python
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        set_n = set()
        while headA:
            set_n.add(headA)
            headA = headA.next
        while headB:
            if headB in set_n:
                return headB
            headB = headB.next
        return None
```

æˆ‘çš„OnO1

```python
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        preheadA = headA
        preheadB = headB
        
        STATE_A = STATE_B = True
        while headA and headB:
            print(headA.val,headB.val,'  ')
            if headA == headB:
                return headA

            headA = headA.next
            headB = headB.next
        
            if headA == None and STATE_A:  # è¦å…ˆåˆ¤æ–­ä¸‹
                headA = preheadB
                STATE_A = False
            if headB == None and STATE_B:
                headB = preheadA 
                STATE_B = False
                
        return None
```

å¤§ä½¬OnO1ç‰ˆæœ¬

```python
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:

        curr1, curr2 = headA, headB
        while curr1 != curr2:
            curr1 = curr1.next if curr1 else headB
            curr2 = curr2.next if curr2 else headA

        return curr1
```



### ğŸš©(60m)[92. åè½¬é“¾è¡¨ II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

éš¾åº¦ä¸­ç­‰674

åè½¬ä»ä½ç½® *m* åˆ° *n* çš„é“¾è¡¨ã€‚è¯·ä½¿ç”¨ä¸€è¶Ÿæ‰«æå®Œæˆåè½¬ã€‚

**è¯´æ˜:**
1 â‰¤ *m* â‰¤ *n* â‰¤ é“¾è¡¨é•¿åº¦ã€‚

**ç¤ºä¾‹:**

```
è¾“å…¥: 1->2->3->4->5->NULL, m = 2, n = 4
è¾“å‡º: 1->4->3->2->5->NULL
```





```python
    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:
        # å®˜è§£
        if not head: # åªæœ‰å½“å‰èŠ‚ç‚¹
            return None  
        # dummy = head
        # pos = 1
        
        # i = dummy
        cur, prev = head, None
        # while pos < m:
    
        while m > 1:   # ä¸€ç›´å¾ªç¯åˆ°m==1çš„æƒ…å†µ
            prev = cur
            cur = cur.next
            m, n = m-1, n-1   # æ³¨æ„ï¼Œè¿™æ ·å°±ä¸éœ€è¦è®°å½•å½“å‰ä½ç½®
        #     pos += 1
        # j = dummy

        tail, con = cur, prev  

        while n:
            thrid = cur.next  
            cur.next = prev
            prev, cur = cur, thrid
            n -= 1
            # pos += 1
        
        if con:  # å¦‚æœiä»1å¼€å§‹ï¼Œåˆ™con==Noneï¼Œæ— nextï¼Œåˆ™ç›´æ¥ä»¤head = prev
            con.next = prev
        else:
            head = prev
        tail.next = cur

        return head
```

#### 3ï¸âƒ£ (40m) æ³¨æ„åœæ­¢æ¡ä»¶æ˜¯        while head:

æ³¨æ„ï¼š

1. m, n = m-1, n-1   # æ³¨æ„ï¼Œè¿™æ ·å°±ä¸éœ€è¦è®°å½•å½“å‰ä½ç½®
2. æœ€åè¦åˆ†æƒ…å†µï¼Œæ˜¯å¦ç›´æ¥ä»ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å°±å¼€å§‹åè½¬

### ğŸš© (1.5h) 146. LRUç¼“å­˜æœºåˆ¶

è¿ç”¨ä½ æ‰€æŒæ¡çš„æ•°æ®ç»“æ„ï¼Œè®¾è®¡å’Œå®ç°ä¸€ä¸ª  LRU (æœ€è¿‘æœ€å°‘ä½¿ç”¨) ç¼“å­˜æœºåˆ¶ã€‚å®ƒåº”è¯¥æ”¯æŒä»¥ä¸‹æ“ä½œï¼š è·å–æ•°æ® get å’Œ å†™å…¥æ•°æ® put ã€‚

è·å–æ•°æ® get(key) - å¦‚æœå…³é”®å­— (key) å­˜åœ¨äºç¼“å­˜ä¸­ï¼Œåˆ™è·å–å…³é”®å­—çš„å€¼(æ€»æ˜¯æ­£æ•°)ï¼Œå¦åˆ™è¿”å› -1ã€‚
å†™å…¥æ•°æ® put(key, value) - å¦‚æœå…³é”®å­—å·²ç»å­˜åœ¨ï¼Œåˆ™å˜æ›´å…¶æ•°æ®å€¼ï¼›å¦‚æœå…³é”®å­—ä¸å­˜åœ¨ï¼Œåˆ™æ’å…¥è¯¥ç»„ã€Œå…³é”®å­—/å€¼ã€ã€‚å½“ç¼“å­˜å®¹é‡è¾¾åˆ°ä¸Šé™æ—¶ï¼Œå®ƒåº”è¯¥åœ¨å†™å…¥æ–°æ•°æ®ä¹‹å‰åˆ é™¤æœ€ä¹…æœªä½¿ç”¨çš„æ•°æ®å€¼ï¼Œä»è€Œä¸ºæ–°çš„æ•°æ®å€¼ç•™å‡ºç©ºé—´ã€‚

 

è¿›é˜¶:

ä½ æ˜¯å¦å¯ä»¥åœ¨ O(1) æ—¶é—´å¤æ‚åº¦å†…å®Œæˆè¿™ä¸¤ç§æ“ä½œï¼Ÿ


```
ç¤ºä¾‹:

LRUCache cache = new LRUCache( 2 /* ç¼“å­˜å®¹é‡ */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // è¿”å›  1
cache.put(3, 3);    // è¯¥æ“ä½œä¼šä½¿å¾—å…³é”®å­— 2 ä½œåºŸ
cache.get(2);       // è¿”å› -1 (æœªæ‰¾åˆ°)
cache.put(4, 4);    // è¯¥æ“ä½œä¼šä½¿å¾—å…³é”®å­— 1 ä½œåºŸ
cache.get(1);       // è¿”å› -1 (æœªæ‰¾åˆ°)
cache.get(3);       // è¿”å›  3
cache.get(4);       // è¿”å›  4
```

#### 2ï¸âƒ£

LRU åŒå‘é“¾è¡¨+å“ˆå¸Œ åŒé“¾è¡¨æ•°æ®ç»“æ„ï¼š


```python
class DLinkedNode:
    def __init__(self, key=0, value=0):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None


class LRUCache:

    def __init__(self, capacity: int):
        self.cache = dict()
        # ä½¿ç”¨ä¼ªå¤´éƒ¨å’Œä¼ªå°¾éƒ¨èŠ‚ç‚¹    
        self.head = DLinkedNode()
        self.tail = DLinkedNode()
        self.head.next = self.tail
        self.tail.prev = self.head
        self.capacity = capacity
        self.size = 0

```

