# leetcodeé¢˜ç›®æŒ‰ç±»å‹

## äºŒå‰æ ‘

### âœ… äºŒå‰æ ‘éå†æ¡†æ¶

äºŒå‰æ ‘ç®—æ³•çš„è®¾è®¡çš„æ€»è·¯çº¿:**æ˜ç¡®ä¸€ä¸ªèŠ‚ç‚¹è¦åšçš„äº‹æƒ…,ç„¶åå‰©ä¸‹çš„äº‹æŠ›ç»™æ¡†æ¶ã€‚**

```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
        
def traverse(root) :
    if not root: return None
	  # nodeéœ€è¦åšä»€ä¹ˆåœ¨è¿™é‡Œåš, å…¶ä»–çš„äº¤ç»™æ¡†æ¶
    # your task
    # å‰åºéå†
    traverse(root.left)
    # ä¸­åºéå†
    traverse(root.right)
    # ååºéå†
```



```C++
/* åŸºæœ¬çš„äºŒå‰æ ‘èŠ‚ç‚¹ */ 
class TreeNode {     
  int val;     
  TreeNode left, right; 
} 

void traverse(TreeNode root) {     
    // å‰åºéå†    
    traverse(root.left)     
    // ä¸­åºéå†    
    traverse(root.right)     
    // ååºéå†
}
```

> 1. å¦‚æœdfs
>
>    ```python
>    def binaryTreePaths(self, root: TreeNode) -> List[str]:
>      if not root: return []
>      ans = []
>      path = ''
>    
>      def dfs(root, path):
>        if root: 
>          # do sth
>          path+=str(root.val)
>          # æ»¡è¶³æ¡ä»¶
>          if not(root.left or root.right): 
>            ans.append(path)
>          # ä¸æ»¡è¶³ç»§ç»­å¾ªç¯
>          else:
>            path += '->'
>            dfs(root.left, path)
>            dfs(root.right, path)
>    
>        dfs(root,path)
>        return ans
>    
>    ```

### BSTéå†æ¡†æ¶

äºŒå‰æœç´¢æ ‘(Binary Search Tree,ç®€ç§° BST), æ˜¯ä¸€ç§å¾ˆå¸¸ç”¨çš„çš„äºŒå‰æ ‘ã€‚å®ƒçš„å®šä¹‰æ˜¯:ä¸€ä¸ªäºŒå‰æ ‘ä¸­,ä»»æ„èŠ‚ç‚¹çš„å€¼è¦**å¤§äºç­‰äº**å·¦å­æ ‘æ‰€æœ‰èŠ‚ç‚¹çš„å€¼, ä¸”è¦**å°äºç­‰äº**å³è¾¹å­æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹çš„å€¼ã€‚

<img src="/img/in-post/20_07/image-20210116112419058.png" alt="image-20210116112419058" style="zoom: 33%;" />

```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
        

def BST(root:TreeNode, target:int):
  if root.val == target:
    # do something
  if root.val > target:
    BST(root.left, target)
  if root.val < target:
    BST(root.right, target)
```

```C++
/* åŸºæœ¬çš„äºŒå‰æ ‘èŠ‚ç‚¹ */ 
class TreeNode {     
  int val;     
  TreeNode left, right; 
} 

void BST(TreeNode root, int target) {     
  if (root.val == target)         
    // æ‰¾åˆ°ç›®æ ‡,åšç‚¹ä»€ä¹ˆ    
  if (root.val < target)         
    BST(root.right, target);     
  if (root.val > target)         
    BST(root.left, target); 
} 
```

> 1. æŸ¥
> 2. æ”¹ â€” è¿”å›TreeNodeç±»å‹ï¼ˆå¦‚rootï¼‰ã€‚

### N å‰æ ‘çš„éå†æ¡†æ¶

äºŒå‰æ ‘æ¡†æ¶å¯ä»¥æ‰©å±•ä¸º **N å‰æ ‘**çš„éå†æ¡†æ¶:

```python
class TreeNode:
  def __init__(self, val, children):
    self.val = val
    self.children = chrildren
    
def traverse(root:TreeNode):
  for child in root.children:
    traverse(child)
```



```C++
/* åŸºæœ¬çš„ N å‰æ ‘èŠ‚ç‚¹ */ 
class TreeNode {     
  int val;     
  TreeNode[] children; 
} 

void traverse(TreeNode root) {     
  for (TreeNode child : root.children)         
    traverse(child) 
}
```

### å›¾éå†æ¡†æ¶ï¼ˆğŸš©å¾…ç ”ç©¶ï¼‰

N å‰æ ‘çš„éå†åˆå¯ä»¥æ‰©å±•ä¸ºå›¾çš„éå†,å› ä¸ºå›¾å°±æ˜¯å¥½å‡  N å‰æ£µæ ‘çš„ç»“åˆä½“ã€‚ä½ è¯´å›¾æ˜¯å¯èƒ½å‡ºç°ç¯çš„?è¿™ä¸ªå¾ˆå¥½åŠ,ç”¨ä¸ªå¸ƒå°”æ•°ç»„ visited åšæ ‡è®°å°±è¡Œäº†ã€‚

### æ€»ç»“

#### åšé¢˜æ€è·¯

æˆ‘ä»¬åœ¨åšäºŒå‰æ ‘é¢˜ç›®æ—¶å€™ï¼Œç¬¬ä¸€æƒ³åˆ°çš„åº”è¯¥æ˜¯ç”¨**é€’å½’**æ¥è§£å†³ã€‚

é€’å½’è¿”å›å€¼ï¼š

        return root  #  æ³¨æ„è¿”å›çš„æ˜¯rootï¼Œæ­¤æ—¶rootä¸ºç©º

ä¸€å®šæ³¨æ„ root æ˜¯æ ‘ï¼Œ root.val æ˜¯å€¼

        valuePerDepth[index].append(root.val)   # ä¸€å®šæ³¨æ„ root æ˜¯æ ‘ï¼Œ root.val æ˜¯å€¼

æ³¨æ„ç”¨æ•°ç»„å½¢å¼å¯ä»¥æŠŠrootæ ‘åŠ å…¥é˜Ÿåˆ—        

        queue = [root]  # æ³¨æ„ç”¨æ•°ç»„å½¢å¼å¯ä»¥æŠŠrootæ ‘åŠ å…¥é˜Ÿåˆ—

**æ³¨æ„é€’å½’æ—¶, return é‡Œçš„false å’Œtrueçš„å…³ç³», çœ‹æ˜¯and è¿˜æ˜¯or**

#### é€’å½’æ³•å¸¦helperå‡½æ•°æ±‚è§£æ ‡å‡†æ­¥éª¤


```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        def helper(left,right):   # æ³¨æ„æ²¡æœ‰self
            # åŸºå‡†æƒ…å†µï¼ŒäºŒå‰æ ‘ä¸ºç©º
            if left > right:  # å·¦å³ä½ç½®åšæ ‡
                return None
            
            # é€‰ä¸­é—´åå·¦çš„ç»“ç‚¹ä¸ºroot
            mid = (left+right)//2
            
            root = TreeNode(nums[mid])  # root = TreeNode(0) # ç”¨0ä½œä¸ºæ ¹èŠ‚ç‚¹
            root.left = helper(left, mid - 1)
            root.right = helper(mid + 1, right)
            
            return root 
        
        return helper(0, len(nums) - 1)
    
```


```python
from typing import List

nums = [1,2,0,2,2]
solution = Solution()
result = solution.sortedArrayToBST(nums)
result
```

#### é€’å½’æ³•ä¸å¸¦helperå‡½æ•°æ ‡å‡†æ­¥éª¤


```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
# é€’å½’
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:  # root is empty then return, å³ä½¿å­æ ‘ä¸ºç©ºä¹Ÿæ²¡å…³ç³»åº”è¯¥
            return None

        root.left, root.right = root.right, root.left
        
        self.invertTree(root.left)
        self.invertTree(root.right)

        return root  #  æ³¨æ„è¿”å›çš„æ˜¯rootï¼Œæ­¤æ—¶rootä¸ºç©º


            
```

#### è¿­ä»£æ³•æ ‡å‡†æ­¥éª¤


```python
# è¿­ä»£
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return None
        queue = [root]  # æ³¨æ„ç”¨æ•°ç»„å½¢å¼å¯ä»¥æŠŠrootæ ‘åŠ å…¥é˜Ÿåˆ—
        while queue:
            tmp = queue.pop(0)
            tmp.left, tmp.right = tmp.right, tmp.left
            
            if tmp.left:
                queue.append(tmp.left)
            if tmp.right:
                queue.append(tmp.right)
        
        return root 
```

#### æ·±åº¦ä¼˜å…ˆæœç´¢

1. å¤§å¤šä½¿ç”¨**é€’å½’**å‡½æ•°
2. **é€’å½’å‡½æ•°ä¸‰è¦ç´ **:
   1. å­é—®é¢˜åŸé—®é¢˜åšç›¸åŒçš„äº‹æƒ…
   2. éœ€è¦é€’å½’ç»“æŸçš„å‡ºå£
   3. é€’å½’è¡¨è¾¾

#### å½“returnè¾“å‡ºå’Œhelperå­ä»»åŠ¡ä¸åŒæ—¶


```python
# é€’å½’è¿‡ç¨‹ï¼š
# æ±‚depthï¼ˆ1)è¦æ±‚depthï¼ˆ2)ï¼Œdepthï¼ˆ3)
# æ±‚depthï¼ˆ2)è¦ â€˜â€™â€˜
# â€™â€˜â€™
# é€’å½’è¡¨è¾¾å¼ï¼š
# depth(rt) = max(depth(rt->left), depth(rt->right))+1
class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:        
        self.ans = 1
        def depth(root):
            if not root: return 0
            self.ans = self.ans, depthdepth(root.left) + depth(root.right)+1
            return max(depth(root.left), depth(root.right))+1
        
        depth(root)
        return self.ans - 1
```

#### äºŒå‰æ ‘éå†æ–¹å¼

äºŒå‰æ ‘éå†æ–¹æ³•äºŒå‰æ ‘çš„éå†æ–¹å¼å¯ä»¥å¾ˆå¤š,å¦‚æœæˆ‘ä»¬é™åˆ¶äº†ä»å·¦åˆ°å³çš„ä¹ æƒ¯æ–¹å¼,é‚£ä¹ˆä¸»è¦å°±åˆ†ä¸ºå››ç§: 

1.å‰åºéå†è§„åˆ™æ˜¯è‹¥äºŒå‰æ ‘ä¸ºç©º,åˆ™ç©ºæ“ä½œè¿”å›,å¦åˆ™**å…ˆè®¿é—®æ ¹ç»“ç‚¹,ç„¶åå‰åºéå†å·¦å­æ ‘,å†å‰åºéå†å³å­æ ‘ã€‚**å¦‚å›¾6-8-2æ‰€ç¤º,éå†çš„é¡ºåºä¸º: ABDGH-CEIFã€‚

<img src="/img/in-post/20_07/image-20210116165251179.png" alt="image-20210116165251179" style="zoom:33%;" />

2.ä¸­åºéå†è§„åˆ™æ˜¯è‹¥æ ‘ä¸ºç©º,åˆ™ç©ºæ“ä½œè¿”å›,å¦åˆ™**ä»æ ¹ç»“ç‚¹å¼€å§‹(æ³¨æ„å¹¶ä¸æ˜¯å…ˆè®¿é—®æ ¹ç»“ç‚¹),ä¸­åºéå†æ ¹ç»“ç‚¹çš„å·¦å­æ ‘,ç„¶åæ˜¯è®¿é—®æ ¹ç»“ç‚¹,æœ€åä¸­åºéå†å³å­æ ‘**ã€‚å¦‚å›¾6-8-3æ‰€ç¤º,éå†çš„é¡ºåºä¸º:GDHBAE-ICFã€‚

<img src="/img/in-post/20_07/image-20210116165308451.png" alt="image-20210116165308451" style="zoom:33%;" />

3.ååºéå†è§„åˆ™æ˜¯è‹¥æ ‘ä¸ºç©º,åˆ™ç©ºæ“ä½œè¿”å›,å¦åˆ™**ä»å·¦åˆ°å³å…ˆå¶å­åç»“ç‚¹çš„æ–¹å¼éå†è®¿é—®å·¦å³å­æ ‘,æœ€åæ˜¯è®¿é—®æ ¹ç»“ç‚¹**ã€‚å¦‚å›¾6-8-4æ‰€ç¤º,éå†çš„é¡ºåºä¸º:GHDBIEFCAã€‚

<img src="/img/in-post/20_07/image-20210116170012938.png" alt="image-20210116170012938" style="zoom:33%;" />

4.å±‚åºéå†è§„åˆ™æ˜¯è‹¥æ ‘ä¸ºç©º,åˆ™ç©ºæ“ä½œè¿”å›,å¦åˆ™ä»æ ‘çš„ç¬¬ä¸€å±‚,ä¹Ÿå°±æ˜¯æ ¹ç»“ç‚¹å¼€å§‹è®¿é—®,ä»ä¸Šè€Œä¸‹é€å±‚éå†,åœ¨åŒä¸€å±‚ä¸­,æŒ‰ä»å·¦åˆ°å³çš„é¡ºåºå¯¹ç»“ç‚¹é€307 ä¸ªè®¿é—®ã€‚å¦‚å›¾6-8-5æ‰€ç¤º,éå†çš„é¡ºåºä¸º:ABCDEFGHIã€‚

<img src="/img/in-post/20_07/image-20210116170000354.png" alt="image-20210116170000354" style="zoom:33%;" />

### âœ…101. å¯¹ç§°äºŒå‰æ ‘(äºŒå‰æ ‘ä¸æ˜ç™½)  

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ£€æŸ¥å®ƒæ˜¯å¦æ˜¯é•œåƒå¯¹ç§°çš„ã€‚

```
ä¾‹å¦‚ï¼ŒäºŒå‰æ ‘Â [1,2,2,3,4,4,3] æ˜¯å¯¹ç§°çš„ã€‚

    1
   / \
  2   2
 / \ / \
3  4 4  3
ä½†æ˜¯ä¸‹é¢è¿™ä¸ªÂ [1,2,2,null,3,null,3] åˆ™ä¸æ˜¯é•œåƒå¯¹ç§°çš„:

    1
   / \
  2   2
   \   \
   3    3
è¯´æ˜:

å¦‚æœä½ å¯ä»¥è¿ç”¨é€’å½’å’Œè¿­ä»£ä¸¤ç§æ–¹æ³•è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä¼šå¾ˆåŠ åˆ†ã€‚
```


```python
# è‡ªå·±å†™çš„ åˆ¤æ–­æ•°ç»„ äºŒå‰æ ‘ä¸è¡Œ
class Solution:
    def isSymmetric(self, root) -> bool:
        import math
        length = len(root)
        line_sum = math.log(length+1, 2)
#         print(line_sum)
        if line_sum % 1 != 0:return False
        

        for i in range(int(line_sum)):
            for j in range(int(math.pow(2,(i-1)))): 
                if root[int(math.pow(2,i)-1+j)] != root[int(math.pow(2,(i+1))-2-j)]:
                    return False
        return True
```


```python
global null
null = '#'
root = [1,2,2,null,3,null,3]
root = [1,2,2,3,4,4,3]
solution = Solution()
result = solution.isSymmetric(root)
print(result)
```


```python
# é€’å½’æ–¹æ³•
class Solution(object):
	def isSymmetric(self, root):
		"""
		:type root: TreeNode
		:rtype: bool
		"""
		if not root:
			return True
		def dfs(left,right):
			# é€’å½’çš„ç»ˆæ­¢æ¡ä»¶æ˜¯ä¸¤ä¸ªèŠ‚ç‚¹éƒ½ä¸ºç©º
			# æˆ–è€…ä¸¤ä¸ªèŠ‚ç‚¹ä¸­æœ‰ä¸€ä¸ªä¸ºç©º
			# æˆ–è€…ä¸¤ä¸ªèŠ‚ç‚¹çš„å€¼ä¸ç›¸ç­‰
			if not (left or right):
				return True
			if not (left and right):
				return False
			if left.val!= right.val:
				return False
			return dfs(left.left,right.right) and dfs(left.right,right.left)
		# ç”¨é€’å½’å‡½æ•°ï¼Œæ¯”è¾ƒå·¦èŠ‚ç‚¹ï¼Œå³èŠ‚ç‚¹
		return dfs(root.left,root.right)
```


```python
root = [1,2,2,null,3,null,3]
solution = Solution()
result = solution.isSymmetric(root)
print(result)
```

#### 2ï¸âƒ£(40m)  


```python
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if not root: return True
        def helper(root1, root2):
            if not (root1 or root2): return True
            elif not (root1 and root2):  return False

            if root1.val != root2.val: return False
            return helper(root1.left, root2.right) and helper(root1.right, root2.left)

        return helper(root, root)
```

### âœ…104. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦  

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ‰¾å‡ºå…¶æœ€å¤§æ·±åº¦ã€‚

äºŒå‰æ ‘çš„æ·±åº¦ä¸ºæ ¹èŠ‚ç‚¹åˆ°æœ€è¿œå¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°ã€‚

è¯´æ˜:Â å¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚

```
ç¤ºä¾‹ï¼š
ç»™å®šäºŒå‰æ ‘ [3,9,20,null,null,15,7]ï¼Œ

    3
   / \
  9  20
    /  \
   15   7
è¿”å›å®ƒçš„æœ€å¤§æ·±åº¦Â 3 ã€‚

````


```python
# æ ‘èŠ‚ç‚¹TreeNodeå®šä¹‰
class TreeNode(object):
    """ Definition of a binary tree node."""
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
```


```python
# é€’å½’-DFSæ·±åº¦æœç´¢ç­–ç•¥
class Solution:
    def maxDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """ 
        if root is None: 
            return 0 
        else: 
            left_height = self.maxDepth(root.left) 
            right_height = self.maxDepth(root.right) 
            return max(left_height, right_height) + 1
```


```python
# è¿­ä»£
class Solution:
    def maxDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """ 
        stack = []
        if root is not None:
            stack.append((1, root))
        
        
        depth = 0
        while stack != []:
            current_depth, root = stack.pop()
            if root is not None:
                depth = max(depth, current_depth)
                stack.append((current_depth + 1, root.left))
                stack.append((current_depth + 1, root.right))
        
        return depth
```

#### 2ï¸âƒ£(50m)   


```python
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        def helper( root, depth):
            if not root:
                return 0
            
            self.maxdepth = max(self.maxdepth,depth + 1)
                    
            helper(root.left, depth + 1)
            helper(root.right, depth + 1)
            
            return self.maxdepth

        self.maxdepth = 0
        return helper(root, 0)
```

### ğŸš©(50m) 108. å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘

å°†ä¸€ä¸ªæŒ‰ç…§å‡åºæ’åˆ—çš„æœ‰åºæ•°ç»„ï¼Œè½¬æ¢ä¸ºä¸€æ£µé«˜åº¦å¹³è¡¡äºŒå‰æœç´¢æ ‘ã€‚

æœ¬é¢˜ä¸­ï¼Œä¸€ä¸ªé«˜åº¦å¹³è¡¡äºŒå‰æ ‘æ˜¯æŒ‡ä¸€ä¸ªäºŒå‰æ ‘æ¯ä¸ªèŠ‚ç‚¹ çš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡ 1ã€‚

```
ç¤ºä¾‹:

ç»™å®šæœ‰åºæ•°ç»„: [-10,-3,0,5,9],

ä¸€ä¸ªå¯èƒ½çš„ç­”æ¡ˆæ˜¯ï¼š[0,-3,9,-10,null,5]ï¼Œå®ƒå¯ä»¥è¡¨ç¤ºä¸‹é¢è¿™ä¸ªé«˜åº¦å¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼š

      0
     / \
   -3   9
   /   /
 -10  5
```

#### 2ï¸âƒ£


```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        if not nums: return None
        
        # å› ä¸ºæ˜¯å¹³è¡¡äºŒå‰æ ‘, æ•…æ‰¾ä¸­é—´èŠ‚ç‚¹
        mid = len(nums)//2
        node = TreeNode(nums[mid])  # æ³¨æ„rootæ˜¯ä¸€ä¸ªå€¼!
        
        left = nums[:mid]
        right = nums[mid+1:]
    
    
        node.left = sortedArrayToBST(left)
        node.right = sortedArrayToBST(right)
        
        return node
    
        
```


    ---------------------------------------------------------------------------
    
    NameError                                 Traceback (most recent call last)
    
    <ipython-input-6-a9ae52dc2c7f> in <module>
    ----> 1 class Solution:
          2     def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
          3         if not nums: return None
          4 
          5         # å› ä¸ºæ˜¯å¹³è¡¡äºŒå‰æ ‘, æ•…æ‰¾ä¸­é—´èŠ‚ç‚¹


    <ipython-input-6-a9ae52dc2c7f> in Solution()
          1 class Solution:
    ----> 2     def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
          3         if not nums: return None
          4 
          5         # å› ä¸ºæ˜¯å¹³è¡¡äºŒå‰æ ‘, æ•…æ‰¾ä¸­é—´èŠ‚ç‚¹


    NameError: name 'List' is not defined

### âœ…(50m) 226. ç¿»è½¬äºŒå‰æ ‘

ç¿»è½¬ä¸€æ£µäºŒå‰æ ‘ã€‚

```
ç¤ºä¾‹ï¼šè¾“å…¥ï¼š     4   /   \  2     7 / \   / \1   3 6   9è¾“å‡ºï¼š     4   /   \  7     2 / \   / \9   6 3   1
```

<img src="/img/in-post/20_07/0f91f7cbf5740de86e881eb7427c6c3993f4eca3624ca275d71e21c5e3e2c550-226_2.gif" alt="image.png" style="zoom:50%;" />

**é€’å½’æ³•ä¸å¸¦helperå‡½æ•°æ ‡å‡†æ­¥éª¤**


```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
# é€’å½’
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:  # root is empty then return, å³ä½¿å­æ ‘ä¸ºç©ºä¹Ÿæ²¡å…³ç³»åº”è¯¥
            return None

        root.left, root.right = root.right, root.left
        
        self.invertTree(root.left)
        self.invertTree(root.right)

        return root  #  æ³¨æ„è¿”å›çš„æ˜¯rootï¼Œæ­¤æ—¶rootä¸ºç©º


            
```

**è¿­ä»£æ³•æ ‡å‡†æ­¥éª¤**


```python
# è¿­ä»£
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return None
        queue = [root]  # æ³¨æ„ç”¨æ•°ç»„å½¢å¼å¯ä»¥æŠŠrootæ ‘åŠ å…¥é˜Ÿåˆ—
        while queue:
            tmp = queue.pop(0)
            tmp.left, tmp.right = tmp.right, tmp.left
            
            if tmp.left:
                queue.append(tmp.left)
            if tmp.right:
                queue.append(tmp.right)
        
        return root 
```

### ğŸš©(40m) 543. äºŒå‰æ ‘çš„ç›´å¾„

ç»™å®šä¸€æ£µäºŒå‰æ ‘ï¼Œä½ éœ€è¦è®¡ç®—å®ƒçš„ç›´å¾„é•¿åº¦ã€‚ä¸€æ£µäºŒå‰æ ‘çš„ç›´å¾„é•¿åº¦æ˜¯ä»»æ„ä¸¤ä¸ªç»“ç‚¹è·¯å¾„é•¿åº¦ä¸­çš„æœ€å¤§å€¼ã€‚è¿™æ¡è·¯å¾„å¯èƒ½ç©¿è¿‡ä¹Ÿå¯èƒ½ä¸ç©¿è¿‡æ ¹ç»“ç‚¹ã€‚

 

```
ç¤ºä¾‹ :
ç»™å®šäºŒå‰æ ‘

          1
         / \
        2   3
       / \     
      4   5    
è¿”å› 3, å®ƒçš„é•¿åº¦æ˜¯è·¯å¾„ [4,2,1,3] æˆ–è€… [5,2,1,3]ã€‚
```

**æ·±åº¦ä¼˜å…ˆæœç´¢**

1. å¤§å¤šä½¿ç”¨é€’å½’å‡½æ•°
2. é€’å½’å‡½æ•°ä¸‰è¦ç´ 
   1. å­é—®é¢˜åŸé—®é¢˜åšç›¸åŒçš„äº‹æƒ…
   2. éœ€è¦é€’å½’ç»“æŸçš„å‡ºå£
   3. é€’å½’è¡¨è¾¾å¼

**å½“returnè¾“å‡ºå’Œhelperå­ä»»åŠ¡ä¸åŒæ—¶**


```python
# é€’å½’è¿‡ç¨‹ï¼š
# æ±‚depthï¼ˆ1)è¦æ±‚depthï¼ˆ2)ï¼Œdepthï¼ˆ3)
# æ±‚depthï¼ˆ2)è¦ â€˜â€™â€˜
# â€™â€˜â€™
# é€’å½’è¡¨è¾¾å¼ï¼š
# depth(rt) = max(depth(rt->left), depth(rt->right))+1
class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:        
        self.ans = 1
        def depth(root):
            if not root: return 0
            self.ans = self.ans, depthdepth(root.left) + depth(root.right)+1
            return max(depth(root.left), depth(root.right))+1
        
        depth(root)
        return self.ans - 1
```

#### 2ï¸âƒ£ 


```python
class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:        
        self.ans = 1
        def depth():  # è¿”å›è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„å­æ ‘çš„æ·±åº¦( max(L,R)+1 )
            if not root: return 0
            L = depth(node.left)
            R = depth(node.right)
            self.ans = max(self.ans, L+R+1)
            return max(L,R) + 1
        depth(root)
        return self.ans - 1

```


```python

```

### âœ… 102. äºŒå‰æ ‘çš„å±‚åºéå†

ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¯·ä½ è¿”å›å…¶æŒ‰ å±‚åºéå† å¾—åˆ°çš„èŠ‚ç‚¹å€¼ã€‚ (å³é€å±‚åœ°ï¼Œä»å·¦åˆ°å³è®¿é—®æ‰€æœ‰èŠ‚ç‚¹)ã€‚

 

```
ç¤ºä¾‹ï¼š
äºŒå‰æ ‘ï¼š[3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
è¿”å›å…¶å±‚æ¬¡éå†ç»“æœï¼š

[
  [3],
  [9,20],
  [15,7]
]
```

#### 2ï¸âƒ£(50m) 


```python
# é€’å½’
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        valuePerDepth = []
        def helper(root, index):
            if not root: return 0
                       
            if len(valuePerDepth) < index+1:
                valuePerDepth.append([])

            valuePerDepth[index].append(root.val)   # ä¸€å®šæ³¨æ„ root æ˜¯æ ‘ï¼Œ root.val æ˜¯å€¼

            L = root.left
            R = root.right
            if L: helper(L, index+1)
            if R: helper(R, index+1) 
        
        helper(root, 0)
        return valuePerDepth    
            
            
            
```


```python
# å®˜è§£ï¼Œè¿­ä»£
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root: return []
        res = []
        queue = [root]  
        while queue:
            size = len(queue)
            tmp = []
            
            for _ in xrange(size):
                r = queue.pop(0)
                tmp.append(r.val)
                if r.left:
                    queue.append(r.left)
                if r.right:
                    queue.append(r.right)
            res.append(tmp)
        return res



```

### âœ… (7m) 107. äºŒå‰æ ‘çš„å±‚æ¬¡éå† II

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼è‡ªåº•å‘ä¸Šçš„å±‚æ¬¡éå†ã€‚ (å³æŒ‰ä»å¶å­èŠ‚ç‚¹æ‰€åœ¨å±‚åˆ°æ ¹èŠ‚ç‚¹æ‰€åœ¨çš„å±‚ï¼Œé€å±‚ä»å·¦å‘å³éå†)

```
ä¾‹å¦‚ï¼šç»™å®šäºŒå‰æ ‘ [3,9,20,null,null,15,7],    3   / \  9  20    /  \   15   7è¿”å›å…¶è‡ªåº•å‘ä¸Šçš„å±‚æ¬¡éå†ä¸ºï¼š[  [15,7],  [9,20],  [3]]
```


```python
class Solution:    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:        valuePerDepth = []        def helper(root, index):            if not root: return 0                                   if len(valuePerDepth) < index+1:                valuePerDepth.append([])            valuePerDepth[index].append(root.val)   # ä¸€å®šæ³¨æ„ root æ˜¯æ ‘ï¼Œ root.val æ˜¯å€¼            L = root.left            R = root.right            if L: helper(L, index+1)            if R: helper(R, index+1)                 helper(root, 0)        valuePerDepth = valuePerDepth[::-1]  # åè½¬æ•°ç»„æ“ä½œ        return valuePerDepth            
```

###  âœ…617. åˆå¹¶äºŒå‰æ ‘

ç»™å®šä¸¤ä¸ªäºŒå‰æ ‘ï¼Œæƒ³è±¡å½“ä½ å°†å®ƒä»¬ä¸­çš„ä¸€ä¸ªè¦†ç›–åˆ°å¦ä¸€ä¸ªä¸Šæ—¶ï¼Œä¸¤ä¸ªäºŒå‰æ ‘çš„ä¸€äº›èŠ‚ç‚¹ä¾¿ä¼šé‡å ã€‚

ä½ éœ€è¦å°†ä»–ä»¬åˆå¹¶ä¸ºä¸€ä¸ªæ–°çš„äºŒå‰æ ‘ã€‚åˆå¹¶çš„è§„åˆ™æ˜¯å¦‚æœä¸¤ä¸ªèŠ‚ç‚¹é‡å ï¼Œé‚£ä¹ˆå°†ä»–ä»¬çš„å€¼ç›¸åŠ ä½œä¸ºèŠ‚ç‚¹åˆå¹¶åçš„æ–°å€¼ï¼Œå¦åˆ™ä¸ä¸º NULL çš„èŠ‚ç‚¹å°†ç›´æ¥ä½œä¸ºæ–°äºŒå‰æ ‘çš„èŠ‚ç‚¹ã€‚

``` python
ç¤ºä¾‹ 1:è¾“å…¥: 	Tree 1                     Tree 2                            1                         2                                      / \                       / \                                    3   2                     1   3                               /                           \   \                            5                             4   7                  è¾“å‡º: åˆå¹¶åçš„æ ‘:	     3	    / \	   4   5	  / \   \ 	 5   4   7æ³¨æ„: åˆå¹¶å¿…é¡»ä»ä¸¤ä¸ªæ ‘çš„æ ¹èŠ‚ç‚¹å¼€å§‹ã€‚
```


```python
class Solution:    def mergeTrees(self, node1: TreeNode, node2: TreeNode) -> TreeNode:        if not node1: return node2        elif not node2: return node1        node1.val = node1.val + node2.val        node1.left = self.mergeTrees(node1.left, node2.left)        node1.right = self.mergeTrees(node1.right, node2.right)        return node1        
```

#### 2ï¸âƒ£

#### 3ï¸âƒ£(30m)

```python
class Solution:    def mergeTrees(self, node1: TreeNode, node2: TreeNode) -> TreeNode:        if not node1: return node2        elif not node2: return node1        node = TreeNode(node1.val + node2.val)        node.left = self.mergeTrees(node1.left, node2.left)        node.right = self.mergeTrees(node1.right, node2.right)        return node        
```



###  ğŸš©687. æœ€é•¿åŒå€¼è·¯å¾„

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ‰¾åˆ°æœ€é•¿çš„è·¯å¾„ï¼Œè¿™ä¸ªè·¯å¾„ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹å…·æœ‰ç›¸åŒå€¼ã€‚ è¿™æ¡è·¯å¾„å¯ä»¥ç»è¿‡ä¹Ÿå¯ä»¥ä¸ç»è¿‡æ ¹èŠ‚ç‚¹ã€‚

æ³¨æ„ï¼šä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´çš„è·¯å¾„é•¿åº¦ç”±å®ƒä»¬ä¹‹é—´çš„è¾¹æ•°è¡¨ç¤ºã€‚

``` python
ç¤ºä¾‹ 1:è¾“å…¥:              5             / \            4   5           / \   \          1   1   5è¾“å‡º:2ç¤ºä¾‹ 2:è¾“å…¥:              1             / \            4   5           / \   \          4   4   5è¾“å‡º:2æ³¨æ„: ç»™å®šçš„äºŒå‰æ ‘ä¸è¶…è¿‡10000ä¸ªç»“ç‚¹ã€‚ æ ‘çš„é«˜åº¦ä¸è¶…è¿‡1000ã€‚
```


```python
class Solution(object):    def longestUnivaluePath(self, root):        self.ans = 0        def arrow_length(node):            if not node: return 0            left_length = arrow_length(node.left)            right_length = arrow_length(node.right)            left_arrow = right_arrow = 0            if node.left and node.left.val == node.val:                left_arrow = left_length + 1            if node.right and node.right.val == node.val:                right_arrow = right_length + 1            self.ans = max(self.ans, left_arrow + right_arrow)            return max(left_arrow, right_arrow)        arrow_length(root)        return self.ans
```

#### 2ï¸âƒ£



### âœ… 112. è·¯å¾„æ€»å’Œ

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘å’Œä¸€ä¸ªç›®æ ‡å’Œï¼Œåˆ¤æ–­è¯¥æ ‘ä¸­æ˜¯å¦å­˜åœ¨æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ï¼Œè¿™æ¡è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹å€¼ç›¸åŠ ç­‰äºç›®æ ‡å’Œã€‚

è¯´æ˜: å¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚

``` python
ç¤ºä¾‹: ç»™å®šå¦‚ä¸‹äºŒå‰æ ‘ï¼Œä»¥åŠç›®æ ‡å’Œ sum = 22ï¼Œ              5             / \            4   8           /   / \          11  13  4         /  \      \        7    2      1è¿”å› true, å› ä¸ºå­˜åœ¨ç›®æ ‡å’Œä¸º 22 çš„æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ 5->4->11->2ã€‚
```

#### 2ï¸âƒ£ (20m)


```python
class Solution:    def hasPathSum(self, root: TreeNode, sum: int) -> bool:        if not root: return False        if root.val == sum and not(root.left or root.right):            return True        return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val)
```

###  ğŸš©257. äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¿”å›æ‰€æœ‰ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ã€‚

è¯´æ˜: å¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚

``` python
ç¤ºä¾‹:è¾“å…¥:   1 /   \2     3 \  5è¾“å‡º: ["1->2->5", "1->3"]è§£é‡Š: æ‰€æœ‰æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ä¸º: 1->2->5, 1->3
```


```python
# Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    def binaryTreePaths(self, root: TreeNode) -> List[str]:        if not root: return []        ans = []        path = ''        def dfs(root, path):            if root:                 path+=str(root.val)                if not(root.left or root.right):                     ans.append(path)                else:                    path += '->'                    dfs(root.left, path)                    dfs(root.right, path)        dfs(root,path)        return ans        
```

#### 2ï¸âƒ£(30m)

æ³¨æ„ï¼š 

1. dfs æ‰¾è·¯å¾„æ—¶ï¼Œé™¤äº†ä¼ å…¥å½“å‰èŠ‚ç‚¹ï¼ˆ`node`ï¼‰ï¼Œè¿˜è¦ä¼ å…¥`path`.
2. 

###  ğŸš©669. ä¿®å‰ªäºŒå‰æœç´¢æ ‘

ç»™å®šä¸€ä¸ªäºŒå‰æœç´¢æ ‘ï¼ŒåŒæ—¶ç»™å®šæœ€å°è¾¹ç•ŒL å’Œæœ€å¤§è¾¹ç•Œ Rã€‚é€šè¿‡ä¿®å‰ªäºŒå‰æœç´¢æ ‘ï¼Œä½¿å¾—æ‰€æœ‰èŠ‚ç‚¹çš„å€¼åœ¨[L, R]ä¸­ (R>=L) ã€‚ä½ å¯èƒ½éœ€è¦æ”¹å˜æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œæ‰€ä»¥ç»“æœåº”å½“è¿”å›ä¿®å‰ªå¥½çš„äºŒå‰æœç´¢æ ‘çš„æ–°çš„æ ¹èŠ‚ç‚¹ã€‚

``` python
ç¤ºä¾‹ 1:è¾“å…¥:     1   / \  0   2  L = 1  R = 2è¾“å‡º:     1      \       2ç¤ºä¾‹ 2:è¾“å…¥:     3   / \  0   4   \    2   /  1  L = 1  R = 3è¾“å‡º:       3     /    2     / 1
```

#### 2ï¸âƒ£(40m)

ä»¤ `trim(node)` ä½œä¸ºè¯¥èŠ‚ç‚¹ä¸Šçš„å­æ ‘çš„ç†æƒ³ç­”æ¡ˆ,è¿›è¡Œæ„å»º

###  âœ…(40m) 538. æŠŠäºŒå‰æœç´¢æ ‘è½¬æ¢ä¸ºç´¯åŠ æ ‘

ç»™å®šä¸€ä¸ªäºŒå‰æœç´¢æ ‘ï¼ˆBinary Search Tree)ï¼ŒæŠŠå®ƒè½¬æ¢æˆä¸ºç´¯åŠ æ ‘ï¼ˆGreater Tree)ï¼Œä½¿å¾—æ¯ä¸ªèŠ‚ç‚¹çš„å€¼æ˜¯åŸæ¥çš„èŠ‚ç‚¹å€¼åŠ ä¸Šæ‰€æœ‰å¤§äºå®ƒçš„èŠ‚ç‚¹å€¼ä¹‹å’Œã€‚


```
ä¾‹å¦‚ï¼šè¾“å…¥: åŸå§‹äºŒå‰æœç´¢æ ‘:              5            /   \           2     13è¾“å‡º: è½¬æ¢ä¸ºç´¯åŠ æ ‘:             18            /   \          20     13
```

#### 2ï¸âƒ£ # ä¸€å®šæ³¨æ„ï¼Œæ­¤é¢˜è¦ç”¨å…¨å±€å˜é‡ï¼Œè€Œä¸èƒ½åªæ˜¯ä¼ å‚

```python
# ä¸€å®šæ³¨æ„ï¼Œæ­¤é¢˜è¦ç”¨å…¨å±€å˜é‡ï¼Œè€Œä¸èƒ½åªæ˜¯ä¼ å‚class Solution:    def convertBST(self, root: TreeNode) -> TreeNode:        def helper(node, ):            global nums_sum            if not node:                return None            helper(node.right,)            # ä¸­åº                        nums_sum += node.val            node.val = nums_sum  # ?            helper(node.left,)                global nums_sum        nums_sum = 0        helper(root)        return root# class Solution:#     def convertBST(self, root: TreeNode) -> TreeNode:#         def helper(node, nums_sum):#             if not node:#                 return None#             helper(node.right,nums_sum)#             # ä¸­åº            #             nums_sum += node.val#             node.val = nums_sum  # ?#             helper(node.left,nums_sum)        #         nums_sum = 0#         helper(root, nums_sum)#         return root
```



### âœ… (20m) 199. äºŒå‰æ ‘çš„å³è§†å›¾

ç»™å®šä¸€æ£µäºŒå‰æ ‘ï¼Œæƒ³è±¡è‡ªå·±ç«™åœ¨å®ƒçš„å³ä¾§ï¼ŒæŒ‰ç…§ä»é¡¶éƒ¨åˆ°åº•éƒ¨çš„é¡ºåºï¼Œè¿”å›ä»å³ä¾§æ‰€èƒ½çœ‹åˆ°çš„èŠ‚ç‚¹å€¼ã€‚

ç¤ºä¾‹:

```
è¾“å…¥: [1,2,3,null,5,null,4]è¾“å‡º: [1, 3, 4]è§£é‡Š:   1            <--- /   \2     3         <--- \     \  5     4       <---
```

#### 2ï¸âƒ£

cur = stack.pop(0)  # ä¸€å®šæ³¨æ„æ˜¯pop(0)

```python
class Solution:    def rightSideView(self, root: TreeNode) -> List[int]:        if not root:            return []        stack = [root]        ans = []        while stack:            for i in range(len(stack)):                cur = stack.pop(0)  # ä¸€å®šæ³¨æ„æ˜¯pop(0)                if cur.left: stack.append(cur.left)                if cur.right: stack.append(cur.right)            ans.append(cur.val)        return ans
```

### ğŸš©ï¼ˆå›°éš¾ï¼‰124. äºŒå‰æ ‘ä¸­çš„æœ€å¤§è·¯å¾„å’Œ

ç»™å®šä¸€ä¸ªéç©ºäºŒå‰æ ‘ï¼Œè¿”å›å…¶æœ€å¤§è·¯å¾„å’Œã€‚

æœ¬é¢˜ä¸­ï¼Œè·¯å¾„è¢«å®šä¹‰ä¸ºä¸€æ¡ä»æ ‘ä¸­ä»»æ„èŠ‚ç‚¹å‡ºå‘ï¼Œè¾¾åˆ°ä»»æ„èŠ‚ç‚¹çš„åºåˆ—ã€‚è¯¥è·¯å¾„è‡³å°‘åŒ…å«ä¸€ä¸ªèŠ‚ç‚¹ï¼Œä¸”ä¸ä¸€å®šç»è¿‡æ ¹èŠ‚ç‚¹ã€‚

```
ç¤ºä¾‹ 1:è¾“å…¥: [1,2,3]       1      / \     2   3è¾“å‡º: 6ç¤ºä¾‹ 2:è¾“å…¥: [-10,9,20,null,null,15,7]   -10   / \  9  20    /  \   15   7
```

#### 2ï¸âƒ£



### âœ… (10m) 102. äºŒå‰æ ‘çš„å±‚åºéå†

ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¯·ä½ è¿”å›å…¶æŒ‰ å±‚åºéå† å¾—åˆ°çš„èŠ‚ç‚¹å€¼ã€‚ (å³é€å±‚åœ°ï¼Œä»å·¦åˆ°å³è®¿é—®æ‰€æœ‰èŠ‚ç‚¹)ã€‚

#### 2ï¸âƒ£

```python
class Solution:    def levelOrder(self, root: TreeNode) -> List[List[int]]:        if not root:            return []        stack = [root]        ans = []        while stack:            tmp = []            for i in range(len(stack)):                cur = stack.pop(0)                tmp.append(cur.val)                if cur.left: stack.append(cur.left)                if cur.right: stack.append(cur.right)            ans.append(tmp)        return ans
```




### ğŸš©(1.0h) [95. ä¸åŒçš„äºŒå‰æœç´¢æ ‘ II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)

ç»™å®šä¸€ä¸ªæ•´æ•° *n*ï¼Œç”Ÿæˆæ‰€æœ‰ç”± 1 ... *n* ä¸ºèŠ‚ç‚¹æ‰€ç»„æˆçš„ **äºŒå‰æœç´¢æ ‘** ã€‚

### ğŸš©(33m)  [114. äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

```python
class Solution:
    def flatten(self, root: TreeNode) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        if root == None:
            return 

        self.flatten(root.left)
        self.flatten(root.right)
    
        #/**** ååºéå†ä½ç½® ****/
        #// 1ã€å·¦å³å­æ ‘å·²ç»è¢«æ‹‰å¹³æˆä¸€æ¡é“¾è¡¨
        left = root.left
        right = root.right

        #// 2ã€å°†å·¦å­æ ‘ä½œä¸ºå³å­æ ‘
        root.left = None
        root.right = left

        #// 3ã€å°†åŸå…ˆçš„å³å­æ ‘æ¥åˆ°å½“å‰å³å­æ ‘çš„æœ«ç«¯
        p = root 
        while(p.right):
            p = p.right
        p.right = right

```

### âœ…(90m)[116. å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

æ­¥éª¤ï¼š

1. ä½¿ç”¨queueæ„å»ºå±‚åºéå†
2. åŠ å¾ªç¯ä½¿æ¯å±‚è¿›è¡Œä¸€æ¬¡è¾“å‡º

```python
class Solution:
    def connect(self, root: 'Node') -> 'Node':
        # å±‚åºéå†
        if not root: return None
        queue = [root]
        while queue:
            for i in range(len(queue)-1):
                queue[i].next = queue[i+1]

            for i in range(len(queue)):
                cur = queue.pop(0)
                if cur.left: queue.append(cur.left)
                if cur.right: queue.append(cur.right)
        
        return root
```

### ğŸš©[297. åºåˆ—åŒ–äºŒå‰æ ‘](https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/)

```python
class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """

        s = ""
        queue = []
        queue.append(root)
        
        while queue:
            root = queue.pop(0)
            if root:
                s += str(root.val)
                queue.append(root.left)
                queue.append(root.right)
            else:
                s += "n"
            s += " "        
        return s


    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        tree = data.split()
        print(tree)
        if tree[0] == "n":
            return None
        queue = []
        root = TreeNode(int(tree[0]))
        queue.append(root)

        i = 1
        while queue:
            cur = queue.pop(0)
            if cur == None:
                continue
            cur.left = TreeNode(int(tree[i])) if tree[i] != "n" else None
            cur.right = TreeNode(int(tree[i + 1])) if tree[i + 1] != "n" else None
            i += 2
            queue.append(cur.left)
            queue.append(cur.right)
        return root
```

#### 2ï¸âƒ£



### âœ…(30m)[103. äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚åºéå†](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

éš¾åº¦ä¸­ç­‰378

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„é”¯é½¿å½¢å±‚åºéå†ã€‚ï¼ˆå³å…ˆä»å·¦å¾€å³ï¼Œå†ä»å³å¾€å·¦è¿›è¡Œä¸‹ä¸€å±‚éå†ï¼Œä»¥æ­¤ç±»æ¨ï¼Œå±‚ä¸å±‚ä¹‹é—´äº¤æ›¿è¿›è¡Œï¼‰ã€‚

ä¾‹å¦‚ï¼š
ç»™å®šäºŒå‰æ ‘ `[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

è¿”å›é”¯é½¿å½¢å±‚åºéå†å¦‚ä¸‹ï¼š

```
[
  [3],
  [20,9],
  [15,7]
]
```

```python
class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root: return []
        queue = [root]
        ans = []
        forward = True
        while queue:
            size = len(queue)
            temp = []
            for i in range(size):
                node = queue.pop(0)
                temp.append(node.val)  # æ³¨æ„å¯¸çš„æ˜¯nodeçš„å€¼
                if node.left: queue.append(node.left)
                if node.right: queue.append(node.right)
                # queue.pop(0)
            if forward == True:
                ans.append(temp)
                forward = False
            else:
                ans.append(temp[::-1])
                forward = True                
        return ans
```

æ€»ç»“ï¼š

1. è®°å¾—æ”¾temp

### âœ…(20m)[144. äºŒå‰æ ‘çš„å‰åºéå†](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

éš¾åº¦ä¸­ç­‰511

ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œè¿”å›å®ƒèŠ‚ç‚¹å€¼çš„ **å‰åº** éå†ã€‚

**ç¤ºä¾‹ 1ï¼š**

![img](/img/in-post/20_07/inorder_1.jpg)

```
è¾“å…¥ï¼šroot = [1,null,2,3]
è¾“å‡ºï¼š[1,2,3]
```



```python
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        def helper(node):
            if not node:
                return 
            ans.append(node.val)
            helper(node.left)
            helper(node.right)
        
        ans = []
        helper(root)
        return ans 
```

è¿­ä»£æ³•å®˜è§£ï¼šğŸš©

```python
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        res = list()
        if not root:
            return res
        stack = []
        node = root
        while stack or node:
            while node:
                res.append(node.val)
                stack.append(node)
                node = node.left
            node = stack.pop()
            node = node.right
        return res
```



### âœ…(10m)[145. äºŒå‰æ ‘çš„ååºéå†](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

éš¾åº¦ä¸­ç­‰517

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¿”å›å®ƒçš„ *ååº* éå†ã€‚

**ç¤ºä¾‹:**

```
è¾“å…¥: [1,null,2,3]  
   1
    \
     2
    /
   3 

è¾“å‡º: [3,2,1]
```

```python
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        def helper(node):
            if not node: 
                return 
            helper(node.left)
            helper(node.right)
            ans.append(node.val)
        ans = []
        helper(root)
        return ans 
```

## 