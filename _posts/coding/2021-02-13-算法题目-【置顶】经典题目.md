# ç»å…¸é¢˜ç›®

## æŽ’åº

#### ðŸš©å†’æ³¡æŽ’åº â€” é€ä¸ªæ¯”è¾ƒï¼Œæœ€å¤§çš„åŽç§»

```python
def bubbleSort(nums):
    for i in range(len(nums)):
        # Last i elements are already in place
        for j in range(len(nums)-i-1):
 							if nums[j] > nums[j+1]:
                nums[j], nums[j+1] = nums[j+1], nums[j]
```

#### é€‰æ‹©æŽ’åº â€” éåŽ†é€‰æ‹©æœ€å°çš„ï¼Œæ”¾åˆ°æœ€å‰

#### ðŸš©æ’å…¥æŽ’åºï¼ˆç†Ÿæ‚‰ï¼‰ â€” å‘çŽ°å°æ•°å­—ï¼Œå‘å‰äº¤æ¢

ç®€å•æŽ’åºé‡Œï¼Œæ’å…¥æŽ’åºæœ€å¥½ï¼ˆ**æ ·æœ¬å°ä¸”åŸºæœ¬æœ‰åºæ—¶ï¼Œæ•ˆçŽ‡è¾ƒé«˜ï¼Œæ•ˆæžœå¥½**ï¼‰

```python
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        for ind in range(1,len(nums)):
            i = ind
            while i > 0 and nums[i] < nums[i-1]:
                nums[i], nums[i-1] = nums[i-1], nums[i]
                i -= 1
        return nums
```



#### å¸Œå°”æŽ’åº â€” æ”¹è¿›çš„æ’å…¥æŽ’åºï¼Œé—´éš”ç”±å¤§åˆ°å°æŽ’åº

#### ðŸš© å½’å¹¶æŽ’åºï¼ˆæŽŒæ¡ï¼‰

æœ€åæƒ…å†µæ•ˆæžœæœ€å¥½

```python
class Solution:
    def merge_sort(self, nums, l, r):
        if l == r:
            return
        mid = (l + r) // 2
        self.merge_sort(nums, l, mid)
        self.merge_sort(nums, mid + 1, r)
        tmp = []
        i, j = l, mid + 1
        while i <= mid or j <= r:
            if i > mid or (j <= r and nums[j] < nums[i]):
                tmp.append(nums[j])
                j += 1
            else:
                tmp.append(nums[i])
                i += 1
        nums[l: r + 1] = tmp

    def sortArray(self, nums: List[int]) -> List[int]:
        self.merge_sort(nums, 0, len(nums) - 1)
        return nums
```

#### ðŸš© å¿«é€ŸæŽ’åº ï¼ˆæŽŒæ¡ï¼‰

```python
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        def partition(nums, left_bound, right_bound):
            pivot = nums[right_bound]
            l,r = left_bound, right_bound - 1
            while l <= r:
                while l <= r and nums[l] <= pivot:
                    l += 1
                while l <= r and nums[r] > pivot:
                    r -= 1
                if l < r:
                    nums[l], nums[r] = nums[r], nums[l]
            # æ³¨æ„è¦æŠŠè½´æ”¾åœ¨ä¸­é—´, å› ä¸ºæœ€åŽä¸€æ¬¡å¾ªçŽ¯ä¸€å®šæ˜¯èµ°çš„l++ï¼Œå³å½“å‰lå’ŒræŒ‡å‘çš„æ˜¯å¤§å€¼ï¼Œäº’æ¢lå’Œé”šç‚¹
            nums[l], nums[right_bound] = nums[right_bound], nums[l]
            return l  
        def quick_sort(nums, left_bound, right_bound):
            if left_bound>=right_bound: 
                return
            mid = partition(nums, left_bound, right_bound)
            quick_sort(nums, left_bound, mid - 1)
            quick_sort(nums, mid + 1, right_bound) # æ³¨æ„æ˜¯mid+1

        quick_sort(nums, 0, len(nums)-1)
        return nums
```

 å¿«é€ŸæŽ’åºæ˜¯æ¯ä¸ªç¨‹åºå‘˜éƒ½åº”å½“æŽŒæ¡çš„æŽ’åºç®—æ³•ã€‚å½“ç„¶æˆ‘ä»¬æŽ¥è§¦çš„ç¬¬ä¸€ä¸ªæŽ’åºç®—æ³•å¯èƒ½æ˜¯æ’å…¥æŽ’åºæˆ–è€…å†’æ³¡æŽ’åºï¼Œä½†æ•°æ®é‡ä¸€æ—¦è¶…è¿‡å‡ ä¸‡ï¼Œæ’å…¥å’Œå†’æ³¡çš„æ€§èƒ½ä¼šéžå¸¸å·®ã€‚è¿™æ—¶æ—¶é—´å¤æ‚åº¦çš„æ¸è¿›ä¼˜åŠ¿å°±è¡¨çŽ°å‡ºæ¥äº†ã€‚ **å¹³å‡æƒ…å†µä¸‹å¿«é€ŸæŽ’åºçš„æ—¶é—´å¤æ‚åº¦æ˜¯Î˜(ð‘›lgð‘›)ï¼Œæœ€åæƒ…å†µæ˜¯ð‘›2ï¼Œä½†é€šè¿‡éšæœºç®—æ³•å¯ä»¥é¿å…æœ€åæƒ…å†µã€‚ç”±äºŽé€’å½’è°ƒç”¨ï¼Œå¿«æŽ’çš„ç©ºé—´å¤æ‚åº¦æ˜¯Î˜(lgð‘›)**ã€‚æ—¶é—´å¤æ‚åº¦$O(nlogn)$ï¼Œç©ºé—´å¤æ‚åº¦$O(logn)$ã€‚

**æ­¥éª¤ï¼š**

1. æ‰¾åŸºå‡†
2. åˆ†åŒº
3. é€’å½’

> å¿«é€ŸæŽ’åºç®—æ³•å…¶å®žå¾ˆç®€å•ï¼Œé‡‡ç”¨**åˆ†æ²»ç­–ç•¥**ã€‚æ­¥éª¤å¦‚ä¸‹ï¼š
>
> 1. é€‰å–ä¸€ä¸ªåŸºå‡†å…ƒç´ ï¼ˆpivot)
> 2. æ¯”pivotå°çš„æ”¾åˆ°pivotå·¦è¾¹ï¼Œæ¯”pivotå¤§çš„æ”¾åˆ°pivotå³è¾¹
> 3. å¯¹pivotå·¦è¾¹çš„åºåˆ—å’Œå³è¾¹çš„åºåˆ—åˆ†åˆ«é€’å½’çš„æ‰§è¡Œæ­¥éª¤1å’Œæ­¥éª¤2

> **åŸºæœ¬æ€æƒ³:**é€šè¿‡ä¸€è¶ŸæŽ’åºå°†å¾…æŽ’è®°å½•åˆ†éš”æˆç‹¬ç«‹çš„ä¸¤éƒ¨åˆ†,å…¶ä¸­ä¸€éƒ¨åˆ†è®°å½•çš„å…³é”®å­—å‡æ¯”å¦ä¸€éƒ¨åˆ†çš„å…³é”®å­—å°,åˆ™å¯åˆ†åˆ«å¯¹è¿™ä¸¤éƒ¨åˆ†è®°å½•ç»§ç»­è¿›è¡ŒæŽ’åº,ä»¥è¾¾åˆ°æ•´ä¸ªåºåˆ—æœ‰åºã€‚
> **ç®—æ³•æè¿°:** å¿«é€ŸæŽ’åºä½¿ç”¨åˆ†æ²»æ³•æ¥æŠŠä¸€ä¸ªä¸²(list)åˆ†ä¸ºä¸¤ä¸ªå­ä¸²(sub-lists)ã€‚å…·ä½“ç®—æ³•æè¿°å¦‚ä¸‹: 
>
> 1. ä»Žæ•°åˆ—ä¸­æŒ‘å‡ºä¸€ä¸ªå…ƒç´ ,ç§°ä¸º **â€œåŸºå‡†â€(pivot);** 
> 2. é‡æ–°æŽ’åºæ•°åˆ—,æ‰€æœ‰å…ƒç´ æ¯”åŸºå‡†å€¼å°çš„æ‘†æ”¾åœ¨åŸºå‡†å‰é¢,æ‰€æœ‰å…ƒç´ æ¯”åŸºå‡†å€¼å¤§çš„æ‘†åœ¨åŸºå‡†çš„åŽé¢(ç›¸åŒçš„æ•°å¯ä»¥åˆ°ä»»ä¸€è¾¹)ã€‚åœ¨è¿™ä¸ªåˆ†åŒºé€€å‡ºä¹‹åŽ,è¯¥åŸºå‡†å°±å¤„äºŽæ•°åˆ—çš„ä¸­é—´ä½ç½®ã€‚è¿™ä¸ªç§°ä¸º**åˆ†åŒº(partition)**æ“ä½œ; 
> 3. **é€’å½’åœ°(recursive)**æŠŠå°äºŽåŸºå‡†å€¼å…ƒç´ çš„å­æ•°åˆ—å’Œå¤§äºŽåŸºå‡†å€¼å…ƒç´ çš„å­æ•°åˆ—æŽ’åºã€‚

## äºŒå‰æ ‘

### âœ… 07. é‡å»ºäºŒå‰æ ‘

è¾“å…¥æŸäºŒå‰æ ‘çš„å‰åºéåŽ†å’Œä¸­åºéåŽ†çš„ç»“æžœï¼Œè¯·é‡å»ºè¯¥äºŒå‰æ ‘ã€‚å‡è®¾è¾“å…¥çš„å‰åºéåŽ†å’Œä¸­åºéåŽ†çš„ç»“æžœä¸­éƒ½ä¸å«é‡å¤çš„æ•°å­—ã€‚


```
ä¾‹å¦‚ï¼Œç»™å‡º

å‰åºéåŽ† preorder =Â [3,9,20,15,7]
ä¸­åºéåŽ† inorder = [9,3,15,20,7]
è¿”å›žå¦‚ä¸‹çš„äºŒå‰æ ‘ï¼š

    3
   / \
  9  20
    /  \
   15   7
```

#### 2ï¸âƒ£

**ç»†èŠ‚**

åœ¨ä¸­åºéåŽ†ä¸­å¯¹æ ¹èŠ‚ç‚¹è¿›è¡Œå®šä½æ—¶ï¼Œä¸€ç§ç®€å•çš„æ–¹æ³•æ˜¯ç›´æŽ¥æ‰«ææ•´ä¸ªä¸­åºéåŽ†çš„ç»“æžœå¹¶æ‰¾å‡ºæ ¹èŠ‚ç‚¹ï¼Œä½†è¿™æ ·åšçš„æ—¶é—´å¤æ‚åº¦è¾ƒé«˜ã€‚æˆ‘ä»¬å¯ä»¥è€ƒè™‘ä½¿ç”¨å“ˆå¸Œè¡¨æ¥å¸®åŠ©æˆ‘ä»¬å¿«é€Ÿåœ°å®šä½æ ¹èŠ‚ç‚¹ã€‚å¯¹äºŽ**å“ˆå¸Œæ˜ å°„**ä¸­çš„æ¯ä¸ªé”®å€¼å¯¹ï¼Œé”®è¡¨ç¤ºä¸€ä¸ªå…ƒç´ ï¼ˆèŠ‚ç‚¹çš„å€¼ï¼‰ï¼Œå€¼è¡¨ç¤ºå…¶åœ¨ä¸­åºéåŽ†ä¸­çš„å‡ºçŽ°ä½ç½®ã€‚åœ¨æž„é€ äºŒå‰æ ‘çš„è¿‡ç¨‹ä¹‹å‰ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹ä¸­åºéåŽ†çš„åˆ—è¡¨è¿›è¡Œä¸€éæ‰«æï¼Œå°±å¯ä»¥æž„é€ å‡ºè¿™ä¸ªå“ˆå¸Œæ˜ å°„ã€‚åœ¨æ­¤åŽæž„é€ äºŒå‰æ ‘çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬å°±åªéœ€è¦ ***O(1)* çš„æ—¶é—´å¯¹æ ¹èŠ‚ç‚¹è¿›è¡Œå®šä½äº†**ã€‚


```python
preorder = [3,9,20,15,7]
inorder = [9,3,15,20,7]
```


```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        if not preorder or not inorder:
            return None
        root_val = preorder[0]
        ind = inorder.index(root_val)
        print(ind)
        root = TreeNode(root_val)
        root.left = self.buildTree(preorder[1:ind+1], inorder[:ind])
        root.right = self.buildTree(preorder[ind+1:], inorder[ind+1:])
        return root
```

å®˜è§£ï¼ˆä½¿ç”¨äº†setï¼‰ï¼š

```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        def recur(root, left, right):
            if left > right: return                               # é€’å½’ç»ˆæ­¢
            node = TreeNode(preorder[root])                       # å»ºç«‹æ ¹èŠ‚ç‚¹
            i = dic[preorder[root]]                               # åˆ’åˆ†æ ¹èŠ‚ç‚¹ã€å·¦å­æ ‘ã€å³å­æ ‘
            node.left = recur(root + 1, left, i - 1)              # å¼€å¯å·¦å­æ ‘é€’å½’
            node.right = recur(i - left + root + 1, i + 1, right) # å¼€å¯å³å­æ ‘é€’å½’
            return node                                           # å›žæº¯è¿”å›žæ ¹èŠ‚ç‚¹

        dic, preorder = {}, preorder
        for i in range(len(inorder)):
            dic[inorder[i]] = i
        return recur(0, 0, len(inorder) - 1)
```

### ðŸš©(30m)[å‰‘æŒ‡ Offer 26. æ ‘çš„å­ç»“æž„](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

```python
class Solution:
    def isSubStructure(self, A: TreeNode, B: TreeNode) -> bool:
        def compare(nodeA,nodeB):
            # B è¢«éåŽ†ç©ºï¼Œè¿”å›žTrue
            if not nodeB:
                return True
            # é˜²æ­¢ A.val æŠ¥é”™, å€¼ä¸åŒï¼Œè¿”å›žFalse
            if not nodeA or nodeA.val != nodeB.val:
                return False
            # ç»§ç»­é€’å½’éåŽ†åŽç»­å­æ ‘æ˜¯å¦ç›¸åŒ
            return compare(nodeA.left, nodeB.left) or compare(nodeA.right, nodeB.right)
        if not A or not B:
            return False
        # é€šè¿‡é€’å½’å°†Açš„ç»“ç‚¹åˆ†åˆ«å’ŒBè¿›è¡Œæ¯”è¾ƒï¼Œè¿™é‡Œçš„ or å…·æœ‰é˜»æ–­æ•ˆåº”ï¼ŒåŽé¢çš„é€’å½’è°ƒç”¨ä¸æ‰§è¡Œï¼Œç›´æŽ¥å‘ä¸Šè¿”å›ž
        return compare(A,B) or self.isSubStructure(A.left,B) or self.isSubStructure(A.right, B) 
```

#### 2ï¸âƒ£ æ³¨æ„ï¼š

**è¿™é‡Œçš„ or å…·æœ‰é˜»æ–­æ•ˆåº”ï¼ŒåŽé¢çš„é€’å½’è°ƒç”¨ä¸æ‰§è¡Œï¼Œç›´æŽ¥å‘ä¸Šè¿”å›ž**

## é“¾è¡¨

###  ðŸš©206. åè½¬é“¾è¡¨

[åŠ¨ç”»æ¼”ç¤º+å¤šç§è§£æ³• 206. åè½¬é“¾è¡¨](https://leetcode-cn.com/problems/reverse-linked-list/solution/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/)



åè½¬ä¸€ä¸ªå•é“¾è¡¨ã€‚

```
ç¤ºä¾‹:

è¾“å…¥: 1->2->3->4->5->NULL
è¾“å‡º: 5->4->3->2->1->NULL
```

è¿›é˜¶:
ä½ å¯ä»¥è¿­ä»£æˆ–é€’å½’åœ°åè½¬é“¾è¡¨ã€‚ä½ èƒ½å¦ç”¨ä¸¤ç§æ–¹æ³•è§£å†³è¿™é“é¢˜ï¼Ÿ

```python
class Solution(object):
	def reverseList(self, head):
		"""
		:type head: ListNode
		:rtype: ListNode
		"""
		# ç”³è¯·ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œpreå’Œ curï¼ŒpreæŒ‡å‘None
		pre = None
		cur = head
		# éåŽ†é“¾è¡¨ï¼Œwhileå¾ªçŽ¯é‡Œé¢çš„å†…å®¹å…¶å®žå¯ä»¥å†™æˆä¸€è¡Œ
		# è¿™é‡Œåªåšæ¼”ç¤ºï¼Œå°±ä¸æžé‚£ä¹ˆéªšæ°”çš„å†™æ³•äº†
		while cur:
			# è®°å½•å½“å‰èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
			tmp = cur.next
			# ç„¶åŽå°†å½“å‰èŠ‚ç‚¹æŒ‡å‘pre
			cur.next = pre
			# preå’ŒcurèŠ‚ç‚¹éƒ½å‰è¿›ä¸€ä½
			pre = cur
			cur = tmp
		return pre	

```

#### ðŸš©ï¼ˆ20mï¼‰ é€’å½’è§£æ³• + è¿­ä»£

```python
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        # digui
        if not head or not head.next: # åªæœ‰å½“å‰èŠ‚ç‚¹
            return head
        last = self.reverseList(head.next) # æ‹†è§£ä¸ºå­é—®é¢˜
        head.next.next = head
        head.next = None
        return last
```



```python
        # è¿­ä»£
        if not head: # åªæœ‰å½“å‰èŠ‚ç‚¹
            return head  
        pre, cur = None, head
        while cur:
            tmp = cur.next  
            cur.next = pre
            pre, cur = cur, tmp
        return pre
```

## dfs

### âœ…  [46. å…¨æŽ’åˆ—](https://leetcode-cn.com/problems/permutations/)

ç»™å®šä¸€ä¸ª **æ²¡æœ‰é‡å¤** æ•°å­—çš„åºåˆ—ï¼Œè¿”å›žå…¶æ‰€æœ‰å¯èƒ½çš„å…¨æŽ’åˆ—ã€‚

**ç¤ºä¾‹:**

```
è¾“å…¥: [1,2,3]è¾“å‡º:[  [1,2,3],  [1,3,2],  [2,1,3],  [2,3,1],  [3,1,2],  [3,2,1]] 
```

#### âœ…ï¼ˆ5mï¼‰

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        def helper(path, nums):
            if len(path) == len(nums):
                res.append(path)
            for i in nums:
                if i not in path:
                    helper(path+[i], nums)
        
        res = []
        path = []   
        helper(path, nums)     
        return res
```

æ€»ç»“ï¼š

1. åœ¨basecaseé‡Œï¼Œæ³¨æ„ï¼Œæ»¡è¶³æ¡ä»¶äº†å°±è¦returnå‡ºåŽ»
2. ç»„åˆé—®é¢˜éœ€è¦åšé€‰æ‹©å‰æ·»åŠ åˆ¤æ–­ï¼Œ**è·³è¿‡ä¸æ»¡è¶³æ¡ä»¶çš„é€‰æ‹©**

### âœ…(20m)[79. å•è¯æœç´¢](https://leetcode-cn.com/problems/word-search/)

ç»™å®šä¸€ä¸ªäºŒç»´ç½‘æ ¼å’Œä¸€ä¸ªå•è¯ï¼Œæ‰¾å‡ºè¯¥å•è¯æ˜¯å¦å­˜åœ¨äºŽç½‘æ ¼ä¸­ã€‚

å•è¯å¿…é¡»æŒ‰ç…§å­—æ¯é¡ºåºï¼Œé€šè¿‡ç›¸é‚»çš„å•å…ƒæ ¼å†…çš„å­—æ¯æž„æˆï¼Œå…¶ä¸­â€œç›¸é‚»â€å•å…ƒæ ¼æ˜¯é‚£äº›æ°´å¹³ç›¸é‚»æˆ–åž‚ç›´ç›¸é‚»çš„å•å…ƒæ ¼ã€‚åŒä¸€ä¸ªå•å…ƒæ ¼å†…çš„å­—æ¯ä¸å…è®¸è¢«é‡å¤ä½¿ç”¨ã€‚

```
# ç¤ºä¾‹board =[  ['A','B','C','E'],  ['S','F','C','S'],  ['A','D','E','E']]ç»™å®š word = "ABCCED", è¿”å›ž trueç»™å®š word = "SEE", è¿”å›ž trueç»™å®š word = "ABCB", è¿”å›ž false
```

#### âœ…ï¼ˆ20mï¼‰

```python
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]   
        def check(i: int, j: int, k: int) -> bool:
            if board[i][j] != word[k]:
                return False
            if k == len(word) - 1:
                return True

            visited.add((i, j))
            result = False
            for di, dj in directions:
                newi, newj = i + di, j + dj
                if 0 <= newi < len(board) and 0 <= newj < len(board[0]):
                    if (newi, newj) not in visited:
                        if check(newi, newj, k + 1):
                            result = True
                            break

            visited.remove((i, j))
            return result

        h, w = len(board), len(board[0])
        visited = set()
        for i in range(h):
            for j in range(w):
                if check(i, j, 0):
                    return True

        return False
```

### ðŸš©12. çŸ©é˜µä¸­çš„è·¯å¾„

è¯·è®¾è®¡ä¸€ä¸ªå‡½æ•°ï¼Œç”¨æ¥åˆ¤æ–­åœ¨ä¸€ä¸ªçŸ©é˜µä¸­æ˜¯å¦å­˜åœ¨ä¸€æ¡åŒ…å«æŸå­—ç¬¦ä¸²æ‰€æœ‰å­—ç¬¦çš„è·¯å¾„ã€‚è·¯å¾„å¯ä»¥ä»ŽçŸ©é˜µä¸­çš„ä»»æ„ä¸€æ ¼å¼€å§‹ï¼Œæ¯ä¸€æ­¥å¯ä»¥åœ¨çŸ©é˜µä¸­å‘å·¦ã€å³ã€ä¸Šã€ä¸‹ç§»åŠ¨ä¸€æ ¼ã€‚å¦‚æžœä¸€æ¡è·¯å¾„ç»è¿‡äº†çŸ©é˜µçš„æŸä¸€æ ¼ï¼Œé‚£ä¹ˆè¯¥è·¯å¾„ä¸èƒ½å†æ¬¡è¿›å…¥è¯¥æ ¼å­ã€‚ä¾‹å¦‚ï¼Œåœ¨ä¸‹é¢çš„3Ã—4çš„çŸ©é˜µä¸­åŒ…å«ä¸€æ¡å­—ç¬¦ä¸²â€œbfceâ€çš„è·¯å¾„(è·¯å¾„ä¸­çš„å­—æ¯ç”¨åŠ ç²—æ ‡å‡º)ã€‚

[["a","b","c","e"],
["s","f","c","s"],
["a","d","e","e"]]

ä½†çŸ©é˜µä¸­ä¸åŒ…å«å­—ç¬¦ä¸²â€œabfbâ€çš„è·¯å¾„ï¼Œå› ä¸ºå­—ç¬¦ä¸²çš„ç¬¬ä¸€ä¸ªå­—ç¬¦bå æ®äº†çŸ©é˜µä¸­çš„ç¬¬ä¸€è¡Œç¬¬äºŒä¸ªæ ¼å­ä¹‹åŽï¼Œè·¯å¾„ä¸èƒ½å†æ¬¡è¿›å…¥è¿™ä¸ªæ ¼å­ã€‚


```
ç¤ºä¾‹ 1ï¼šè¾“å…¥ï¼šboard = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"è¾“å‡ºï¼štrueç¤ºä¾‹ 2ï¼šè¾“å…¥ï¼šboard = [["a","b"],["c","d"]], word = "abcd"è¾“å‡ºï¼šfalse
```


```python
board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]]word = "ABCCED"
```

#### 2ï¸âƒ£

```python
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        def dfs(i, j, k):
            if not 0 <= i < len(board) or not 0 <= j < len(board[0]) or board[i][j] != word[k] or (i,j) in visited: return False
            if k == len(word) - 1: return True
            visited.add((i,j))
            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)
            visited.remove((i,j))
            return res

        for i in range(len(board)):
            for j in range(len(board[0])):
                visited = set()
                if dfs(i, j, 0): return True
        return False
```

