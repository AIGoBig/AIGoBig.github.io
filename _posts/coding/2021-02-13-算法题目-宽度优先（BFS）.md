# leetcodeé¢˜ç›®æŒ‰ç±»å‹

## å®½åº¦ä¼˜å…ˆBFS

### BFS ç®—æ³•æ¡†æ¶

```python
def BFS(start, target):
  q = []
  visited = {}
  
  q.append(start)  # é˜Ÿåˆ—queue
  visited.add(start)  # åƒäºŒå‰æ ‘ä¸€æ ·çš„ç»“æ„ï¼Œæ²¡æœ‰å­èŠ‚ç‚¹åˆ°çˆ¶èŠ‚ç‚¹çš„æŒ‡é’ˆï¼Œä¸ä¼šèµ°å›å¤´è·¯ï¼Œå°±ä¸éœ€è¦visited
  step = 0
  
  while q:
    for _ in range(len(queue)):
      cur = q.pop(0)  # Notice is 0
      if cur is target:
        return step
      for x in cur.adj():  # å°† cur çš„ç›¸é‚»èŠ‚ç‚¹åŠ â¼Šé˜Ÿåˆ—
        if x not in visited:
          q.append(x)
          visited.add(x)
    step += 1  # éå†å®Œä¸€å±‚åstep++
      
```



```C++
// è®¡ç®—ä»èµ·ç‚¹ start åˆ°ç»ˆç‚¹ target çš„æœ€è¿‘è·ç¦»
int BFS(Node start, Node target) {
    Queue<Node> q;  // æ ¸â¼¼æ•°æ®ç»“æ„
    Set<Node> visited;  // é¿å…â¾›å›å¤´è·¯

    q.offer(start);  // å°†èµ·ç‚¹åŠ â¼Šé˜Ÿåˆ—
    visited.add(start);
    int step = 0;  // è®°å½•æ‰©æ•£çš„æ­¥æ•°

    while (q not empty) {
        int sz = q.size();
        /* å°†å½“å‰é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹å‘å››å‘¨æ‰©æ•£ */
        for (int i = 0; i < sz; i++) {
            Node cur = q.poll();
            /* åˆ’é‡ç‚¹ï¼šè¿™â¾¥åˆ¤æ–­æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹ */
            if (cur is target) 
                return step; 
            /* å°† cur çš„ç›¸é‚»èŠ‚ç‚¹åŠ â¼Šé˜Ÿåˆ— */ 
            for (Node x : cur.adj()) 
                if (x not in visited) { 
                    q.offer(x); 
                    visited.add(x); 
                } 
        }
        /* åˆ’é‡ç‚¹ï¼šæ›´æ–°æ­¥æ•°åœ¨è¿™â¾¥ */ 
        step++; 
    } 
}
```



### âœ… (30m)[111. äºŒå‰æ ‘çš„æœ€å°æ·±åº¦](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ‰¾å‡ºå…¶æœ€å°æ·±åº¦ã€‚

æœ€å°æ·±åº¦æ˜¯ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿‘å¶å­èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„ä¸Šçš„**èŠ‚ç‚¹æ•°é‡**ã€‚

**è¯´æ˜ï¼š**å¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚

 

**ç¤ºä¾‹ 1ï¼š**

<img src="/img/in-post/20_07/ex_depth.jpg" alt="img" style="zoom:50%;" />

```
è¾“å…¥ï¼šroot = [3,9,20,null,null,15,7]
è¾“å‡ºï¼š2
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼šroot = [2,null,3,null,4,null,5,null,6]
è¾“å‡ºï¼š5
```

```python
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if not root: return 0
        deque = [root]  
        step = 1
        while deque:
            for i in range(len(deque)):  # é‡è¦ï¼Œè¦å…ˆæŠŠdequeé‡Œçš„æ‰€æœ‰å¹¶åˆ—èŠ‚ç‚¹éå†å®Œåï¼Œåœ¨éå†å­èŠ‚ç‚¹ï¼Œå¹¶æ‰¾æ–°èŠ‚ç‚¹ï¼Œstep+1
                node = deque.pop(0)
                if not node.left and not node.right:
                    return step
                if node.left: deque.append(node.left) # æ³¨æ„å…ˆåˆ¤æ–­å·¦å³å­èŠ‚ç‚¹æ˜¯å¦æ˜¯None
                if node.right: deque.append(node.right)
            step += 1
        return 0
```

æ€»ç»“ï¼š

1. `for i in range(len(deque)): `  å¾ˆé‡è¦ï¼Œè¦å…ˆæŠŠdequeé‡Œçš„æ‰€æœ‰å¹¶åˆ—èŠ‚ç‚¹éå†å®Œåï¼Œåœ¨éå†å­èŠ‚ç‚¹ï¼Œå¹¶æ‰¾æ–°èŠ‚ç‚¹ï¼Œstep+1
2. `if node.left: deque.append(node.left)` æ³¨æ„å…ˆåˆ¤æ–­å·¦å³å­èŠ‚ç‚¹æ˜¯å¦æ˜¯None

#### 2ï¸âƒ£

### âœ…(2.0h) [752. æ‰“å¼€è½¬ç›˜é”](https://leetcode-cn.com/problems/open-the-lock/)

éš¾åº¦ä¸­ç­‰211

ä½ æœ‰ä¸€ä¸ªå¸¦æœ‰å››ä¸ªåœ†å½¢æ‹¨è½®çš„è½¬ç›˜é”ã€‚æ¯ä¸ªæ‹¨è½®éƒ½æœ‰10ä¸ªæ•°å­—ï¼š `'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'` ã€‚æ¯ä¸ªæ‹¨è½®å¯ä»¥è‡ªç”±æ—‹è½¬ï¼šä¾‹å¦‚æŠŠ `'9'` å˜ä¸º `'0'`ï¼Œ`'0'` å˜ä¸º `'9'` ã€‚æ¯æ¬¡æ—‹è½¬éƒ½åªèƒ½æ—‹è½¬ä¸€ä¸ªæ‹¨è½®çš„ä¸€ä½æ•°å­—ã€‚

é”çš„åˆå§‹æ•°å­—ä¸º `'0000'` ï¼Œä¸€ä¸ªä»£è¡¨å››ä¸ªæ‹¨è½®çš„æ•°å­—çš„å­—ç¬¦ä¸²ã€‚

åˆ—è¡¨ `deadends` åŒ…å«äº†ä¸€ç»„æ­»äº¡æ•°å­—ï¼Œä¸€æ—¦æ‹¨è½®çš„æ•°å­—å’Œåˆ—è¡¨é‡Œçš„ä»»ä½•ä¸€ä¸ªå…ƒç´ ç›¸åŒï¼Œè¿™ä¸ªé”å°†ä¼šè¢«æ°¸ä¹…é”å®šï¼Œæ— æ³•å†è¢«æ—‹è½¬ã€‚

å­—ç¬¦ä¸² `target` ä»£è¡¨å¯ä»¥è§£é”çš„æ•°å­—ï¼Œä½ éœ€è¦ç»™å‡ºæœ€å°çš„æ—‹è½¬æ¬¡æ•°ï¼Œå¦‚æœæ— è®ºå¦‚ä½•ä¸èƒ½è§£é”ï¼Œè¿”å› -1ã€‚

 

**ç¤ºä¾‹ 1:**

```
è¾“å…¥ï¼šdeadends = ["0201","0101","0102","1212","2002"], target = "0202"
è¾“å‡ºï¼š6
è§£é‡Šï¼š
å¯èƒ½çš„ç§»åŠ¨åºåˆ—ä¸º "0000" -> "1000" -> "1100" -> "1200" -> "1201" -> "1202" -> "0202"ã€‚
æ³¨æ„ "0000" -> "0001" -> "0002" -> "0102" -> "0202" è¿™æ ·çš„åºåˆ—æ˜¯ä¸èƒ½è§£é”çš„ï¼Œ
å› ä¸ºå½“æ‹¨åŠ¨åˆ° "0102" æ—¶è¿™ä¸ªé”å°±ä¼šè¢«é”å®šã€‚
```

**ç¤ºä¾‹ 2:**

```
è¾“å…¥: deadends = ["8888"], target = "0009"
è¾“å‡ºï¼š1
è§£é‡Šï¼š
æŠŠæœ€åä¸€ä½åå‘æ—‹è½¬ä¸€æ¬¡å³å¯ "0000" -> "0009"ã€‚
```

**ç¤ºä¾‹ 3:**

```
è¾“å…¥: deadends = ["8887","8889","8878","8898","8788","8988","7888","9888"], target = "8888"
è¾“å‡ºï¼š-1
è§£é‡Šï¼š
æ— æ³•æ—‹è½¬åˆ°ç›®æ ‡æ•°å­—ä¸”ä¸è¢«é”å®šã€‚
```

**ç¤ºä¾‹ 4:**

```
è¾“å…¥: deadends = ["0000"], target = "8888"
è¾“å‡ºï¼š-1
```

**æç¤ºï¼š**

1. æ­»äº¡åˆ—è¡¨ `deadends` çš„é•¿åº¦èŒƒå›´ä¸º `[1, 500]`ã€‚
2. ç›®æ ‡æ•°å­— `target` ä¸ä¼šåœ¨ `deadends` ä¹‹ä¸­ã€‚
3. æ¯ä¸ª `deadends` å’Œ `target` ä¸­çš„å­—ç¬¦ä¸²çš„æ•°å­—ä¼šåœ¨ 10,000 ä¸ªå¯èƒ½çš„æƒ…å†µ `'0000'` åˆ° `'9999'` ä¸­äº§ç”Ÿã€‚

```python
class Solution:
    def openLock(self, deadends: List[str], target: str) -> int:
        if "0000" in deadends: return -1
        deque = ["0000"]  
        step = 0
        visited = set(["0000"]+ deadends)  # listå†…ç±»å‹å˜åŒ–æ–¹å¼

        # add
        def num_add(arr, idx):
            if arr[idx] == '9':
                newnum = '0'
            else: 
                newnum = str(int(arr[idx])+1)
            return arr[:idx] + newnum + arr[idx+1:]
        def num_red(arr, idx):
            if arr[idx] == '0':
                newnum = '9'
            else:
                newnum = str(int(arr[idx])-1)
            return arr[:idx] + newnum + arr[idx+1:]

        while deque:
            for num in range(len(deque)):  # é‡è¦ï¼Œè¦å…ˆæŠŠdequeé‡Œçš„æ‰€æœ‰å¹¶åˆ—èŠ‚ç‚¹éå†å®Œåï¼Œåœ¨éå†å­èŠ‚ç‚¹ï¼Œå¹¶æ‰¾æ–°èŠ‚ç‚¹ï¼Œstep+1
                node = deque.pop(0)
                visited.add(node)
                if node == target:
                    return step
                next_node = []
                for j in range(4):
                    next_node_add = num_add(node,j)
                    next_node_red = num_red(node,j)
                    next_node.append(next_node_add)
                    next_node.append(next_node_red)

                next_node = [i for i in next_node if i not in visited]  # å®ç°æ•°ç»„è¿‡æ»¤
                deque.extend(next_node) 
                visited.update(next_node)  # set ä¼ å…¥å¯è¿­ä»£å…ƒç´ çš„æ–¹å¼
            # print("visited",visited)
            # print("deque",deque)
            step += 1
        return -1

```

```python
# å®˜è§£
class Solution(object):
    def openLock(self, deadends, target):
        def neighbors(node):
            for i in xrange(4):
                x = int(node[i])
                for d in (-1, 1):
                    y = (x + d) % 10
                    yield node[:i] + str(y) + node[i+1:]

        dead = set(deadends)
        queue = collections.deque([('0000', 0)])
        seen = {'0000'}
        while queue:
            node, depth = queue.popleft()
            if node == target: return depth
            if node in dead: continue
            for nei in neighbors(node):
                if nei not in seen:
                    seen.add(nei)
                    queue.append((nei, depth+1))
        return -1

```

æ€»ç»“ï¼š

1. å…³äºé˜²æ­¢è¿›ä½çš„å†™æ³•ï¼š

       def neighbors(node):
           for i in xrange(4):
               x = int(node[i])
               for d in (-1, 1):
                   y = (x + d) % 10
                   yield node[:i] + str(y) + node[i+1:]



### ğŸš©(90m)ï¼ˆå›°éš¾ï¼‰ [773. æ»‘åŠ¨è°œé¢˜](https://leetcode-cn.com/problems/sliding-puzzle/)

åœ¨ä¸€ä¸ª 2 x 3 çš„æ¿ä¸Šï¼ˆ`board`ï¼‰æœ‰ 5 å—ç –ç“¦ï¼Œç”¨æ•°å­— `1~5` æ¥è¡¨ç¤º, ä»¥åŠä¸€å—ç©ºç¼ºç”¨ `0` æ¥è¡¨ç¤º.

ä¸€æ¬¡ç§»åŠ¨å®šä¹‰ä¸ºé€‰æ‹© `0` ä¸ä¸€ä¸ªç›¸é‚»çš„æ•°å­—ï¼ˆä¸Šä¸‹å·¦å³ï¼‰è¿›è¡Œäº¤æ¢.

æœ€ç»ˆå½“æ¿ `board` çš„ç»“æœæ˜¯ `[[1,2,3],[4,5,0]]` è°œæ¿è¢«è§£å¼€ã€‚

ç»™å‡ºä¸€ä¸ªè°œæ¿çš„åˆå§‹çŠ¶æ€ï¼Œè¿”å›æœ€å°‘å¯ä»¥é€šè¿‡å¤šå°‘æ¬¡ç§»åŠ¨è§£å¼€è°œæ¿ï¼Œå¦‚æœä¸èƒ½è§£å¼€è°œæ¿ï¼Œåˆ™è¿”å› -1 ã€‚

**ç¤ºä¾‹ï¼š**

```
è¾“å…¥ï¼šboard = [[1,2,3],[4,0,5]]
è¾“å‡ºï¼š1
è§£é‡Šï¼šäº¤æ¢ 0 å’Œ 5 ï¼Œ1 æ­¥å®Œæˆ
è¾“å…¥ï¼šboard = [[1,2,3],[5,4,0]]
è¾“å‡ºï¼š-1
è§£é‡Šï¼šæ²¡æœ‰åŠæ³•å®Œæˆè°œæ¿
è¾“å…¥ï¼šboard = [[4,1,2],[5,0,3]]
è¾“å‡ºï¼š5
è§£é‡Šï¼š
æœ€å°‘å®Œæˆè°œæ¿çš„æœ€å°‘ç§»åŠ¨æ¬¡æ•°æ˜¯ 5 ï¼Œ
ä¸€ç§ç§»åŠ¨è·¯å¾„:
å°šæœªç§»åŠ¨: [[4,1,2],[5,0,3]]
ç§»åŠ¨ 1 æ¬¡: [[4,1,2],[0,5,3]]
ç§»åŠ¨ 2 æ¬¡: [[0,1,2],[4,5,3]]
ç§»åŠ¨ 3 æ¬¡: [[1,0,2],[4,5,3]]
ç§»åŠ¨ 4 æ¬¡: [[1,2,0],[4,5,3]]
ç§»åŠ¨ 5 æ¬¡: [[1,2,3],[4,5,0]]
è¾“å…¥ï¼šboard = [[3,2,4],[1,5,0]]
è¾“å‡ºï¼š14
```

### âœ…(80m)ï¼ˆå›°éš¾ï¼‰[127. å•è¯æ¥é¾™](https://leetcode-cn.com/problems/word-ladder/)

éš¾åº¦å›°éš¾776

å­—å…¸ `wordList` ä¸­ä»å•è¯ `beginWord` å’Œ `endWord` çš„ **è½¬æ¢åºåˆ—** æ˜¯ä¸€ä¸ªæŒ‰ä¸‹è¿°è§„æ ¼å½¢æˆçš„åºåˆ—ï¼š

- åºåˆ—ä¸­ç¬¬ä¸€ä¸ªå•è¯æ˜¯ `beginWord` ã€‚
- åºåˆ—ä¸­æœ€åä¸€ä¸ªå•è¯æ˜¯ `endWord` ã€‚
- æ¯æ¬¡è½¬æ¢åªèƒ½æ”¹å˜ä¸€ä¸ªå­—æ¯ã€‚
- è½¬æ¢è¿‡ç¨‹ä¸­çš„ä¸­é—´å•è¯å¿…é¡»æ˜¯å­—å…¸ `wordList` ä¸­çš„å•è¯ã€‚

ç»™ä½ ä¸¤ä¸ªå•è¯ `beginWord` å’Œ `endWord` å’Œä¸€ä¸ªå­—å…¸ `wordList` ï¼Œæ‰¾åˆ°ä» `beginWord` åˆ° `endWord` çš„ **æœ€çŸ­è½¬æ¢åºåˆ—** ä¸­çš„ **å•è¯æ•°ç›®** ã€‚å¦‚æœä¸å­˜åœ¨è¿™æ ·çš„è½¬æ¢åºåˆ—ï¼Œè¿”å› 0ã€‚

**ç¤ºä¾‹ 1ï¼š**

```
è¾“å…¥ï¼šbeginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
è¾“å‡ºï¼š5
è§£é‡Šï¼šä¸€ä¸ªæœ€çŸ­è½¬æ¢åºåˆ—æ˜¯ "hit" -> "hot" -> "dot" -> "dog" -> "cog", è¿”å›å®ƒçš„é•¿åº¦ 5ã€‚
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼šbeginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
è¾“å‡ºï¼š0
è§£é‡Šï¼šendWord "cog" ä¸åœ¨å­—å…¸ä¸­ï¼Œæ‰€ä»¥æ— æ³•è¿›è¡Œè½¬æ¢ã€‚
```



æˆ‘ä»¬å¯ä»¥æŠŠæ¯ä¸ªå•è¯éƒ½æŠ½è±¡ä¸ºä¸€ä¸ªç‚¹ï¼Œå¦‚æœ**ä¸¤ä¸ªå•è¯å¯ä»¥åªæ”¹å˜ä¸€ä¸ªå­—æ¯è¿›è¡Œè½¬æ¢ï¼Œé‚£ä¹ˆè¯´æ˜ä»–ä»¬ä¹‹é—´æœ‰ä¸€æ¡åŒå‘è¾¹ã€‚**å› æ­¤æˆ‘ä»¬åªéœ€è¦æŠŠæ»¡è¶³è½¬æ¢æ¡ä»¶çš„ç‚¹ç›¸è¿ï¼Œå°±å½¢æˆäº†ä¸€å¼ å›¾ã€‚

**åŸºäºè¯¥å›¾ï¼Œ**æˆ‘ä»¬ä»¥ beginWord ä¸ºå›¾çš„èµ·ç‚¹ï¼Œä»¥ endWord ä¸ºç»ˆç‚¹è¿›è¡Œå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼Œå¯»æ‰¾ beginWord åˆ° endWord çš„æœ€çŸ­è·¯å¾„ã€‚



æ­¥éª¤ï¼š

1. å…ˆå»ºå›¾
2. å†bfs

```python
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        G = dict()
        allword = wordList
        allwordset = set(allword)
        for word in allword+[beginWord]:
            G[word] = []
            for j in range(len(word)):
                for k in range(26):
                    tmp = list(word)
                    tmp[j] = chr(ord('a') + k)
                    tmp = ''.join(tmp)
                    if tmp in allwordset:
                        G[word].append(tmp)
        print(G)

        q = [beginWord]
        visited = {word:False for word in allword}
        visited[beginWord] = True
        step = 1

        while q:
            for _ in range(len(q)):
                cur = q.pop(0)
                print(cur)
                if cur == endWord:
                    return step
                if cur in G.keys():
                    for word in G[cur]:
                        if not visited[word]:
                            q.append(word)
                            visited[word] = True
                # print(q)
            step += 1
        return 0
```

æ³¨æ„ï¼š

1. æ³¨æ„æ„å»ºå›¾çš„æ–¹å¼ï¼Œæ¯ä¸€ä¸ªå•è¯éå†ç„¶åä»setä¸­æ‰¾çš„å¤æ‚åº¦æ˜¯O(26n)ï¼Œå¦åˆ™æ˜¯O(nn)ï¼Œä¼šè¶…æ—¶

### ğŸš©ï¼ˆå›°éš¾ï¼‰[126. å•è¯æ¥é¾™ II](https://leetcode-cn.com/problems/word-ladder-ii/)

