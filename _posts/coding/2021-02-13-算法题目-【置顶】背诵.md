# ç»å…¸é¢˜ç›®èƒŒè¯µ

## é“¾è¡¨

###  ðŸš©206. åè½¬é“¾è¡¨

[åŠ¨ç”»æ¼”ç¤º+å¤šç§è§£æ³• 206. åè½¬é“¾è¡¨](https://leetcode-cn.com/problems/reverse-linked-list/solution/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/)



åè½¬ä¸€ä¸ªå•é“¾è¡¨ã€‚

```
ç¤ºä¾‹:

è¾“å…¥: 1->2->3->4->5->NULL
è¾“å‡º: 5->4->3->2->1->NULL
```

è¿›é˜¶:
ä½ å¯ä»¥è¿­ä»£æˆ–é€’å½’åœ°åè½¬é“¾è¡¨ã€‚ä½ èƒ½å¦ç”¨ä¸¤ç§æ–¹æ³•è§£å†³è¿™é“é¢˜ï¼Ÿ

```python
class Solution(object):
	def reverseList(self, head):
		"""
		:type head: ListNode
		:rtype: ListNode
		"""
		# ç”³è¯·ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œpreå’Œ curï¼ŒpreæŒ‡å‘None
		pre = None
		cur = head
		# éåŽ†é“¾è¡¨ï¼Œwhileå¾ªçŽ¯é‡Œé¢çš„å†…å®¹å…¶å®žå¯ä»¥å†™æˆä¸€è¡Œ
		# è¿™é‡Œåªåšæ¼”ç¤ºï¼Œå°±ä¸æžé‚£ä¹ˆéªšæ°”çš„å†™æ³•äº†
		while cur:
			# è®°å½•å½“å‰èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
			tmp = cur.next
			# ç„¶åŽå°†å½“å‰èŠ‚ç‚¹æŒ‡å‘pre
			cur.next = pre
			# preå’ŒcurèŠ‚ç‚¹éƒ½å‰è¿›ä¸€ä½
			pre = cur
			cur = tmp
		return pre	

```

#### ðŸš©ï¼ˆ20mï¼‰ é€’å½’è§£æ³• + è¿­ä»£

```python
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        # digui
        if not head or not head.next: # åªæœ‰å½“å‰èŠ‚ç‚¹
            return head
        last = self.reverseList(head.next) # æ‹†è§£ä¸ºå­é—®é¢˜
        head.next.next = head
        head.next = None
        return last
```



```python
        # è¿­ä»£
        if not head: # åªæœ‰å½“å‰èŠ‚ç‚¹
            return head  
        pre, cur = None, head
        while cur:
            tmp = cur.next  
            cur.next = pre
            pre, cur = cur, tmp
        return pre
```

## dfs

### âœ…  [46. å…¨æŽ’åˆ—](https://leetcode-cn.com/problems/permutations/)

ç»™å®šä¸€ä¸ª **æ²¡æœ‰é‡å¤** æ•°å­—çš„åºåˆ—ï¼Œè¿”å›žå…¶æ‰€æœ‰å¯èƒ½çš„å…¨æŽ’åˆ—ã€‚

**ç¤ºä¾‹:**

```
è¾“å…¥: [1,2,3]è¾“å‡º:[  [1,2,3],  [1,3,2],  [2,1,3],  [2,3,1],  [3,1,2],  [3,2,1]] 
```

#### âœ…ï¼ˆ5mï¼‰

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        def helper(path, nums):
            if len(path) == len(nums):
                res.append(path)
            for i in nums:
                if i not in path:
                    helper(path+[i], nums)
        
        res = []
        path = []   
        helper(path, nums)     
        return res
```

æ€»ç»“ï¼š

1. åœ¨basecaseé‡Œï¼Œæ³¨æ„ï¼Œæ»¡è¶³æ¡ä»¶äº†å°±è¦returnå‡ºåŽ»
2. ç»„åˆé—®é¢˜éœ€è¦åšé€‰æ‹©å‰æ·»åŠ åˆ¤æ–­ï¼Œ**è·³è¿‡ä¸æ»¡è¶³æ¡ä»¶çš„é€‰æ‹©**





### âœ…(20m)[79. å•è¯æœç´¢](https://leetcode-cn.com/problems/word-search/)

ç»™å®šä¸€ä¸ªäºŒç»´ç½‘æ ¼å’Œä¸€ä¸ªå•è¯ï¼Œæ‰¾å‡ºè¯¥å•è¯æ˜¯å¦å­˜åœ¨äºŽç½‘æ ¼ä¸­ã€‚

å•è¯å¿…é¡»æŒ‰ç…§å­—æ¯é¡ºåºï¼Œé€šè¿‡ç›¸é‚»çš„å•å…ƒæ ¼å†…çš„å­—æ¯æž„æˆï¼Œå…¶ä¸­â€œç›¸é‚»â€å•å…ƒæ ¼æ˜¯é‚£äº›æ°´å¹³ç›¸é‚»æˆ–åž‚ç›´ç›¸é‚»çš„å•å…ƒæ ¼ã€‚åŒä¸€ä¸ªå•å…ƒæ ¼å†…çš„å­—æ¯ä¸å…è®¸è¢«é‡å¤ä½¿ç”¨ã€‚

```
# ç¤ºä¾‹board =[  ['A','B','C','E'],  ['S','F','C','S'],  ['A','D','E','E']]ç»™å®š word = "ABCCED", è¿”å›ž trueç»™å®š word = "SEE", è¿”å›ž trueç»™å®š word = "ABCB", è¿”å›ž false
```

#### âœ…ï¼ˆ20mï¼‰

```python
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]   
        def check(i: int, j: int, k: int) -> bool:
            if board[i][j] != word[k]:
                return False
            if k == len(word) - 1:
                return True

            visited.add((i, j))
            result = False
            for di, dj in directions:
                newi, newj = i + di, j + dj
                if 0 <= newi < len(board) and 0 <= newj < len(board[0]):
                    if (newi, newj) not in visited:
                        if check(newi, newj, k + 1):
                            result = True
                            break

            visited.remove((i, j))
            return result

        h, w = len(board), len(board[0])
        visited = set()
        for i in range(h):
            for j in range(w):
                if check(i, j, 0):
                    return True

        return False
```

