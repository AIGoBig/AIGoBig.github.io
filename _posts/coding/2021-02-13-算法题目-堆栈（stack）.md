# leetcodeé¢˜ç›®æŒ‰ç±»å‹

## å †æ ˆstack

### âœ…(20m) 20. æœ‰æ•ˆçš„æ‹¬å·

**æ³¨æ„: range(x)å–ä¸åˆ°x**

ç»™å®šä¸€ä¸ªåªåŒ…æ‹¬ '('ï¼Œ')'ï¼Œ'{'ï¼Œ'}'ï¼Œ'['ï¼Œ']'Â çš„å­—ç¬¦ä¸²ï¼Œåˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦æœ‰æ•ˆã€‚

æœ‰æ•ˆå­—ç¬¦ä¸²éœ€æ»¡è¶³ï¼š

å·¦æ‹¬å·å¿…é¡»ç”¨ç›¸åŒç±»å‹çš„å³æ‹¬å·é—­åˆã€‚
å·¦æ‹¬å·å¿…é¡»ä»¥æ­£ç¡®çš„é¡ºåºé—­åˆã€‚
æ³¨æ„ç©ºå­—ç¬¦ä¸²å¯è¢«è®¤ä¸ºæ˜¯æœ‰æ•ˆå­—ç¬¦ä¸²ã€‚


``` 
ç¤ºä¾‹ 1:
è¾“å…¥: "()"
è¾“å‡º: true
ç¤ºä¾‹Â 2:

è¾“å…¥: "()[]{}"
è¾“å‡º: true
ç¤ºä¾‹Â 3:

è¾“å…¥: "(]"
è¾“å‡º: false
ç¤ºä¾‹Â 4:

è¾“å…¥: "([)]"
è¾“å‡º: false
ç¤ºä¾‹Â 5:

è¾“å…¥: "{[]}"
è¾“å‡º: true

```




```python
# answer
# ä¸»è¦æ€æƒ³:å †æ ˆstack
class Solution(object):
    def isValid(self, s):
        """
        :type s: str
        :rtype: bool
        """

        # The stack to keep track of opening brackets.
        stack = []

        # Hash map for keeping track of mappings. This keeps the code very clean.
        # Also makes adding more types of parenthesis easier
        mapping = {")": "(", "}": "{", "]": "["}

        # For every bracket in the expression.
        for char in s:

            # If the character is an closing bracket
            if char in mapping:

                # Pop the topmost element from the stack, if it is non empty
                # Otherwise assign a dummy value of '#' to the top_element variable
                top_element = stack.pop() if stack else '#'

                # The mapping for the opening bracket in our hash and the top
                # element of the stack don't match, return False
                if mapping[char] != top_element:
                    return False
            else:
                # We have an opening bracket, simply push it onto the stack.
                stack.append(char)

        # In the end, if the stack is empty, then we have a valid expression.
        # The stack won't be empty for cases like ((()
        return not stack
```


```python
solution = Solution() # å®ä¾‹åŒ–!!!!!
solution.isValid(s)
```


```python
# try2:
class Solution:
    def isValid(self, s: str) -> bool:
        dec = {  '(': ')',
               '{': '}', 
               '[': ']' }
        s = list(s)
        print(s)
        if len(s) == 0:return True
        if (len(s) % 2) == 1:return False # å¥‡æ•°ä¸ªæ—¶  

#     def cellpop()
    
        while s:
            for i in range(int(len(s)/2)):  # æ³¨æ„range(x)å–ä¸åˆ°x 
                print(i)
                if s[i] in dec:
                    if dec[s[i]] == s[i+1]:
                        s.pop(i+1)
                        s.pop(i)
                        print(('s=',s))
                        break
                    else:pass
            else:
                print('wrong')
                return False
        return True
```


```python
# try1:
class Solution:
    def isValid(self, s: str) -> bool:
        if len(s) == 0:return True
        if (len(s) % 2) == 1:return False # å¥‡æ•°ä¸ªæ—¶      
        left = s[0]
        right_exp = dec[s[0]]
        right_ind = s.index(right_exp)
        if (s.index % 2) == 0:return False 
        else:
            s_cell = s[1:(s.index-1)]
            symbolcell(s_cell)
        print(left,right_exp,right_ind)
    
    def symbolcell(self, s_cell):
        for i in range(len(s_cell)-1):
```


```python
nums1 = [1, 2] nums2 = [3, 4]
```

#### 2ï¸âƒ£

```python
class Solution:
    def isValid(self, s: str) -> bool:
        bracket_map = {
            ')':'(',
            '}':'{',
            ']':'['
        }
        stack = []
        for bracket in s:
            if bracket in bracket_map.keys():
                if not stack or stack[-1] != bracket_map[bracket]:
                    return False
                else:
                    stack.pop()
            else:
                stack.append(bracket)
        return True if not stack else False
         
```



### ğŸš©(0.5h)32. æœ€é•¿æœ‰æ•ˆæ‹¬å·

ç»™å®šä¸€ä¸ªåªåŒ…å« '(' å’Œ ')' çš„å­—ç¬¦ä¸²ï¼Œæ‰¾å‡ºæœ€é•¿çš„åŒ…å«æœ‰æ•ˆæ‹¬å·çš„å­ä¸²çš„é•¿åº¦ã€‚

```
ç¤ºä¾‹ 1:

è¾“å…¥: "(()"
è¾“å‡º: 2
è§£é‡Š: æœ€é•¿æœ‰æ•ˆæ‹¬å·å­ä¸²ä¸º "()"
ç¤ºä¾‹ 2:

è¾“å…¥: ")()())"
è¾“å‡º: 4
è§£é‡Š: æœ€é•¿æœ‰æ•ˆæ‹¬å·å­ä¸²ä¸º "()()"
```

#### æ ˆçš„ä¾‹å­

æ ˆåº•ï¼š stack=ã€-1ã€‘


```python
# æ ˆ

class Solution:
    def longestValidParentheses(self, s: str) -> int:
        stack = [-1]
        length = 0
        max_length = 0
        for i in range(len(s)):
            if s[i] == '(':
                stack.append(i)  # å¯¹äºé‡åˆ°çš„æ¯ä¸ªâ€˜(â€™ ï¼Œæˆ‘ä»¬å°†å®ƒçš„ä¸‹æ ‡æ”¾å…¥æ ˆä¸­
            else:   # å¦‚æœæ˜¯â€™)â€˜
                stack.pop()  # å¼¹å‡ºæ ˆé¡¶ï¼Œè¡¨ç¤ºåŒ¹é…äº†å½“å‰â€™)â€˜
                if stack == []:
                    stack.append(i) # æ‹¬å·ç»“æŸï¼Œè®°å½•ç»“æŸä½ç½®(æ›´æ–°ã€Œæœ€åä¸€ä¸ªæ²¡æœ‰è¢«åŒ¹é…çš„å³æ‹¬å·çš„ä¸‹æ ‡ã€)
                else:  # å¦‚æœæ ˆä¸ä¸ºç©ºï¼Œå½“å‰å³æ‹¬å·çš„ä¸‹æ ‡å‡å»æ ˆé¡¶å…ƒç´ å³ä¸ºã€Œä»¥è¯¥å³æ‹¬å·ä¸ºç»“å°¾çš„æœ€é•¿æœ‰æ•ˆæ‹¬å·çš„é•¿åº¦ã€
                    length = i-stack[-1]
                    max_length = max(max_length,length)
            print(i, stack, '  \tmax_length=',max_length)
        return max_length
```


```python
from typing import List

nums = ")()())"
solution = Solution()
result = solution.longestValidParentheses(nums)
result

```

### âœ…155. æœ€å°æ ˆ

è®¾è®¡ä¸€ä¸ªæ”¯æŒ pushï¼Œpopï¼Œtop æ“ä½œï¼Œå¹¶èƒ½åœ¨å¸¸æ•°æ—¶é—´å†…æ£€ç´¢åˆ°æœ€å°å…ƒç´ çš„æ ˆã€‚

push(x)Â -- å°†å…ƒç´  x æ¨å…¥æ ˆä¸­ã€‚
pop()Â -- åˆ é™¤æ ˆé¡¶çš„å…ƒç´ ã€‚
top()Â -- è·å–æ ˆé¡¶å…ƒç´ ã€‚
getMin() -- æ£€ç´¢æ ˆä¸­çš„æœ€å°å…ƒç´ ã€‚

```
ç¤ºä¾‹:MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin();   --> è¿”å› -3.minStack.pop();minStack.top();      --> è¿”å› 0.minStack.getMin();   --> è¿”å› -2.
```


```python
# æ ¸å¿ƒæ€æƒ³: å®šä¹‰è¾…åŠ©æ ˆhelper() æå‡æŸ¥æ‰¾æœ€å°å€¼é€Ÿåº¦
class MinStack:

    def __init__(self):
        """
        initialize your data structure here.
        """
        self.mylist = []
        self.helper = []

    def push(self, x: int) -> None:
        self.mylist.append(x)
        if len(self.helper) == 0 or x <= self.helper[-1]:
            self.helper.append(x)

    def pop(self) -> None:
        top = self.mylist.pop()
        if self.helper and top == self.helper[-1]:
            self.helper.pop()
        return top

    def top(self) -> int:
        return self.mylist[-1]

    def getMin(self) -> int:
        # æ³¨æ„æ­¤å¤„ä¸èƒ½æ˜¯ç­‰äº å¦åˆ™ä¼šæ”¹å˜ä¸€ä¸ªå¦ä¸€ä¸ªä¹Ÿä¼šå˜
        if self.helper:
             return self.helper[-1]
           


# Your MinStack object will be instantiated and called as such:
obj = MinStack()
obj.push(-2)
obj.push(0)
obj.push(-3)
# obj.mylist
# print(obj.getMin())
# obj.pop()
obj.mylist
# print(obj.top())
print((obj.getMin()))
```

### âœ… 581. æœ€çŸ­æ— åºè¿ç»­å­æ•°ç»„

**æ³¨æ„ä¸­æ‹¬å·[]ä¸èƒ½éšä¾¿ç”¨,è¦è¡¨ç¤ºå…ˆåå…³ç³»åªèƒ½ç”¨()**

ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œä½ éœ€è¦å¯»æ‰¾ä¸€ä¸ªè¿ç»­çš„å­æ•°ç»„ï¼Œå¦‚æœå¯¹è¿™ä¸ªå­æ•°ç»„è¿›è¡Œå‡åºæ’åºï¼Œé‚£ä¹ˆæ•´ä¸ªæ•°ç»„éƒ½ä¼šå˜ä¸ºå‡åºæ’åºã€‚

ä½ æ‰¾åˆ°çš„å­æ•°ç»„åº”æ˜¯æœ€çŸ­çš„ï¼Œè¯·è¾“å‡ºå®ƒçš„é•¿åº¦ã€‚

```
ç¤ºä¾‹ 1:

è¾“å…¥: [2, 6, 4, 8, 10, 9, 15]
è¾“å‡º: 5
è§£é‡Š: ä½ åªéœ€è¦å¯¹ [6, 4, 8, 10, 9] è¿›è¡Œå‡åºæ’åºï¼Œé‚£ä¹ˆæ•´ä¸ªè¡¨éƒ½ä¼šå˜ä¸ºå‡åºæ’åºã€‚
è¯´æ˜ :

è¾“å…¥çš„æ•°ç»„é•¿åº¦èŒƒå›´åœ¨Â [1, 10,000]ã€‚
è¾“å…¥çš„æ•°ç»„å¯èƒ½åŒ…å«é‡å¤å…ƒç´ Â ï¼Œæ‰€ä»¥å‡åºçš„æ„æ€æ˜¯<=ã€‚
```


```python

```


```python
class Solution:
    def findUnsortedSubarray(self, nums) -> int:
        nums_sorted = sorted(nums)
        print((nums,nums_sorted))
        if not [(nums > nums_sorted) - (nums < nums_sorted)]:
            return 0  
        else:
            end = 0
            start = 0
            for i in range(len(nums)):
                if nums[i] != nums_sorted[i]:
                    start = i
                    break
            for i in range(1,len(nums)):
                if nums[-i] != nums_sorted[-i]:
                    end = len(nums)-i
                    break

            length = end - start + 1
            return length

    
# nums = [2,6,4,8,9,22,15]
nums = [1,2,3,4]
solution = Solution()
result = solution.findUnsortedSubarray(nums)
result
```

