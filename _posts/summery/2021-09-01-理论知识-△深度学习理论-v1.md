# △深度学习理论

### Gap层的原理

全局平均池化，是替代FC的一种方式，可以将每个二维的特征通道变成一个实数，该实数某种程度上具有该特征通道的全局信息。最开始主要是从模型压缩的应用中得到的灵感。

- **使用原因**：

  - FC层的权值参数最多，现在的趋势是尽量**避免全连接**，近期的大部分论文多用全局平均池化层代替。

    > 因为全连接层的每一个节点都与上一层每个节点连接，是把前一层的输出特征都综合起来

  - 更重要的是实验效果并不比用 FC 差

- **整体思想**：

  - 用 feature map直接表示属于某个类的 confidence map
  - 每个feature map中的值加起来求平均值，直接作为属于某个类别的**置信度**
  - 把一维的置信度输入softmax中分类

- **GAP的优势**：

  - 因为FC的参数众多，GAP减少了参数的数量（在最近比较火的**模型压缩**中，这个优势可以很好的压缩模型的大小）
  - 因为在这种特别小样本的情况下是非常容易过拟合的，GAP可以很好的**减轻过拟合**的发生

### 过拟合

- **原理：**

  - 根本原因：特征维度过多，模型假设过于复杂，参数过多，训练数据过少，噪声过多。
  - 导致拟合的函数过度的拟合了训练集，但没有考虑到泛化能力从而对新数据的测试集预测结果差。
  - 因此需要：减少特征维度，或者正则化降低参数值。

- **避免方法**：交叉验证、正则化、数据增强、Dropout、降低模型复杂程度、early stopping 等

  - 交叉验证：

    - 即<u>重复使用数据</u>，把得到的样本数据进行切分，组合为不同的训练集和测试集，用训练集训练模型，用测试集来评估模型预测的好坏。

    - 由于在此基础上可以得到多组不同的训练集和测试集，某次训练集中的某样本在下次可能成为测试集中的样本，即所谓“交叉”。

    - 当数据量不是很充足的时候，会使用交叉验证。

    - 在训练过程中，我们**经常使用交叉验证来确定一些超参数**。

      > 比方依据validation data上的accuracy来确定early stopping的epoch大小、learning rate等等

  - 正则化(L1和L2)：通过改动代价函数实现。

  - 数据增强：去除非共性特征。

  - Dropout：通过改动神经网络本身来实现。例如，训练前，随机删除一部分隐层单元，保持输入输出层不变，依照BP算法更新上图神经网络中的权值。

  - 降低模型复杂程度。

  - early stopping：即提前终止迭代来防止过拟合。

  - Bagging用不同的模型拟合不同部分的训练集；

  - Boosting只使用简单的神经网络； 

  - 数据清洗：将错误的label纠正或者删除错误的数据。


### 小样本问题-模型方面

- 迁移学习
- 无监督、半监督
- GAN网络
- 结构优化

  - 利用样本相关性
  - 使用残差学习和**特征融合**

### 欠拟合

- **原理：**
  - 欠拟合的根本原因**：特征维度过少，模型过于简单**，
  - 导致拟合的函数无法满足训练集，误差较大； 
  - **因此需要增加特征维度，增加训练数据。**
- **避免方法：**
  - 模型方面：模型复杂化、调整参数和超参数、降低正则化约束
  - 特征方面：增加更多的特征
  - **模型复杂化**
    - 对同一个算法复杂化。例如回归模型添加更多的高次项，增加决策树的深度，增加神经网络的隐藏层数和隐藏单元数等
    - 弃用原来的算法，使用一个更加复杂的算法或模型。例如用神经网络来替代线性回归，用随机森林来代替决策树等
  - **增加更多的特征，使输入数据具有更强的表达能力**
    - 特征挖掘十分重要，尤其是具有强表达能力的特征，往往可以抵过大量的弱表达能力的特征
    - 特征的数量往往并非重点，质量才是，总之强特最重要
    - 能否挖掘出强特，还在于对数据本身以及具体应用场景的深刻理解，往往依赖于经验
  - **调整参数和超参数**
    - 超参数包括：神经网络中：学习率、学习衰减率、隐藏层数、隐藏层的单元数、Adam优化算法中的β1β1和β2β2参数、batch_size数值等
    - 其他算法中：随机森林的树数量，k-means中的cluster数，正则化参数λλ等
  - **降低正则化约束**
    - 正则化约束是为了防止模型过拟合，如果模型压根不存在过拟合而是欠拟合了，那么就考虑是否降低正则化参数λλ或者直接去除正则化项
  - **增加训练数据往往没有用**
    - 欠拟合本来就是模型的学习能力不足，增加再多的数据给它训练它也没能力学习好

### 样本不均衡问题

- **原理**：
  - 某类数据不均衡（某一标签数量太多，其余标签数量太少）的问题，在机器学习中被称为**“长尾问题”**。
  - 这个问题导致，数据集中（尤其是大型数据集）样本数量少的物体，**泛化效果**会非常差。

<img src="/img/in-post/20_07/v2-4eb62875ea6a629b3772ae2ec35bc37d_720w-0044321.jpg" alt="img" style="zoom: 50%;" />



- **方法**：重采样、**数据合成** 、重加权、**迁移学习** 、度量学习、元学习/域自适应、**解耦特征和分类器** 

  - **重采样** （re-sampling）：分为对少样本的**过采样**、及多样本的**欠采样**。但这2种方法，都有欠缺：过采样容易发生少样本过拟合，无法学习更鲁棒、易泛化的特征，在不平衡数据上表现较差；欠采样会造成多样本严重信息损失，导致发生欠拟合。
  - **数据合成** （synthetic samples）**：生成和少样本相似的新数据**。以SMOTE方法为例，对于任意选取的少类样本，它用K近邻选取相似样本，并通过对样本线性插值得到新样本。这里与mixup方法相似，因此，也有非均衡的mixup版本出现。
  - **重加权** （re-weighting）：为不同类别（甚至不同样本）分配不同的权重。其中，权重可以自适应。这一方法诞生出很多变种，如对类别数目的倒数进行加权、对“有效”样本数加权、对样本数优化分类间距的损失加权等等。
  - **迁移学习** （transfer learning）：对多类和少类样本**分别建模**，将学到的多类样本信息/表示/知识迁移给少类别使用。
    <img src="/img/in-post/20_07/v2-623aef46d94f448786ff163b15635872_720w-5034007-0044321.jpg" alt="img" style="zoom: 50%;" />
  - **度量学习** （metric learning）：希望能**学到更好的嵌入**，以对少类附近的边界/边缘更好地建模。
  - **元学习/域自适应** （meta learning/domain adaptation）：分别对头、尾部数据进行不同处理，自适应地学习如何重加权，或是规划成域自适应问题。
    <img src="/img/in-post/20_07/v2-0303f1faccc24c84435a5070c1b55bdf_720w-0044321.jpg" alt="img" style="zoom:25%;" />
  - **解耦特征和分类器** （decoupling representation & classifier）：研究发现，**将特征学习和分类器学习解耦**、将不平衡学习分为两个阶段，并在特征学习阶段正常采样、在分类器学习阶段平衡采样，可以带来更好的长尾学习效果。这是目前最优的长尾分类算法。（🚩待研究）
  - **自监督预训练：** 但这些，在样本极端失衡的情况下也没法用，如果真的只有几个样本，模型的性能差异就无法避免。所以可以考虑如下的自监督预训练。

  ###  自监督学习方法

- **训练数据集**：不是由人手动标记的，每个样本的标签是通过利用输入的相关性生成的（如来自不同的传感器模式）。

- **标签**：通常来自于数据本身: 即模型直接从无标签数据中自行学习，无需标注数据。

- **训练**：**通过使用各种辅助任务 (auxiliary task ) 训练网络**, 来提高学习表征 (representation) 的质量.

- **核心**：如何自动为数据产生标签。如随机旋转, 均匀分割而自动产生的标注

- **性能评价**：通过模型学出来的**feature的质量**来评价. feature质量是通过迁移学习的方式，把feature用到其它视觉任务中通过结果的好坏来评价。

### 分类评价指标

- 整体精度OA（overall accuracy），将测试集上**正确分类的像素点的个数除以总的像素个数**

- 平均精度AA（average accuracy），将测试集上**每类正确分类的像素点个数除以该类所有像素的总数**，然后计算所有类别的精度的平均值称为平均精度AA。

- Kappa（Kappa Coefficient），Kappa系数是定义在混淆矩阵X上的一个评价指标，综合考虑**混淆矩阵**对角线上的元素和**偏离对角线**的元素，可以惩罚模型的“偏向性”，更客观地反映了算法的分类性能, Kappa 的值在-1~1的范围 。 

> 各个类别的样本数量**往往不太平衡**时，模型很容易偏向大类别而放弃小类别  (eg: 正负样本比例1:9，直接全部预测为负，acc也有90%。但正样本就完全被“抛弃”了)。 导致**整体acc挺高，但是部分类别完全不能被召回**。
>
> 基于混淆矩阵的kappa系数计算公式如下：是一种能够**惩罚模型的“偏向性”**的指标来代替acc。

### ResNet为什么有效

- 从梯度弥散、网络退化角度看

  - **梯度消失/爆炸**已经通过 normalized 、initialization 等方式得到缓解。残差结构是为了解决**网络退化**的问题提出的，跨层输入相当于一个恒等映射，中间层只需拟合残差，因此层的加入不会使效果变差
  - 在网络上堆叠这样的结构，**就算梯度消失，我什么也学不到，我至少把原来的样子恒等映射了过去**，相当于在浅层网络上堆叠了“**复制层**”，这样**至少不会比浅层网络差**。
- 从**梯度反向传播的角度**解释

  - 即过于深的网络在反传时容易发生梯度弥散，一旦某一步开始导数小于1，此后**继续反传**，传到前面时，用float32位数字已经无法表示梯度的变化了，相当于梯度没有改变，也就是浅层的网络学不到东西了。**这是网络太深反而效果下降的原因**。
  - 加入ResNet中的shortcut结构之后，在**反传时，每两个block之间不仅传递了梯度，还加上了求导之前的梯度**，这相当于把每一个block中向前传递的梯度人为加大了，也就会**减小梯度弥散的可能性**。
- 解决**欠拟合**问题角度解释(待研究)

  - 在正向卷积时，对每一层做卷积其实只提取了图像的一部分信息，这样一来，越到深层，原始图像信息的丢失越严重，而仅仅是对原始图像中的一小部分特征做提取。 这显然会发生类似欠拟合的现象。 加入shortcut结构，相当于在**每个block中又加入了上一层图像的全部信息，一定程度上保留了更多的原始信息。**
  - 由于每做一次卷积（包括对应的激活操作）都会浪费掉一些信息：比如卷积核参数的随机性（盲目性）、激活函数的抑制作用等等。这时，**ResNet中的shortcut相当于把以前处理过的信息直接再拿到现在一并处理，起到了减损的效果。**
- 模型集成角度解释（加入shortcut后**相当于一个ensemble模型**）

  - **输出的结果是前面各个block及其组合一起做的一个投票选出的结果**。即可以把ResNet网络看成是多个子网络并行，从实验中看，真实起作用的路径长度并不深，主要走是中等深度的网络。简单来说，就是**做了不同层次上的特征组合。**
- 特征具有层次性的角度解释

  - **回到网络结构上面，浅层网络提取的是简单的特征**，而简单和复杂的特征适用于不同的样本，没有shortcut时，对所有样本的分类都是利用最复杂的特征判断，费时费力；**加入shortcut后，相当于保留了一些简单的特征用于判断，变得省时。这一观点主要解释了为什么ResNet网络能够更快收敛。**



### Dropout(解决过拟合现象)

- **原理**：
  - 往往在模型参数太多，训练样本少，易产生过拟合情况下。
  - 在神经网络训练过程中 ，对于神经单元**按一定的概率令其停止工作**（置零），
  - 这样可以提升模型的**泛化能力**，使其不会太依赖某些**局部特征**。
  - 相当于每次训练都是不同的网络，bagging思想
- **具体操作**：每次迭代，重复下述过程
  1. 一定概率将某些隐层神经元置零
  2. 前向传播
  3. 反向传播，更新未被删除神经元的权重
  4. 恢复被删除的神经元
- **作用：**
  - 减少神经元之间复杂的**共适应关系**，权值更新不再依赖于有固定关系的隐含节点的共同作用。
  - 阻止了某些特征仅仅在其他特定特征下才有效的情况，**增强了模型的鲁棒性。**

### BN层的原理（归一化+变换重构）

- **原理**：

  - BN的本质是利用**优化**的方法来改变方差大小和均值的位置
  - 可以加快收敛速度、减小梯度消失和梯度爆炸、控制过拟合等。
    <img src="/img/in-post/20_07/v2-0b0f8a8ffd52e44bbc0330f32e1f5907_1440w.jpg" alt="img" style="zoom:67%;" />

- **具体操作：**

  - 首先进行**归一化**：对输入数据进行一个标准的“减均值除方差”的归一化过程（为了防止分母为0加了一个ε）。但这样会影响到本层网络所学习到的特征，因为特征分布会被破坏。
  - 所以还需要**变换重构**：增加了`γ`和`β`这2个需要学习的参数，这两个参数是在每个batch的数据上计算得到的，可以通过优化改变方差大小和均值的位置。
  - **具体实现**是：在网络的每一层输入的时候，又**插入了一个归一化层**，也就是先做一个归一化处理（归一化至：均值0、方差为1），然后再进入网络的下一层。

- **细节：**

  - **训练阶段**：因为每个batch的数据分布是不同的，所以在训练阶段对每个batch都会进行BN归一化，并通过滑窗平均的方式在训练结束后保存下全部数据的分布参数。
  - **测试阶段**：因为训练阶段完成后，均值、方差、γ、β已经是固定数值了，所以即可直接用训练阶段得到的参数来进行BN即可。
  - **BN参数量**：因为每个通道上会进行BN，所以个数为c。

- **优化方式**： 

  - 将BN和CNN进行结合，加速计算，减少参数量（因为一堆参数都可以改成一个参数，减少计算和参数量）

- **BN层的作用**

  - 加快**训练速度**, 增大学习率（BN使每一层的**输入分布稳定**，使激活函数能够有效地利用输入信息，确保随着训练，网络层可以持续学习输入的分布，因此可以使训练加速）

    > 如果每层的数据分布都不一样的话，将会导致网络非常难收敛和训练，而如果把 每层的数据都在转换在均值为零，方差为1 的状态下，这样**每层数据的分布都一样**, 训练会比较容易收敛。
    >
    > 使激活函数能够更有效地利用输入信息，确保层能持续的学习输入的分布，内部协方差不断变小，加速训练过程。

  - 减小**梯度消失和梯度爆炸**  (做归一化可以将数据分布**映射到一个比较合适的范围内**, 否则, 当x到了一定的大小，经过sigmoid函数后输出范围就会变得很小)

    > 以sigmoid函数为例，sigmoid函数使得输出在[0,1]之间，实际上当x到了一定的大小，经过sigmoid函数后输出范围就会变得很小

  - 改善正则化策略，控制**过拟合**，可以少用或者不用dropout和正则（因为BN本身就是一个归一化网络层）

    > 在网络的训练中，BN的使用**使得一个minibatch中所有样本都被关联在了一起**，因此网络不会从某一个训练样本中生成确定的结果，即同样一个样本的输出不再仅仅取决于样本的本身，也取决于跟这个样本同属一个batch的其他样本，而每次网络都是随机取batch，这样就会使得整个网络不会朝这一个方向使劲学习。一定程度上避免了过拟合。

  - 使网络对参数设置不敏感,如学习率, 初始权重等

### 梯度消失和梯度爆炸

- 原理：
  - 梯度消失：因为各层**权值**（特征值）过小，使用了sigmoid等激活函数（最大梯度0.25）
  - 梯度爆炸：因为各层**权值**（特征值）过大。
  - 梯度的连续反向传播是通过**权重层w连乘**进行的。
  - 参数的更新为： $w+△w→w$
  - 如果要更新第二隐藏层的权值信息，根据**链式求导法则，更新梯度信息**： 

![img](/img/in-post/20_07/20190422161352350.png)



- **解决方法**：
  1.  换用Relu、**LeakyRelu、Elu**等激活函数
  2. Batch Normalization
  3.  ResNet 残差结构
  4.  预训练 + finetunning(微调)
  5.  梯度剪切、L1、L2正则
  6. 🚩LSTM 结构



### 池化层的反向传播

》 参考链接：https://blog.csdn.net/Jason_yyz/article/details/80003271

- mean-pooling：梯度平均传播
- max-pooling：把梯度直接传给前一层**某一个像素**，而其他像素不接受梯度，也就是为0（有保存位置的maxid）

### l1和l2正则化的作用

- **原理：**
  - 正则化的主要作用是防止过拟合，对模型添加正则化项可以**限制模型的复杂度**，使得模型在复杂度和性能达到平衡。
  - L1正则化和L2正则化可以看做是**损失函数的惩罚项**。所谓『惩罚』是指对损失函数中的某些参数做一些限制。**无约束变成有约束**。
  - L1正则化是指权值向量w中各个元素的**绝对值之和**
  - L2正则化是指权值向量w中各个元素的**平方和然后再求平方根**

- $l1$正则化：

  - **优点**是可以产生稀疏权值矩阵，即产生一个**稀疏模型**，可以用于特征选择

  - **缺点**是目标函数在**原点不可导**，需要做特殊处理（比如：使用smooth l1）

    > 画出损失函数等值线和L1正则化的函数。（二维特征）
    >
    > <img src="/img/in-post/20_07/format,png-7290731.png" alt="@图1 L1正则化" style="zoom:25%;" />
    >
    > **多维情况下，顶点角更多，在这些角上，很多权值等于0**，产生模型，可用于特征选择。

- $l2$正则化：

  - **优点**是实现简单，能够起**正则化**作用，**防止模型过拟合**

    > **为什么可以避免过拟合？**
    >
    > - 拟合过程中通常都倾向于让**权值尽可能小**，最后构造一个所有参数都比较小的模型。因为一般认为参数值小的**模型比较简单**，能适应不同的数据集，也在一定程度上**避免了过拟合现象**。否则如果参数很大，小的变动就能对结构有很大的影响，这样模型不稳定。

  - **缺点**是无法获得稀疏模型

    > <img src="/img/in-post/20_07/format,png-20210726171411062.png" alt="@图2 L2正则化" style="zoom:25%;" />
    >
    > **为什么无法获得稀疏模型？**
    >
    > - 权值等于0的概率比L1小了很多。

- 改进版 - $smooth\ l1$：

  - 该函数实际上就是一个分段函数,
  - 在[-1,1]之间实际上就是L2损失，这样解决了**L1的不光滑**问题，
  - 在[-1,1]区间外，实际上就是L1损失，这样就解决了**离群点梯度爆炸**的问题。

### l1和l2的鲁棒性（robustness）

- 与最小平方相比，**最小绝对值偏差方法的鲁棒性更好**，它**能更好的处理数据中的异常值。**如果需要考虑任一或全部的异常值，那么最小绝对值偏差是更好的选择。
- 从直观上说，因为**L2范数将误差平方化**（如果误差大于1，则误差会放大很多），模型的误差会比L1范数来得大，因此模型会对这个样本更加敏感，这就需要调整模型来最小化误差。如果这个样本是一个异常值，模型就需要调整以适应单个的异常值，这会牺牲许多其它正常的样本，因为这些正常样本的误差比这单个的异常值的误差小。
- 重建任务中不希望异常值对重建损失带来太大的影响，所以用l1距离鲁棒性更高、效果更好。 

### 网络优化器总结

- 梯度下降法(Gradient Descent)

  - 标准梯度下降法**(GD)**

    - <img src="/img/in-post/20_07/image-20210716003425976.png" alt="image-20210716003425976" style="zoom:50%;" />

      > - 从表达式来看，模型参数的更新调整，与代价函数**关于模型参数的梯度有关**，即沿着梯度的方向不断减小模型参数，从而最小化代价函数。
      > - 基本策略可以理解为”**在有限视距内寻找最快路径下山**“，因此每走一步，参考当前位置最陡的方向(即**梯度**)进而迈出下一步。可以形象的表示为：

    - 缺点

      - **训练速度慢**：（每一步调整）
      - **容易陷入局部最优解**（无法跳出局部最优点）

  - **批量梯度下降法(BGD)**

    - 模型参数的调整更新与全部输入样本的**代价函数的和**（即批量/全局误差）有关。
    - 优点
      - 批量梯度下降法比标准梯度下降法训练时间短，且每次下降的方向都很正确。

  - **随机梯度下降法(SGD)**

    - 优点
      - 但是对梯度的要求很低（计算梯度快）
      - 应用大型数据集时，训练速度很快。
    - 缺点
      - SGD在随机选择梯度的同时会引入噪声，使得**权值更新的方向**不一定正确。
      - 此外，SGD也没能单独克服**局部最优解**的问题。

- **动量优化法**

  - 动量优化方法是在梯度下降法的基础上进行的改变，具有**加速梯度下降**的作用。一般有标准动量优化方法Momentum、NAG（Nesterov accelerated gradient）动量优化方法。
  - Momentum
    - 使用动量(Momentum)的随机梯度下降法(SGD)，主要思想是**引入一个积攒历史梯度信息动量**来加速SGD。由于当前权值的改变会受到上一次权值改变的影响，类似于小球向下滚动的时候带上了**惯性**。这样可以加快小球向下滚动的速度。
    - 优点：主要解决SGD的两个问题：
      - 一是随机梯度的方法（引入的噪声）；
      - 二是Hessian矩阵病态问题（可以理解为SGD在收敛过程中和正确梯度相比来回摆动比较大的问题）。
  - 牛顿加速梯度（NAG, Nesterov accelerated gradient）算法
    - 是Momentum动量算法的变种。理解策略：在Momentun中小球会盲目地跟从下坡的梯度，容易发生错误。所以需要一个更聪明的小球，能提前知道它要去哪里，还要知道走到坡底的时候速度慢下来而不是又冲上另一个坡。

- **自适应学习率优化算法**

  - **AdaGrad算法**，**RMSProp算法**，**Adam算法**以及**AdaDelta算法**。

  - AdaGrad算法

    - 从表达式可以看出，对出现比较多的类别数据，Adagrad给予越来越小的学习率，而对于比较少的类别数据，会给予较大的学习率。因此Adagrad适用于数据稀疏或者分布不平衡的数据集。
    - 优势在于**不需要人为的调节学习率**，它可以自动调节；
    - 缺点在于，随着迭代次数增多，学习率会越来越小，最终会趋近于0。

  - RMSProp算法

    - RMSProp借鉴了Adagrad的思想，观察表达式，分母为由于取了个加权平均，RMSProp算法在经验上已经被证明是一种有效且实用的深度神经网络优化算法。目前它是深度学习从业者**经常采用**的优化方法之一。
    - 优点：避免了学习率越来越低的的问题，而且能自适应地调节学习率。

  - AdaDelta算法。

    - 优点：在模型训练的初期和中期，AdaDelta表现很好，加速效果不错，训练速度快。
    - 缺点：在模型训练的后期，模型会反复地在局部最小值附近抖动。