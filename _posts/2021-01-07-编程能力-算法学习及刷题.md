---
layout: post
Comment: true
mathjax: true
author: "Sun"
header-style: text
header-img: img/computer-code.jpg
tags:
  - C++
  - 数据结构
  - 算法
catalog: true
---



# 概要及参考书

## 规范
1. 每个题不超过30min思考做题，整个题不超过1h
2. 知识点用四级目录
3. 按类别刷题时，先看书再刷题

## 常用记录

**打印所有输出**


```python
import time
# 多行输出
from IPython.core.interactiveshell import InteractiveShell 
InteractiveShell.ast_node_interactivity = 'all'  #默认为'last'
```

## 《图解算法》

### 知识点 


#### 时间复杂度(大O时间)
![](https://cdn.jsdelivr.net/gh/sunqinghu/PicRepo/img/2020/20201023173355.png)

#### 散列表
* Python中的散列表为**字典**,散列表将键映射到值


```python
"""
查找,模拟映射关系
"""
book = dict()
book['apple'] = 2
book['milk'] = 3
book['avocado'] = 5
book
```


    {'apple': 2, 'milk': 3, 'avocado': 5}


```python
book['milk']
```


    3




```python
"""
防止重复
"""
voted = {} 
def check_voter(name):
    if voted.get(name):
        print ("kick them out!")
    else:
        voted[name] = True
        print ("let them vote!")
```


```python
check_voter('tom')
```

    let them vote!



```python
check_voter('tom')
```

    kick them out!



```python
"""
缓存数据
"""
cache = {} 
def get_page(url):    
    if cache.get(url):
        return cache[url]   
    else:     
        data = get_data_from_server(url)     
        cache[url] = data     
        return data
```

### 算法

#### 快速排序 ???


```python
def quicksort(array):
    if len(array) < 2:
        return array
    else:
        pivot = array[0]
        less = [i for i in array[1:] if i <= pivot]
  
        greater = [i for i in array[1:] if i > pivot]
        
        return quicksort(less) + [pivot] + quicksort(greater) 
print((quicksort([10, 5, 2, 3])))
```



#### 广度优先搜索 -- 图



```python
"""
实现图
"""
# map "you" to a list
graph = {} 
graph["you"] = ["alice", "bob", "claire"]
graph["bob"] = ["anuj", "peggy"] 
graph["alice"] = ["peggy"] 
graph["claire"] = ["thom", "jonny"] 
graph["anuj"] = [] 
graph["peggy"] = [] 
graph["thom"] = [] 
graph["jonny"] = []
graph
```


    {'you': ['alice', 'bob', 'claire'],
     'bob': ['anuj', 'peggy'],
     'alice': ['peggy'],
     'claire': ['thom', 'jonny'],
     'anuj': [],
     'peggy': [],
     'thom': [],
     'jonny': []}



![](https://cdn.jsdelivr.net/gh/sunqinghu/PicRepo/img/2020/20201023173422.png)


```python
"""
实现算法
"""
from collections import deque 

def person_is_seller(name):     
    return name[-1] == 'm' # a seller whose name finashed by 'm'

def search(name):
    search_queue = deque()   # 可使用函数deque来创建一个双端队列
    search_queue += graph["you"]
    searched = [] # use to record the person who have searched -- it is important
    while search_queue:     
        person = search_queue.popleft()
        if not person in searched:  # only inspect while did not have searched 
            if person_is_seller(person): 
                print(person + " is a mango seller!" )
                return True 
            else: 
                search_queue += graph[person] 
                searched.append(person)
    return False
search("you")
```

    thom is a mango seller!
    
    True



**算法原理**
![](https://cdn.jsdelivr.net/gh/sunqinghu/PicRepo/img/2020/20201023173450.png)

#### 狄克斯特拉算法计算有权图
![](https://cdn.jsdelivr.net/gh/sunqinghu/PicRepo/img/2020/20201023173529.png)


```python
"""
Graph hash table
"""
graph = {}
graph["start"] = {} 
graph["start"]["a"] = 6 
graph["start"]["b"] = 2

graph["a"] = {} 
graph["a"]["fin"] = 1 

graph["b"] = {} 
graph["b"]["a"] = 3 
graph["b"]["fin"] = 5

graph["fin"] = {} # 终结点无邻居
```


```python
# 获取起点的所有邻居
graph["start"].keys()
```


    dict_keys(['a', 'b'])




```python
# 获得权重
graph["start"]["a"]
```


    6




```python
"""
Costs hash table
"""
infinity = float("inf") 

costs = {} 
costs["a"] = 6 
costs["b"] = 2 
# 不知道到终点需要多长时间。对于还不知道的开销,你将其设置为无穷大。
costs["fin"] = infinity 
costs["fin"]
```


    inf




```python
"""
Parents hash table
"""
parents = {} 
parents["a"] = "start" 
parents["b"] = "start" 
parents["fin"] = None
# 最后需要一个数组,用于记录处理过的节点,你不用处理多次。  
processed = []
```

**算法原理**
![](https://cdn.jsdelivr.net/gh/sunqinghu/PicRepo/img/2020/20201023173550.png)  


```python
def find_lowest_cost_node(costs):     
    lowest_cost = float("inf")      
    lowest_cost_node = None     
    for node in costs:  
        cost = costs[node] 
        if cost < lowest_cost and node not in processed: 
            lowest_cost = cost 
            lowest_cost_node = node     
    return lowest_cost_node

node = find_lowest_cost_node(costs) 

while node is not None:     
    cost = costs[node]     
    neighbors = graph[node]     
    for n in neighbors.keys(): 
        new_cost = cost + neighbors[n] 
        if costs[n] > new_cost: 
            costs[n] = new_cost 
            parents[n] = node     
    processed.append(node)     
    node = find_lowest_cost_node(costs)
print(cost)
```

    6


![](https://cdn.jsdelivr.net/gh/sunqinghu/PicRepo/img/2020/20201023173808.png)


```python
# A -- 不对
"""
Graph hash table
"""
graph = {}
graph["start"] = {}
graph["start"]["a"] = 5
graph["start"]["b"] = 2
graph["a"] = {}
graph["a"]["c"] = 4
graph["a"]["d"] = 2
graph["b"] = {}     # init， important
graph["b"]["a"] = 8
graph["b"]["d"] = 7
graph["c"] = {}
graph["c"]["d"] = 6
graph["c"]["fin"] = 3
graph["d"] = {}
graph["d"]["fin"] = 1
graph["fin"] = {} # 终结点无邻居

"""
Costs hash table：cost to start
"""
infinity = float("inf")

costs = {}
costs["a"] = infinity
costs["b"] = 2
# 不知道到终点需要多长时间。对于还不知道的开销,你将其设置为无穷大。
costs["c"] = infinity
costs["d"] = infinity
costs["fin"] = infinity

"""
Parents hash table: only record the cost that knows
"""
parents = {}
parents["a"] = None
parents["b"] = "start"
parents["c"] = None
parents["d"] = None
parents["fin"] = None
# 最后需要一个数组,用于记录处理过的节点,你不用处理多次。
processed = []

def find_lowest_cost_node(costs):
    lowest_cost = float("inf")
    lowest_cost_node = None
    for node in costs:
        cost = costs[node]
        if cost < lowest_cost and node not in processed:
            lowest_cost = cost
            lowest_cost_node = node
    return lowest_cost_node

node = find_lowest_cost_node(costs)
while node is not None:
    cost = costs[node]
    neighbors = graph[node]
    for n in neighbors.keys():
        
        new_cost = cost + neighbors[n]
        if costs[n] > new_cost:
            costs[n] = new_cost
            parents[n] = node
        print(costs[n])
    processed.append(node)
    node = find_lowest_cost_node(costs)


```

    10
    9
    10
    14
    9
    9
    10


#### 贪婪算法
* 处理没有快速算法的问题 -- NP完全问题
* 每步都寻找局部最优解

集合覆盖问题

具体方法如下。  

(1) 列出每个可能的广播台集合,这被称为幂集(power set)。可能的子集有2n个。 

(2) 在这些集合中,选出覆盖全美50个州的最小集合。

![](https://cdn.jsdelivr.net/gh/sunqinghu/PicRepo/img/2020/20201023173833.png)


```python
# 不对
states_needed = set(["mt", "wa", "or", "id", "nv", "ut", "ca", "az"])

# 有可供选择的广播台清单,我选择使用散列表来表示它。 
stations = {} 
stations["kone"] = set(["id", "nv", "ut"]) 
stations["ktwo"] = set(["wa", "id", "mt"]) 
stations["kthree"] = set(["or", "nv", "ca"]) 
stations["kfour"] = set(["nv", "ut"]) 
stations["kfive"] = set(["ca", "az"])

final_stations = set() 

while states_needed:   
    best_station = None  # 存储最优  
    states_covered = set()
    for station, states_for_station in stations.items():
        covered = states_needed & states_for_station 
        if len(covered) > len(states_covered):   
            best_station = station   
            states_covered = covered
            
states_needed -= states_covered 
final_stations.add(best_station) 
print(final_stations)
```

#### 动态规划
* 只能处理没有相互依赖关系
* 横向：加入新增商品价值 与 没加入该商品时最大价值（上一行） 比较，选择大的

#### 树 
![](https://cdn.jsdelivr.net/gh/sunqinghu/PicRepo/img/2020/20201023174120.png)
* 不能随机访问
* 平衡时效果才好


#### 分布式算法（MapReduce）-- 并行算法的一种
* 可通过流行的开源工具Apache Hadoop来使用
* 基于两个简单的理念: 映射(map)函数和 归并(reduce)函数。


```python
# 映射函数 map
# 如果有100台计算机,而map能够自动将工作分配给这些计算机去完成就好了。
# 这样就可同时下载100个页面,下载速度将快得多!这就是MapReduce中“映射”部分基于的理念。
arr1 = [1, 2, 3, 4, 5]
arr2 = map(lambda x: 2 * x, arr1)
arr2
```


```python
map?
```


```python
# 归并reduce（）
arr1 = [1, 2, 3, 4, 5] 
reduce(lambda x,y: x+y, arr1)
```


```python
# nums = [3,4,5,1,2]
nums = [2,2,2,0,1]
# nums = [10,1,10,10,10]
```


```python
class Solution:
    def minArray(self, numbers) -> int:
        a = 0
        b = len(numbers)-1
        while a<b:
            # prior: numbers[a] > numbers[b]
            i = (a+b)//2
            # Notice compare the value of b
            # Notice need to add 1 to avoid endless loop
            if numbers[i] > numbers[b]:
                a = i + 1
            elif numbers[i] < numbers[b]:
                b = i
            # Notice this situation
            else: 
                b -= 1
        return numbers[b]
```


```python
solution = Solution()
result = solution.minArray(nums)
result
```

# Leetcode按类型

## 未分类类型


### (1h) [6. Z 字形变换](https://leetcode-cn.com/problems/zigzag-conversion/)

难度中等877收藏分享切换为英文接收动态反馈

将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 `"LEETCODEISHIRING"` 行数为 3 时，排列如下：
    
    L C I R E T O E S I I G E D H N 

之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：`"LCIRETOESIIGEDHN"`。

请你实现这个将字符串进行指定行数变换的函数：
    
    string convert(string s, int numRows);
```
示例 1:

输入: s = "LEETCODEISHIRING", numRows = 3
输出: "LCIRETOESIIGEDHN"
示例 2:

输入: s = "LEETCODEISHIRING", numRows = 4
输出: "LDREOEIIECIHNTSG"
解释:

L     D     R
E   O E   I I
E C   I H   N
T     S     G
```

### √(1.5h) [8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)

难度中等880收藏分享切换为英文接收动态反馈

请你来实现一个 `atoi` 函数，使其能将字符串转换成整数。

首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：

  * 如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。
  * 假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。
  * 该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。

注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。

在任何情况下，若函数不能进行有效的转换时，请返回 0 。

**提示：**

  * 本题中的空白字符只包括空格字符 `' '` 。
  * 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。

```python
class Solution:
    def helper(self,s):
        for i, word in enumerate(s):
            if word not in '1234567890':
                return int(s[:i]) 
        return int(s)

    def myAtoi(self, s: str) -> int:
        for i, word in enumerate(s):
            if word not in ' -+1234567890':
                return 0
            elif word in '-+':
                if  len(s) > i+1  and s[i+1] in '1234567890':
                    res = self.helper(s[i+1:]) * -1 if word is '-' else self.helper(s[i+1:])
                    return max( min( res, 2147483647), -2147483648)
                else: return 0
            elif word  in '1234567890':
                res =  self.helper(s[i:])
                return max( min( res, 2147483647), -2147483648)
        return 0
    
        
## 法2  正则  34%
    # def myAtoi(self, s: str) -> int:
    #     return max(min(int(*re.findall('^[\+\-]?\d+', s.lstrip())), 2**31 - 1), -2**31)
```

### √（1h) [12. 整数转罗马数字](https://leetcode-cn.com/problems/integer-to-roman/)

罗马数字包含以下七种字符： `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。
    
    **字符** **数值** I 1 V 5 X 10 L 50 C 100 D 500 M 1000

例如， 罗马数字 2 写做 `II` ，即为两个并列的 1。12 写做 `XII` ，即为 `X` + `II` 。 27 写做  `XXVII`, 即为 `XX` + `V` + `II` 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：

  * `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。
  * `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 
  * `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。

给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。
```
示例 1:

输入: 3
输出: "III"

示例 2:

输入: 4
输出: "IV"

示例 3:

输入: 9
输出: "IX"

示例 4:

输入: 58
输出: "LVIII"
解释: L = 50, V = 5, III = 3.

示例 5:

输入: 1994
输出: "MCMXCIV"
解释: M = 1000, CM = 900, XC = 90, IV = 4.
```

### √（50m） [13. 罗马数字转整数](https://leetcode-cn.com/problems/roman-to-integer/)

罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。
    
    **字符** **数值** I 1 V 5 X 10 L 50 C 100 D 500 M 1000

例如， 罗马数字 2 写做 `II` ，即为两个并列的 1。12 写做 `XII` ，即为 `X` + `II` 。 27 写做  `XXVII`, 即为 `XX` + `V` + `II` 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：

  * `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。
  * `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 
  * `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。

给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。

```
示例 1:

输入: "III"
输出: 3

示例 2:

输入: "IV"
输出: 4

示例 3:

输入: "IX"
输出: 9

示例 4:

输入: "LVIII"
输出: 58
解释: L = 50, V= 5, III = 3.

示例 5:

输入: "MCMXCIV"
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.

```

### √（30m） [14. 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

```
示例 1:

输入: ["flower","flow","flight"]
输出: "fl"

示例 2:

输入: ["dog","racecar","car"]
输出: ""
解释: 输入不存在公共前缀。

```

所有输入只包含小写字母 `a-z` 。


### (30m) [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![](https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png)

**示例:**
```  
    输入："23" 
    输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]. 
```

###  [6. 最接近的三数之和](https://leetcode-cn.com/problems/3sum-closest/)

难度中等627

给定一个包括 _n_ 个整数的数组 `nums`_ _和 一个目标值 `target`。找出 `nums`_ _中的三个整数，使得它们的和与 `target` 最接近。返回这三个数的和。假定每组输入只存在唯一答案。

```
示例：

输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。
```

### √ (2.5h) 42. 接雨水

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

![](https://cdn.jsdelivr.net/gh/sunqinghu/PicRepo/img/2020/20201023174142.png)

上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。

```
示例:

输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
```




```python
class Solution:
    def onelist(self, List):
        Dict1 = {}
        for i in range(len(List)):
            if List[i] not in Dict1:
                Dict1[List[i]]=[i] 
            else:
                Dict1[List[i]].append(i)
        Dict1 = dict(sorted(Dict1.items(), key=lambda Dict1:Dict1[0], reverse=True)) # 字典排序方法
        print(Dict1)        
        
        rainNum = 0
        p = 0
        for num, i in Dict1.items():
            for j in i:
                print('******\n',num,j)
                if j <= p:
                    continue
                count = num*(j-p-1)-sum(List[i] for i in range(p+1,j))
                print('p=',p,'count=',count)
                p = j
                rainNum += count
                print('p=',p,'rain=',rainNum)

        return rainNum
           
        
    def trap(self, height):
        nums = height
        if len(nums)==0: return 0
        max_num = max(nums)
        i_max = nums.index(max_num)
        list1 = nums[:i_max+1]
        list1.reverse()
        list2 = nums[i_max:]
        
        out1 = self.onelist(list1)
        out2 = self.onelist(list2)
        return out1 + out2
```


```python
nums = [0,1,0,2,1,0,1,3,2,1,2,1]
solution = Solution()
result = solution.trap(nums)
result
```

### √ (1.5h) 146. LRU缓存机制

运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。

获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。
写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。

 

进阶:

你是否可以在 O(1) 时间复杂度内完成这两种操作？


```
示例:

LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // 返回  1
cache.put(3, 3);    // 该操作会使得关键字 2 作废
cache.get(2);       // 返回 -1 (未找到)
cache.put(4, 4);    // 该操作会使得关键字 1 作废
cache.get(1);       // 返回 -1 (未找到)
cache.get(3);       // 返回  3
cache.get(4);       // 返回  4
```


```python
class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cacheDict = dict()
        self.st = []  #???????
        
    def get(self, key: int) -> int:
        if  (key not in self.cacheDict.keys()): 
            return -1
        while key in self.st:    # 注意要删除重复值
            self.st.remove(key) # remove() 是删除指定值 
        self.st.append(key)
        return self.cacheDict[key]

    def put(self, key: int, value: int) -> None:
        if len(self.cacheDict) >= self.capacity and key not in self.cacheDict.keys():
            self.cacheDict.pop(self.st[-self.capacity]) 
        self.cacheDict[key] = value
        while key in self.st:
            self.st.remove(key) # remove() 是删除指定值 
        self.st.append(key)
        return 

# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)
```


```python
obj = LRUCache(1)
obj.put(0,1)
param_1 = obj.get(0)
print(param_1)
obj.put(2,2)
```

### 

### √ 56. 合并区间

给出一个区间的集合，请合并所有重叠的区间。

```
示例 1:

输入: [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
示例 2:

输入: [[1,4],[4,5]]
输出: [[1,5]]
解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。
```


```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort(key=lambda x:x[0])
        
        merged = []
        for interval in intervals:
            if not merged or merged[-1][1] < interval[0]:
                merged.append(interval)
            else:
                merged[-1][1] = max(merged[-1][1], interval[1])
                
        return merged
```

#### (10m)2️⃣  


```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        if intervals == []: return []
        intervals.sort()

        ans = [intervals[0]]
        for i in range(len(intervals)):
            if ans[-1][1] < intervals[i][0]:
                ans.append(intervals[i])
            else: 
                ans[-1][1] = max(ans[-1][1], intervals[i][1])   # 合并的方法        
        return ans
```


```python
from typing import List

nums = [[1,3],[2,6],[8,10],[15,18]]
solution = Solution()
result = solution.merge(nums)
result
```

### (1h) 46. 全排列

#### 数组深拷贝、浅拷贝

       res.append(path[:])  # 注意相当于这里做一次拷贝。否则输出为全空


```python
# 浅拷贝, 指向同一地址
a = [2,3,34,4]
b = a
a.append(222)
a, b
```


```python
# 深拷贝， 不同地址
a = [2,3,34,4]
b = a[:]
c = list(a)
d = a*1
import copy
e = copy.copy(a)
a.append(222)
a, b, c, d, e
```

#### 回溯算法（回溯搜索算法）  

1. 深度优先遍历的特有的现象，节约空间  
   全排列思路：  
   在枚举第一位的时候，有 3 种情况。  
   在枚举第二位的时候，前面已经出现过的数字就不能再被选取了；  
   在枚举第三位的时候，前面 2 个已经选择过的数字就不能再被选取了。  
   ![image.png](https://pic.leetcode-cn.com/0bf18f9b86a2542d1f6aa8db6cc45475fce5aa329a07ca02a9357c2ead81eec1-image.png)
   ![](https://pic.leetcode-cn.com/6a464ba95a7ad1c247aa39610535984c241e6b95148f8bc36b02908a190b1d54-image.png)

第 1 步都是先画图，画图是非常重要的，只有画图才能帮助我们想清楚递归结构，想清楚如何剪枝

步骤，即在画图的过程中思考清楚：

1、分支如何产生；

2、题目需要的解在哪里？是在叶子结点、还是在非叶子结点、还是在从跟结点到叶子结点的路径？

3、哪些搜索是会产生不需要的解的？例如：产生重复是什么原因，如果在浅层就知道这个分支不能产生需要的结果，应该提前剪枝，剪枝的条件是什么，代码怎么写？

给定一个 没有重复 数字的序列，返回其所有可能的全排列。

示例:

```
输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```


```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        def dfs(nums, size, depth, path, used, res):
            if depth == size:
                res.append(path[:])  # 注意相当于这里做一次拷贝。否则输出为全空
                return
            
            for i in range(size):  
                if not used[i]:
                    used[i] = True
                    path.append(nums[i]) # 添加到路径
                    
                    dfs(nums, size, depth+1, path, used, res)
                    
                    used[i] = False
                    path.pop()  # 从路径取出
                    
        size = len(nums)
        if len(nums) == 0:
            return []
        
        used = [False for _ in range(size)]
        res = []
        dfs(nums, size, 0, [], used, res)
        return res

```

#### 2️⃣  


```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        if depth == size:
            res.append(path[:])
            return 
        
        for i in range(size):
            if not used[i]:
                used[i] = True
                path.append(nums[i])
                
                dfs(nums, size, depth+1, path, used, res)
                
                used[i] = False
                path.pop()
                
        size = len(nums)
        if size == 0:
            return []
        
        used = [False for _ in range(size)]
        res = []
        dfs(nums, size, 0, [], used, res)
        return res
        
```


```python
from typing import List

nums = [1,2,4]
solution = Solution()
result = solution.permute(nums)
result
```

### (2h) 31. 下一个排列

实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

```
以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
```

算法思路：

1. 将后面的大数与前面的小数字交换
2. 增加幅度尽量小
   1. 低位交换，从后向前找 √
   2. 找尽量接近（小）的大数替换 √
   3. 重置为升序排序 


```python
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        if len(nums) < 2: return 0
        for i in range(len(nums)-1,0,-1):
            if nums[i] > nums[i-1]: 
                nums[i:] = sorted(nums[i:])  
                for j in range(i, len(nums)):
                    if nums[j] > nums[i-1]:  # 找最接近的进行替换
                        nums[j], nums[i-1] = nums[i-1], nums[j]
                        break
                return
        nums.sort()
```


```python
from typing import List

nums = [1,3,2]
solution = Solution()
result = solution.nextPermutation(nums)
result
```

### √ (1.5h) 135. 分发糖果

老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。

你需要按照以下要求，帮助老师给这些孩子分发糖果：

每个孩子至少分配到 1 个糖果。
相邻的孩子中，评分高的孩子必须获得更多的糖果。
那么这样下来，老师至少需要准备多少颗糖果呢？

```
示例 1:

输入: [1,0,2]
输出: 5
解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。
示例 2:

输入: [1,2,2]
输出: 4
解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这已满足上述两个条件。
```

#### 标准数组生成字典及字典排序方法


```python
# 自己做的，有点慢
class Solution:
    def candy(self, ratings: List[int]) -> int:
        if len(ratings) == 1: return 1
        # list to dict 用列表生成字典方法
        ratings_dict = {}  
        for i in range(len(ratings)):
            if ratings[i] not in ratings_dict.keys(): 
                ratings_dict[ratings[i]] = [i]
            else:
                ratings_dict[ratings[i]].append(i)
#         print(ratings_dict)
        # sort
        ratings_sorted = dict(sorted(ratings_dict.items(), key = lambda ratings_dict:ratings_dict[0])) # 字典排序方法
        print(ratings_sorted)
        
        cnt = 0
        candy = [0 for _ in range(len(ratings))]
        for key, indexs in ratings_sorted.items():
#             if cnt == 0: 
#                 candy[index] = 1 for index in indexs
#                 cnt = 1
#                 continue
            temps = []
            for index in indexs:
                if index == 0: 
                    temps.append(candy[index+1] + 1) 
                    continue
                if index == len(candy)-1: 
                    temps.append(candy[index-1] + 1)
                    continue
                temps.append(max(candy[index-1], candy[index+1]) + 1)
            cnt = 0
            for i in range(len(indexs)):
                candy[indexs[i]] = temps[i]   # 同时赋值
        return sum(candy)
```


```python
from typing import List

nums = [1,0,2,2]
solution = Solution()
result = solution.candy(nums)
result
```

#### 满足左原则和满足右原则（贪心）

从左向右一次， 从右向左一次，    取最大




```python
class Solution:
    def candy(self, ratings: List[int]) -> int:
        left = [1 for _ in range(len(ratings))]
        right = left[:]
        for i in range(1, len(ratings)):
            if ratings[i] > ratings[i - 1]: left[i] = left[i - 1] + 1
        count = left[-1]
        for i in range(len(ratings) - 2, -1, -1):
            if ratings[i] > ratings[i + 1]: right[i] = right[i + 1] + 1
            count += max(left[i], right[i])
        return count

```

### (1h) 440. 字典序的第K小数字

给定整数 n 和 k，找到 1 到 n 中字典序第 k 小的数字。

注意：1 ≤ k ≤ n ≤ 109。

```
示例 :

输入:
n: 13   k: 2

输出:
10

解释:
字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。
```


```python
class Solution:
    def findKthNumber(self, n: int, k: int) -> int:
        # prefix 前缀 n 上界
        p = 1
        prefix = 1
            
        while p < k:
            count += next_prefix - cur
            cur *= 10   # 10
            next_prefix *= 10  # 20
            
        return count
            
            
```


```python
from typing import List

nums = 
solution = Solution()
result = solution.maxArea(nums)
result
```

### 200. 岛屿数量

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

 

```
示例 1:

输入:
[
['1','1','1','1','0'],
['1','1','0','1','0'],
['1','1','0','0','0'],
['0','0','0','0','0']
]
输出: 1
示例 2:

输入:
[
['1','1','0','0','0'],
['1','1','0','0','0'],
['0','0','1','0','0'],
['0','0','0','1','1']
]
输出: 3
解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。
```



## 数组

* 有限个**类型相同**的元素的**有序序列**

### √ 3.寻找最长无重复字符串(看答案写上) 
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 
```
shi'li：
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

```

#### 集合移除左半部分方法
```python
while s[i] in lookup:
    lookup.remove(s[left])
```


```python
# 自己写的
s = "abcabcbb"
lists = list(s)
start = 0
end = 0
noduplicate = []
length_max = 0
for i, item in enumerate(lists,1):
    if item not in noduplicate:
        length_new = i - start
        noduplicate.append(item)
        if length_new > length_max:
            length_max = length_new        
    else:
        start += noduplicate.index(item) + 1
length_max
```


```python
# 主要思想:滑动窗口 
s = "abcabcbb"
# s = "abca"
# s = "pwwkew"

class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        if not s: 0
        left = 0
        lookup = set()
        n = len(s)
        max_len = 0
        cur_len = 0
        for i in range(n):
            cur_len += 1
            while s[i] in lookup:
                lookup.remove(s[left])
                left += 1
                cur_len -= 1
            if cur_len > max_len:max_len = cur_len
            lookup.add(s[i])  # 新建了一个滑动窗口
        return max_len


solution = Solution() # 实例化!!!!!
solution.lengthOfLongestSubstring(s)
print((solution.lengthOfLongestSubstring(s)))
```

### ✔155. 最小栈
设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。

push(x) -- 将元素 x 推入栈中。
pop() -- 删除栈顶的元素。
top() -- 获取栈顶元素。
getMin() -- 检索栈中的最小元素。
```
示例:

MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```


```python
# 核心思想: 定义辅助栈helper() 提升查找最小值速度
class MinStack:

    def __init__(self):
        """
        initialize your data structure here.
        """
        self.mylist = []
        self.helper = []

    def push(self, x: int) -> None:
        self.mylist.append(x)
        if len(self.helper) == 0 or x <= self.helper[-1]:
            self.helper.append(x)

    def pop(self) -> None:
        top = self.mylist.pop()
        if self.helper and top == self.helper[-1]:
            self.helper.pop()
        return top

    def top(self) -> int:
        return self.mylist[-1]

    def getMin(self) -> int:
        # 注意此处不能是等于 否则会改变一个另一个也会变
        if self.helper:
             return self.helper[-1]
           


# Your MinStack object will be instantiated and called as such:
obj = MinStack()
obj.push(-2)
obj.push(0)
obj.push(-3)
# obj.mylist
# print(obj.getMin())
# obj.pop()
obj.mylist
# print(obj.top())
print((obj.getMin()))
```

### √ 169. 多数元素
给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。
```

示例 1:

输入: [3,2,3]
输出: 3
示例 2:

输入: [2,2,1,1,1,2,2]
输出: 2
```


```python
# 排序法,自己写的
class Solution:
    def majorityElement(self, nums) -> int:
        nums.sort()
        return nums[(len(nums)-1)//2]
        
nums = [2,2,1,1,1,2,2]
solution = Solution()
result = solution.majorityElement(nums)
print(result)
```


```python
# Boyer-Moore 投票算法
class Solution:
    def majorityElement(self, nums) -> int:
        count = 0
        candidate = None
        for num in nums:
            if count == 0:
                candidate = num
            count += (1 if num == candidate else -1)
        
        return candidate
        
        
nums = [2,2,1,1,1,2,2]
solution = Solution()
result = solution.majorityElement(nums)
print(result)
```

### √ 283. 移动零 
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

```
示例:

输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
说明:

必须在原数组上操作，不能拷贝额外的数组。
尽量减少操作次数。
```



```python
# 自己写的,费时 数组操作
class Solution:
    def moveZeroes(self, nums) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        count = 0
        while True:
            try:
                nums.remove(0)
                count += 1

            except:
                nums.extend([0]*count)
                break
        
nums = [0,1,0,3,12]
solution = Solution()
result = solution.moveZeroes(nums)
nums
```


```python
# 法2: 一次遍历,双指针,检测到0则交换,省时间
class Solution:
    def moveZeroes(self, nums) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        if not nums:
            return 0
        j = 0
        for i in range(len(nums)):
            if nums[i] != 0:   # 只有nums[i] != 0 时,j才会加1往前走
                nums[j],nums[i] == nums[i],nums[j]
                j += 1 
                
nums = [0,1,0,3,12]
solution = Solution()
result = solution.moveZeroes(nums)
nums
```

### √ 461. 汉明距离 
两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。

给出两个整数 x 和 y，计算它们之间的汉明距离。

注意：
0 ≤ x, y < 2^31.
```
示例:

输入: x = 1, y = 4

输出: 2

解释:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑  ↑

上面的箭头指出了对应二进制位不同的位置。
```


```python
class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        return bin(x^y).count('1')  # .count()  计数
        
x = 1
y = 14
solution = Solution()
result = solution.hammingDistance(x,y)
result
```

### √ 581. 最短无序连续子数组

**注意中括号[]不能随便用,要表示先后关系只能用()**

给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。

你找到的子数组应是最短的，请输出它的长度。
```
示例 1:

输入: [2, 6, 4, 8, 10, 9, 15]
输出: 5
解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。
说明 :

输入的数组长度范围在 [1, 10,000]。
输入的数组可能包含重复元素 ，所以升序的意思是<=。
```


```python

```


```python
class Solution:
    def findUnsortedSubarray(self, nums) -> int:
        nums_sorted = sorted(nums)
        print((nums,nums_sorted))
        if not [(nums > nums_sorted) - (nums < nums_sorted)]:
            return 0  
        else:
            end = 0
            start = 0
            for i in range(len(nums)):
                if nums[i] != nums_sorted[i]:
                    start = i
                    break
            for i in range(1,len(nums)):
                if nums[-i] != nums_sorted[-i]:
                    end = len(nums)-i
                    break

            length = end - start + 1
            return length

    
# nums = [2,6,4,8,9,22,15]
nums = [1,2,3,4]
solution = Solution()
result = solution.findUnsortedSubarray(nums)
result
```

### [困难，未做]4. 寻找两个有序数组的中位数 
给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。

请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 nums1 和 nums2 不会同时为空。
``` python
示例 1:

nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0
示例 2:

nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5
```


#### 2️⃣ 


```python
nums1 = [1, 2]
nums2 = [3, 4]

```


```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        
```


```python
solution = Solution()
result = solution.findMedianSortedArrays(nums1,nums2)
result
```

### √(1h) [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

给你两个有序整数数组 _nums1 _和 _nums2_，请你将 _nums2 _合并到 _nums1 _中_，_使 _nums1 _成为一个有序数组。

 

**说明：**

  * 初始化 _nums1_ 和 _nums2_ 的元素数量分别为 _m_ 和 _n _。
  * 你可以假设 _nums1 _有足够的空间（空间大小大于或等于 _m + n_）来保存 _nums2_ 中的元素。

 

**示例：**
```
输入：
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出：[1,2,2,3,5,6]·
```


```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        i = m-1
        j = n-1
        while i>=0 and j>=0:
            if nums1[i] < nums2[j]:
                nums1[i+j+1] = nums2[j]
                j -= 1
            else:
                nums1[i+j+1] = nums1[i]
                i -= 1
        if j>=0:
            nums1[:j+1] = nums2[:j+1]


```


```python
# 法2
# 注意用深拷贝
        nums1[:] = nums1[:m] + nums2
        nums1.sort()
```

### 33. 搜索旋转排序数组

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。

搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。

你可以假设数组中不存在重复的元素。

你的算法时间复杂度必须是 O(log n) 级别。

```
示例 1:

输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4
示例 2:

输入: nums = [4,5,6,7,0,1,2], target = 3
输出: -1
```


#### 2️⃣


```python
# logn → 二分法
class Solution:
    def search(self, nums, target: int) -> int:
        if not nums:
            return -1
        l, r = 0, len(nums) - 1
        while l <= r:
            mid = (l + r)//2
            if nums[mid] == target: return mid
            if nums[mid] > nums[0]:  # 边界条件是最左最右
                if nums[0] <= target < nums[mid]:  # 注意有等于
                    r = mid - 1
                else:
                    l = mid + 1
            else:
                if nums[len(nums)-1] >= target > nums[mid] :
                    l = mid + 1
                else: 
                    r = mid - 1
        return  -1
                
```


```python
from typing import List

nums = [4,5,6,7,0,1,2]
solution = Solution()
result = solution.search(nums, 0)
result
```

### √ (6m) 215. 数组中的第K个最大元素

在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

```
示例 1:

输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
示例 2:

输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
说明:

你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。
```


```python
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        nums.sort(reverse=True)
        return nums[k-1]
```


```python
from typing import List

nums = [3,2,1,5,6,4] 
solution = Solution()
result = solution.findKthLargest(nums ,2)
result
```

### 

## 堆栈stack

### 20. 有效的括号
**注意: range(x)取不到x**

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。


``` 
示例 1:
输入: "()"
输出: true
示例 2:

输入: "()[]{}"
输出: true
示例 3:

输入: "(]"
输出: false
示例 4:

输入: "([)]"
输出: false
示例 5:

输入: "{[]}"
输出: true

```


```python
# s = "()[]{}"
# s = "{[]}"
# s = "()"
s = ")]"
# s = "([)]"
s[-1]
len(s)/2
```


```python
# answer
# 主要思想:堆栈stack
class Solution(object):
    def isValid(self, s):
        """
        :type s: str
        :rtype: bool
        """

        # The stack to keep track of opening brackets.
        stack = []

        # Hash map for keeping track of mappings. This keeps the code very clean.
        # Also makes adding more types of parenthesis easier
        mapping = {")": "(", "}": "{", "]": "["}

        # For every bracket in the expression.
        for char in s:

            # If the character is an closing bracket
            if char in mapping:

                # Pop the topmost element from the stack, if it is non empty
                # Otherwise assign a dummy value of '#' to the top_element variable
                top_element = stack.pop() if stack else '#'

                # The mapping for the opening bracket in our hash and the top
                # element of the stack don't match, return False
                if mapping[char] != top_element:
                    return False
            else:
                # We have an opening bracket, simply push it onto the stack.
                stack.append(char)

        # In the end, if the stack is empty, then we have a valid expression.
        # The stack won't be empty for cases like ((()
        return not stack
```


```python
solution = Solution() # 实例化!!!!!
solution.isValid(s)
```


```python
# try2:
class Solution:
    def isValid(self, s: str) -> bool:
        dec = {  '(': ')',
               '{': '}', 
               '[': ']' }
        s = list(s)
        print(s)
        if len(s) == 0:return True
        if (len(s) % 2) == 1:return False # 奇数个时  

#     def cellpop()
    
        while s:
            for i in range(int(len(s)/2)):  # 注意range(x)取不到x 
                print(i)
                if s[i] in dec:
                    if dec[s[i]] == s[i+1]:
                        s.pop(i+1)
                        s.pop(i)
                        print(('s=',s))
                        break
                    else:pass
            else:
                print('wrong')
                return False
        return True
```


```python
# try1:
class Solution:
    def isValid(self, s: str) -> bool:
        if len(s) == 0:return True
        if (len(s) % 2) == 1:return False # 奇数个时      
        left = s[0]
        right_exp = dec[s[0]]
        right_ind = s.index(right_exp)
        if (s.index % 2) == 0:return False 
        else:
            s_cell = s[1:(s.index-1)]
            symbolcell(s_cell)
        print(left,right_exp,right_ind)
    
    def symbolcell(self, s_cell):
        for i in range(len(s_cell)-1):
```


```python
nums1 = [1, 2] 
nums2 = [3, 4]

```

## 链表

### 总结

1. 链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。链表有很多种不同的类型：单向链表，双向链表以及循环链表。
链表通常可以衍生出循环链表，静态链表，双链表等。对于链表使用，需要注意头结点的使用。

```
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
```
2. 
链表中的“哨兵”节点是解决边界问题的，不参与业务逻辑。如果我们引入“哨兵”节点，则不管链表是否为空，head指针都会指向这个“哨兵”节点。我们把这种有“哨兵”节点的链表称为带头链表，相反，没有“哨兵”节点的链表就称为不带头链表。


#### 基于python的自建链表类（list to linklist）


```python
# 自建库
# Definition for singly-linked list.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
    def initList(self, data):
        # 判断是否为空
        if len(data) == 0:
            return
        else:
            # 创建头结点
            self.head = ListNode(data[0])
            # 头结点
            r = self.head  
            # 指针 
            p = self.head   
            # 逐个为 data 内的数据创建结点, 建立链表
            for i in data[1:]:
                node = ListNode(i)
                p.next = node
                p = p.next
            return r
        
    def linklist2List(self, linklist):
        List = []

        while linklist:
            List.append(linklist.val)
            linklist = linklist.next
        return List
```


```python
# 使用
l1 = [1,2,4]
l2 = [1,3,4]

List2Linklist = ListNode()
l1 = List2Linklist.initList(l1)
l2 = List2Linklist.initList(l2)

print(l1.val, "->", l1.next.val, "->", l1.next.next.val)
print(l2.val, "->", l2.next.val, "->", l2.next.next.val)
print(List2Linklist.linklist2List(l1))
# List2Linklist.printLinklist(result)
```


```python

```

#### 哨兵节点使用

把`prev`期初所在的位置命名为`prehead`，这样`prev`再怎么变都可以找到其起始地址。

```python
prehead = ListNode(-1)  # 哨兵节点，让我们容易的返回合并后的链表
prev = prehead  # prev指针，我们调整它的next指针，直到l1或者l2某一个指向了NULL

···

return prehead.next # 返回入口地址

```

<img src="/img/in-post/20_07/image-20210108091928739.png" alt="image-20210108091928739" style="zoom:50%;" />

#### Python的ListNode类

```python
# Definition for singly-linked list.
class ListNode:
  def __init__(self, val=0, next=None):
    self.val = val
    self.next = next
```



### 21. 合并两个有序链表 

将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
```
示例：

输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4

```

<img src="/img/in-post/20_07/image-20210107215233267.png" alt="image-20210107215233267" style="zoom:50%;" />









#### 2️⃣  (1.5h)


```python
# 标准
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        # maintain an unchanging reference to node ahead of the return node.
        prehead = ListNode(-1)  # 哨兵节点，让我们容易的返回合并后的链表

        prev = prehead  # prev指针，我们调整它的next指针，直到l1或者l2某一个指向了NULL
        while l1 and l2:
            if l1.val <= l2.val:
                prev.next = l1
                l1 = l1.next  # 注意l1的指针也要移动
            else:
                prev.next = l2
                l2 = l2.next
            prev = prev.next  # 指向下一个值
        prev.next = l1 if l1 is not None else l2
        
        return prehead.next # 返回入口地址
```


```python
l1 = [1,2,4]
l2 = [1,3,4]

List2Linklist = ListNode()
l1 = List2Linklist.initList(l1)
l2 = List2Linklist.initList(l2)

solution = Solution()
result = solution.mergeTwoLists(l1,l2)

print(l1.val, "->", l1.next.val, "->", l1.next.next.val)
print(l2.val, "->", l2.next.val, "->", l2.next.next.val)
print(List2Linklist.linklist2List(result))
# List2Linklist.printLinklist(result)
```

###  206. 反转链表

反转一个单链表。
```
示例:

输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```
进阶:
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？



```python
class Solution(object):
	def reverseList(self, head):
		"""
		:type head: ListNode
		:rtype: ListNode
		"""
		# 申请两个节点，pre和 cur，pre指向None
		pre = None
		cur = head
		# 遍历链表，while循环里面的内容其实可以写成一行
		# 这里只做演示，就不搞那么骚气的写法了
		while cur:
			# 记录当前节点的下一个节点
			tmp = cur.next
			# 然后将当前节点指向pre
			cur.next = pre
			# pre和cur节点都前进一位
			pre = cur
			cur = tmp
		return pre	

```

#### 2️⃣ (1.5h) 


```python
class Solution(object):
    def reverseList(self, head):
        pre = None
        cur = head
        while cur:
            temp = cur.next
            cur.next = pre  # 反转指针操作
            pre = cur 
            cur = temp
        return pre
```


```python
List = [1,2,3,4,5]
List2Linklist = ListNode()
l1 = List2Linklist.initList(List)
print(l1.val, "->", l1.next.val, "->", l1.next.next.val)
from typing import List

solution = Solution()
result = solution.reverseList(l1)
result
print(result.val, "->", result.next.val, "->", result.next.next.val)
```



### √ (15m) 

请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。

现有一个链表 -- head = [4,5,1,9]，它可以表示为:
![image.png](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/01/19/237_example.png)




```
示例 1:

输入: head = [4,5,1,9], node = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
示例 2:

输入: head = [4,5,1,9], node = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.

```


```python
class Solution:
    def deleteNode(self, node):
        """
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        """
        node.val = node.next.val
        node.next = node.next.next
```

### √(50m) 203. 移除链表元素
删除链表中等于给定值 val 的所有节点。

```
示例:

输入: 1->2->6->3->4->5->6, val = 6
输出: 1->2->3->4->5
```

哨兵节点广泛应用于树和链表中，如伪头、伪尾、标记等，它们是纯功能的，通常不保存任何数据，其主要目的是使链表标准化，如使链表永不为空、永不无头、简化插入和删除。

![image.png](https://pic.leetcode-cn.com/c650a78cb34caf9a00469651abfc14181c474e2c6152e87273092e7dfd331f19-file_1578026286317)

在这里哨兵节点将被用于伪头。




```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def removeElements(self, head: ListNode, val: int) -> ListNode:        
        if not head: return None
        while head and head.val == val:
            if head.next: head = head.next
            else: 
                head.next = None
                return None


        prehead = head

        while head.next:
            if head.next.val == val and head.next.next:
                head.next = head.next.next
            elif  head.next.val == val and not head.next.next:
                head.next = None
            else:
                head = head.next
        return prehead
        
```


```python
# 官方

class Solution:
    def removeElements(self, head: ListNode, val: int) -> ListNode:
        sentinel = ListNode(0) # 哨兵节点
        sentinel.next = head
        
        prev,curr = sentinel,head
        while curr:
            if curr.val == val:  #  双指针，如果curr删除，prev同时移动
                prev.next == curr.next
            else:
                prev = curr
            curr = curr.next
            
        return sentinel.next
```

### (20m)234. 回文链表
请判断一个链表是否为回文链表。

```
示例 1:

输入: 1->2
输出: false
示例 2:

输入: 1->2->2->1
输出: true
进阶：
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？
```


```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        
            
```


```python
# 官解，数组
def isPalindrome(self, head: ListNode) -> bool:
    vals = []
    current_node = head
    while current_node is not None:
        vals.append(current_node.val)
        current_node = current_node.next
    return vals == vals[::-1]


```


```python
# 官解，反转后半部分链表
# 方法三：
# 避免使用 O(n)O(n) 额外空间的方法就是改变输入。

# 我们可以将链表的后半部分反转（修改链表结构），然后将前半部分和后半部分进行比较。比较完成后我们应该将链表恢复原样。虽然不需要恢复也能通过测试用例，因为使用该函数的人不希望链表结构被更改。

# 算法：

# 我们可以分为以下几个步骤：

# 找到前半部分链表的尾节点。
# 反转后半部分链表。
# 判断是否为回文。
# 恢复链表。
# 返回结果。
```

### √(50m) 2. 两数相加
给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

```
示例：

输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807
```


```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:

        prehead = ListNode(-1)
        newlinklist = prehead

        carry = 0
        while l1 and l2:
            newlinklist.next = ListNode((l1.val+l2.val + carry)%10)  # 新建linklist的方法，注意不能linklist.val == 
            newlinklist = newlinklist.next
            carry = (l1.val+l2.val + carry)//10
            l1, l2 = l1.next, l2.next
        while l1 and l2 is None:
            newlinklist.next = ListNode((l1.val + carry)%10)
            newlinklist = newlinklist.next
            carry = (l1.val + carry)
            l1 = l1.next
        while l2 and l1 is None:
            newlinklist.next = ListNode((l2.val + carry)%10)
            newlinklist = newlinklist.next
            carry = (l2.val + carry)
            l2 = l2.next
        if carry == 1: newlinklist.next = ListNode(carry) 
        return prehead.next
                

```




```python

```


```python

```


```python

```


```python

```

### √ 206. 反转链表

反转一个单链表。

```
示例:

输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

进阶:
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？



```python
class Solution(object):
	def reverseList(self, head):
		"""
		:type head: ListNode
		:rtype: ListNode
		"""
		# 申请两个节点，pre和 cur，pre指向None
		pre = None
		cur = head
		# 遍历链表，while循环里面的内容其实可以写成一行
		# 这里只做演示，就不搞那么骚气的写法了
		while cur:
			# 记录当前节点的下一个节点
			tmp = cur.next
			# 然后将当前节点指向pre
			cur.next = pre
			# pre和cur节点都前进一位
			pre = cur
			cur = tmp
		return pre	

```

#### (30m)2️⃣ 


```python
class Solution(object):
    def reverseList(self, head):
        cur = head  # 注意是从head开始
        pre = None
        while cur:
            nexttmp = cur.next
            cur.next = pre
            
            pre = cur 
            cur = nexttmp
        return pre  # 返回的是起始点
```

### 25. K 个一组翻转链表

给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。

k 是一个正整数，它的值小于或等于链表的长度。

如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。


```
示例：

给你这个链表：1->2->3->4->5

当 k = 2 时，应当返回: 2->1->4->3->5

当 k = 3 时，应当返回: 3->2->1->4->5
```

说明：

你的算法只能使用常数的额外空间。
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。


```python
class Solution:
    def reverseList(self, head):

        while cur:
            nexttmp = cur.next
            cur.next = pre
            
            pre = cur 
            cur = nexttmp
        return pre  # 返回的是起始点    
    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:
        cur = head  # 注意是从head开始
        pre = None
        reverseList()
```

### 23. 合并K个排序链表

合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。

示例:

```
输入:
[
  1->4->5,
  1->3->4,
  2->6
]
输出: 1->1->2->3->4->4->5->6
```

### 

## 递归 

### 70. 爬楼梯(程序自己写)  
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。
```
示例 1：

输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
示例 2：

输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶

```


```python
# 暴力解法(递归, 状态空间)
class Solution:
    def climbStairs_step(self, i , n):
        global sum
        if i > n:
            return 
        if i == n:
            sum += 1
            return
        return self.climbStairs_step(i+1,n), self.climbStairs_step(i+2,n)
    
    def climbStairs(self, n: int) -> int: 
        global sum
        sum = 0
        self.climbStairs_step(0, n)
#         print(sum)
        return sum
```


```python
n = 5
solution = Solution()
result = solution.climbStairs(n)
print(result)
```


```python
# 记忆化递归(修复的递归树)  -- 未
```


```python
# 动态规划法: 到达第 ii 阶的方法总数就是到第 (i-1)(i−1) 阶和第 (i-2)(i−2) 阶的方法数之和。
# dp[i]=dp[i−1]+dp[i−2]
class Solution:
    def climbStairs(self, n):
        dp = [0,1,2]
        for i in range(3,n+1):
            dp.append(dp[i-2] + dp[i-1])
            
        return dp[n]
            
n = 10
solution = Solution()
result = solution.climbStairs(n)
print(result)
```


```python
# 斐波那契数
class Solution:
    def climbStairs(self, n):
        if n==1:return 1
        if n==2:return 2
        first = 1
        second = 2
        for i in range(3,n): 
            third = first + second
            first = second
            second = third
        return second
            
n = 10
solution = Solution()
result = solution.climbStairs(n)
print(result)
```

## √动态规划(11=9+2)

#### 一维动态规划核心思想:


动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即**子问题**），再根据子问题的解以得出原问题的解。

步骤：
    1. 确定初始条件
        
2. 讨论 最后加入最后一个元素 和 不加入最后一个元素 的情况， 建立动态规划数组dp

3. > 如：dp[i] = max(dp[i-1], dp[i-2] + nums[i-1])


要求：
* 只能处理没有相互依赖关系

####  二维动态规划
横向：加入新增商品价值 与 没加入该商品时最大价值（上一行） 比较，选择大的

大致上，若要解一个给定问题，**我们需要解其不同部分**（即子问题），再根据子问题的解以得出原问题的解。动态规划往往用于**优化递归问题**，例如斐波那契数列，如果运用递归的方式来求解会重复计算很多相同的子问题，利用动态规划的思想可以减少计算量。

公式
![](https://cdn.jsdelivr.net/gh/sunqinghu/PicRepo/img/2020/20201023173011.png)

【例1】背包问题
![](https://cdn.jsdelivr.net/gh/sunqinghu/PicRepo/img/2020/20201023173114.png)

【例2】旅游行程最优化

横向：加入新增商品价值 与 没加入该商品时最大价值（上一行） 比较，选择大的
![](https://cdn.jsdelivr.net/gh/sunqinghu/PicRepo/img/2020/20201023173157.png)

### √ 53. 最大子序和
2月18, 3:36 - 2月18, 4:41

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

```
示例:

输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
进阶:
```
如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。



```python
nums = [-2,1,-3,4,-1,2,1,-5,4]
max_sum = 0
for i in range(1,len(nums)):
    if nums[i-1] > 0:
        nums[i] = nums[i-1] + nums[i]
    max_sum = max(nums[i], max_sum)
max_sum
```


```python
# 贪心算法
nums = [-2,1,-3,4,-1,2,1,-5,4]
class Solution:
    def maxSubArray(self, nums: 'List[int]') -> 'int':
        n = len(nums)
        curr_sum = max_sum = nums[0]

        for i in range(1, n):
            curr_sum = max(nums[i], curr_sum + nums[i])
            max_sum = max(curr_sum, max_sum)

        return max_sum
    
solution = Solution()
result = solution.maxSubArray(nums)
print(result)
```


```python
# 动态规划 -- 实时改变数组
nums = [-2,1,-3,4,-1,2,1,-5,4]
class Solution:
    def maxSubArray(self, nums: 'List[int]') -> 'int':
        n = len(nums)
        max_sum = nums[0]

        for i in range(1, n):
            if nums[i-1] > 0:
                nums[i] += nums[i-1] 
            max_sum = max(nums[i], max_sum)

        return max_sum
    
solution = Solution()
result = solution.maxSubArray(nums)
print(result) 
```

### √ 70. 爬楼梯(程序自己写)  2/10 10:06 下午 - 2/11 11:40 上午
    2月18,5:36 - 2月18， 6：03

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。
```
示例 1：

输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
示例 2：

输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶

```


```python
# 动态规划法核心公式: 
# 加入最后一个台阶即：到达第 ii 阶的方法总数就是到第 (i-1)(i−1) 阶和第 (i-2)(i−2) 阶的方法数之和。
# dp[i]=dp[i−1]+dp[i−2]
```


```python
n = 5
dp = [1, 1]
for i in range(2,n+1):
    dp.append(dp[i-1] + dp[i-2])
dp
dp[-1]
```

#### 2️⃣ (7m)


```python
n=10
dp = [0, 1, 2]
for i in range(3,n+1):
    dp.append(dp[i-1] + dp[i-2])
dp
dp[-1]
```

### √ 121. 买卖股票的最佳时机
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。

注意你不能在买入股票前卖出股票。

``` python
示例 1:

输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
示例 2:

输入: [7,6,4,3,1]
输出: 0 
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```



```python
nums = [7,1,5,3,6,4]

num_min = nums[0]
profit = [0]

for i in range(1,len(nums)):
    num_min = min(nums[i], num_min)
    profit.append(max(nums[i] - num_min, profit[i-1]))
profit
profit[-1]
        
    
```

### √ 198. 打家劫舍
2月18, 4:54 - 2月18, 5:27

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

```
示例 1:

输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
示例 2:

输入: [2,7,9,3,1]
输出: 12
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

* 不能偷相邻的两栋房子，方案无非两种：
* 方案一：挑选的房子中包含最后一栋；
* 方案二：挑选的房子中不包含最后一栋；
* 获得的最大收益的最终方案，一定在这两种方案中产生


```python
# 核心思想:
# 动态规划公式:dp[i] = max(dp[i-1], dp[i-2] + nums[i-1])
# 不能偷相邻的两栋房子，方案无非两种：
# 方案一：挑选的房子中包含最后一栋；
# 方案二：挑选的房子中不包含最后一栋；
# 获得的最大收益的最终方案，一定在这两种方案中产生
nums = [2,7,9,3,1]
dp = []  # save the max_value in each length of given list
dp.extend([nums[0],max(nums[0],nums[1])])
```


```python
dp[1] = max(nums)
for i in range(2,len(nums)):
    dp.append(max(dp[i-1], dp[i-2]+nums[i]))
dp
dp[-1]
```

### (15m)303. 区域和检索 - 数组不可变
给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。

```
示例：

给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()

sumRange(0, 2) -> 1
sumRange(2, 5) -> -1
sumRange(0, 5) -> -3
```


```python
class NumArray:

    def __init__(self, nums: List[int]):
        self.nums = nums

    def sumRange(self, i: int, j: int) -> int:
        ans = sum(self.nums[i:j+1])
        return ans


# Your NumArray object will be instantiated and called as such:
# obj = NumArray(nums)
# param_1 = obj.sumRange(i,j)
```


```python
from typing import List

nums = [-2, 0, 3, -5, 2, -1]
solution = NumArray(nums)
result = solution.sumRange(2,5)
result

```


```python
# 官解 缓存法
class NumArray:

    def __init__(self, nums: List[int]):
        self.nums = nums

    def sumRange(self, i: int, j: int) -> int:
        ans = sum(self.nums[i:j+1])
        return ans

```

### √  (1.5h)  5. 最长回文子串
给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

```
示例 1：

输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
示例 2：

输入: "cbbd"
输出: "bb"
```


```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        if len(s)==0: return ""
        max_len_list = []
        for i in range(len(s)):
            if i==0: continue
            if s[i-1] == s[i]:
                j = 1
                while i-1-j>=0 and i+j<=len(s)-1 and s[i-1-j] == s[i+j]:
                    j += 1
                length = 2*j 
                if length > len(max_len_list):
                    max_len_list = s[i-j:i+j]       
            if i == len(s)-1: continue
            if s[i-1] == s[i+1]:
                j = 1
                while i-1-j>=0 and i+1+j<=len(s)-1 and s[i-1-j] == s[i+1+j]:
                    j += 1
                length = 2*j + 1
                if length > len(max_len_list):
                    max_len_list = s[i-j:i+j+1]
        if len(max_len_list)<=1: return s[0]
        return max_len_list
```


```python
# nums = "cbbd"
nums = "dd"
solution = Solution()
result = solution.longestPalindrome(nums)
result
```


```python
# 动态规划
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        dp =[[False] * n for _ in range(n)]
        ans = ""
        for l in range(n):
            for i in range(n):
                j = i+1
                if j >= len(s):
                    break
                if l == 0:
                    dp[i][j] = True
                elif l==1:
                    dp[i][j] = (s[i]==s[j])
                else:
                    dp[i][j]=(dp[i+1][j+1] and s[i]==s[j])
                if dp[i][j] and l+1 > len(ans):
                    ans = s[i:j+1]
            return ans
                
```

#### 2️⃣ (1.5h) 5. 最长回文子串
动态规划方程:`P(i,j)=P(i+1,j−1)∧(Si==Sj)`

动态规划的边界条件：`P(i,i)=true, P(i,i+1)=(Si ==Si+1)`

注意：在状态转移方程中，我们是从长度较短的字符串向长度较长的字符串进行转移的，因此一定要注意动态规划的循环顺序。
![](https://tva1.sinaimg.cn/large/007S8ZIlly1gjs5oeah1uj30zk0c2t9o.jpg)
![](https://tva1.sinaimg.cn/large/007S8ZIlly1gjs5vv9x00j30z40dm3zb.jpg)



```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        dp = [[False ]*n for i in range(n)]
        ans = ''
        l_ans, length = 0, 0
        for i in range(n):
            dp[i][i] = True 
        
        for r in range(1, n):
            for l in range(r):
                dp[l][r] = (s[l] == s[r]) and (dp[l+1][r-1] or r-l<3)
                if dp[l][r] and r-l+1 > length:
                    l_ans, length = l, r-l+1
        ans = s[l_ans:l_ans+length]
        return ans
```


```python
nums = "babab"
# nums = "dd"
solution = Solution()
result = solution.longestPalindrome(nums)
result
```

### √ (1.5h)  [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

难度中等718

一个机器人位于一个 _m x n _网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

问总共有多少条不同的路径？

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png)

例如，上图是一个7 x 3 的网格。有多少可能的路径？

```
示例 1:

输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右
示例 2:

输入: m = 7, n = 3
输出: 28
```


**提示：**

  * `1 <= m, n <= 100`

1. 动态转移方程: `dp[i,j] = dp[i-1,j] + dp[i,j-1]`
2. 边界条件: `dp[0,j]=dp[i,0]=1`

空间优化:
1. O(2n):`cur[j] = pre[j] + cur[j-1]` 
2. O(n):`cur[j] += cur[j-1]`


```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        dp = [[1] * n] + [[1] + [0 for _ in range(m-1)]]
        
        for i in range(1,m):
            for j in range(1,n):
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
                
        return dp[-1][-1]
```


```python
m, n = 3, 2
solution = Solution()
result = solution.uniquePaths(m, n)
result
```

### (2h)  [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

难度中等425

一个机器人位于一个 _m x n _网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png)

网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。

**说明：**_m_ 和 _n _的值均不超过 100。

**示例 1:**

```
输入:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
输出: 2
解释:
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```


```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        dp = [[1] * n] + [[1] + [0 for _ in range(m-1)]]
        
        for i in range(1,m):
            for j in range(1,n):
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
                
        return dp[-1][-1]
```


```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid) -> int:
        m = len(obstacleGrid)
        n = len(obstacleGrid[0])
        
        dp = [[0]*n for i in range(m)]
        
        for i in range(m):
            if obstacleGrid[i][0]==0:
                dp[i][0] = 1 
            else:
                break
        for i in range(n):
            if obstacleGrid[0][i]==0:
                dp[0][i] = 1 
            else:
                break   
        
        if m==1 or n==1:
            return dp[-1][-1]
        
        for i in range(1,m):
            for j in range(1,n):
                if obstacleGrid[i][j] > 0: dp[i][j] = 0
                else:    
                    dp[i][j] = dp[i-1][j] + dp[i][j-1]
                
        return dp[-1][-1]
```


```python
nums = [
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
solution = Solution()
result = solution.uniquePathsWithObstacles(nums)
result
```

### √(30m) [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

难度中等696

给定一个包含非负整数的 _m_ x _n_ 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

**示例:**
```
    
输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。    ```

1. 动态转移方程:`dp[i][j]=min(dp[i][j-1],dp[i-1][j])`
2. 边界条件`dp[0][0]=dp[0][0], dp[m][0]+=dp[m-1][0], dp[0][n]+=dp[0][n-1]`


​```python
class Solution:
    def minPathSum(self, grid) -> int:
        dp = grid
        m = len(dp)
        n = len(dp[0])
        
        dp[0][0]=dp[0][0]
        for i in range(1, m):
            dp[i][0]+=dp[i-1][0]
        for j in range(1, n):
            dp[0][j]+=dp[0][j-1]

        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] += min(dp[i][j-1],dp[i-1][j])

        return dp[-1][-1]
```


```python
nums = [
  [1,3,1],
  [1,5,1],
  [4,2,1]
    
]
solution = Solution()
result = solution.minPathSum(nums)
result
```

### (1.5h) (动态规划)72. 编辑距离

给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

插入一个字符
删除一个字符
替换一个字符


```
示例 1：

输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
示例 2：

输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')

```

#### 递归和动态规划

模式识别：一旦涉及子问题（状态转移），**就可以使用自顶向下的递归和自底向上的动态规划**  

#### 递归（自顶向下） -- 大量冗余操作

1. 定义递归出口
2. 最后字符相同，向前推以为
3. 否则，搜索插入删除替换动作


#### 动态规划（自底向上）：  

1. 构造初始解
2. 抽象状态转移方程，根据转移方程构造更上层的解
   ![](https://tva1.sinaimg.cn/large/007S8ZIlly1ggxgoz3c8bj30hk0520t0.jpg)


```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        
```


```python
from typing import List

nums = 
solution = Solution()
result = solution.maxArea(nums)
result = 
```

### (0.5h)32. 最长有效括号

给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

```
示例 1:

输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"
示例 2:

输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"
```

#### 栈的例子

栈底： stack=【-1】


```python
# 栈

class Solution:
    def longestValidParentheses(self, s: str) -> int:
        stack = [-1]
        length = 0
        max_length = 0
        for i in range(len(s)):
            if s[i] == '(':
                stack.append(i)  # 对于遇到的每个‘(’ ，我们将它的下标放入栈中
            else:   # 如果是’）‘
                stack.pop()  # 弹出栈顶，表示匹配了当前’）‘
                if stack == []:
                    stack.append(i) # 括号结束，记录结束位置（更新「最后一个没有被匹配的右括号的下标」）
                else:  # 如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」
                    length = i-stack[-1]
                    max_length = max(max_length,length)
            print(i, stack, '  \tmax_length=',max_length)
        return max_length
```


```python
from typing import List

nums = ")()())"
solution = Solution()
result = solution.longestValidParentheses(nums)
result

```

#### 10. 正则表达式匹配

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

说明:

s 可能为空，且只包含从 a-z 的小写字母。
p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。

```
示例 1:

输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
示例 2:

输入:
s = "aa"
p = "a*"
输出: true
解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
示例 3:

输入:
s = "ab"
p = ".*"
输出: true
解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
示例 4:

输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
示例 5:

输入:
s = "mississippi"
p = "mis*is*p*."
输出: false
```


```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        def Iter(s,p):
            if  s == [] and p == []:
                return True

            if (s[0] == p[0] or p[0] == '.') and p[1] != '*':
                s.pop(0)
                p.pop(0)
            if len(p) > 1:
                if p[0] == '.' and p[1] == '*':
                    p.pop(0)
                    p.pop(0)
                    for _ in range(len(s)):
                        Iter(s,p)
                        s.pop(0)
                if p[1] == '*':
                    findstr = p[0]
                    p.pop(0)
                    p.pop(0)
                    while len(s) != 0 and s[0] == findstr:
                        Iter(s,p)
                        s.pop(0)
        s = list(s)
        p = list(p)
        while not (s == [] and p == []):
            Iter(s,p)
        return False
                    
                    
                    
                
                
                
                
```


```python
from typing import List

s = "aab"
p = "aab"
solution = Solution()
result = solution.isMatch(s,p)
result
```

#### (0.5h) 2️⃣

### √  9. 回文数

判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

```
示例 1:

输入: 121
输出: true
示例 2:

输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
示例 3:

输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。
进阶:

你能不将整数转为字符串来解决这个问题吗？
```


```python
# 法1：自己写的 效率低
class Solution:
    def isPalindrome(self, num: int) -> bool:
        if num<0: return False
        c=0
        x = num
        while x != 0:
            x = x // 10
            c += 1
        print(c)
        num1 = num2 =num
        for i in range(c // 2):
            a = num1 % 10
            num1 = num1 //10
            
            b = num2 // 10**(c-1) % 10
            num2 = num2 * 10
            
            print(a, b)
            print(num1, num2)
            if  a != b: 
                return False
        return True
    
            
```


```python
from typing import List

nums = 11
solution = Solution()
result = solution.isPalindrome(nums)
result

```

#### int 整数翻转标准操作


```python
# 法2：
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if (x < 0 or (x % 10 == 0 and x != 0)) :
            return False
        revertedNumber = 0
        while(x> revertedNumber):
            revertedNumber = revertedNumber * 10 + x % 10  # int 数字翻转操作
            x = x // 10
            print(revertedNumber, x)
        return x == revertedNumber or x == revertedNumber //10
```


```python
from typing import List

nums = 113311
solution = Solution()
result = solution.isPalindrome(nums)
result

```


```python
s = "12"
s[:: -1]
int(s[1:])>0
```



## 深度优先搜索DFS

#### 步骤
1. 沿着树的深度遍历树的节点，尽可能深的搜索树的分支。
2. 当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。
3. 如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。

#### 概括
深度优先搜索的步骤分为 
1. 递归下去 
2. 回溯上来。

顾名思义，深度优先，则是以深度为准则，先一条路走到底，直到达到目标。这里称之为递归下去。

否则既没有达到目标又无路可走了，那么则退回到上一步的状态，走其他路。这便是回溯上来。

### (20m)  101. 对称二叉树
给定一个二叉树，检查它是否是镜像对称的。

```

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

    1
   / \
  2   2
 / \ / \
3  4 4  3
 

但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

    1
   / \
  2   2
   \   \
   3    3
 
 

进阶：

你可以运用递归和迭代两种方法解决这个问题吗？
```

#### 递归的思想
 如果同时满足下面的条件，两个树互为镜像：

1. 它们的两个根结点具有相同的值
2. 每个树的右子树都与另一个树的左子树镜像对称


```python
# guanjie
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if not root: return 
        return self.check(root.left, root.right)
        
    def check(self, left, right):
        if left is None and right is None: return True
        if left is None or right is None: return False
        if left.val != right.val : return False
        return self.check(left.left, right.right) and self.check(left.right, right.left)
        
        
            
```

### (60m)  394. 字符串解码
给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。

 

```
示例 1：

输入：s = "3[a]2[bc]"
输出："aaabcbc"
示例 2：

输入：s = "3[a2[c]]"
输出："accaccacc"
示例 3：

输入：s = "2[abc]3[cd]ef"
输出："abcabccdcdcdef"
示例 4：

输入：s = "abc3[cd]xyz"
输出："abccdcdcdxyz"
```

#### 栈和递归使用


```python
class Solution:
    def decodeString(self, s: str) -> str:
        def dfs(i):
            res, multi = "", 0
            while i<len(s):
                if '0' <= s[i] <= '9':
                    multi = multi*10 + s[i]
                elif s[i] == '[':
                    # 注意，返回i的含义是更新上层递归指针位置，因为内层递归已经吃掉一串str，若不跟新i，
                    # 外层仍然从i+1开始，则会重复处理内层处理过的一串str。
                    i, tmp = dfs(i+1)  
                    res += multi * tmp
                    multi = 0
                elif s[i] == ']':
                    return i,res
                else: res += s[i]
                i+=1
            return res
        return dfs(0)
```

###  105. 从前序与中序遍历序列构造二叉树
根据一棵树的前序遍历与中序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出
```
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7
```


```python

class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        
```

###  114. 二叉树展开为链表
给定一个二叉树，原地将它展开为一个单链表。


```
例如，给定二叉树

    1
   / \
  2   5
 / \   \
3   4   6
将其展开为：

1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
```


```python
# 前序遍历
class Solution:
    def flatten(self, root: TreeNode) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        if root.left:
            root.next = root.left
        elif root.right:
            root.next = flatten(root.left)
```


###   679. 24 点游戏
你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 *，/，+，-，(，) 的运算得到 24。

```python
示例 1:

输入: [4, 1, 8, 7]
输出: True
解释: (8-4) * (7-1) = 24
示例 2:

输入: [1, 2, 1, 2]
输出: False
注意:

除法运算符 / 表示实数除法，而不是整数除法。例如 4 / (1 - 2/3) = 12 。
每个运算符对两个数进行运算。特别是我们不能用 - 作为一元运算符。例如，[1, 1, 1, 1] 作为输入时，表达式 -1 - 1 - 1 - 1 是不允许的。
你不能将数字连接在一起。例如，输入为 [1, 2, 1, 2] 时，不能写成 12 + 12 。
```


```python
class Solution:
    def judgePoint24(self, nums: List[int]) -> bool:
        for i in range(4):
            if 
        def dfs(nums, depth):
            
```


```python
from typing import List

nums = [4, 1, 8, 7]
solution = Solution()
result = solution.judgePoint24(nums)
result

```

## 双指针



### √(20m) 26. 删除排序数组中的重复项
给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

 

``` python
示例 1:

给定数组 nums = [1,1,2], 

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 

你不需要考虑数组中超出新长度后面的元素。
示例 2:

给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。
 

说明:

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```


```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        i = 0
        for j in range(len(nums)):
            if nums[i] != nums[j]:
                i += 1
                nums[i] = nums[j]
        return i+1
```


```python
from typing import List

nums = [0,0,1,1,1,2,2,3,3,4]
solution = Solution()
result = solution.removeDuplicates(nums)
result
```

### (40m) 15. 三数之和
给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。


```
示例：

给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```

#### 经典，双指针定义, 典型例题，注意去重操作


当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从 O(N^2)O(N 
2
 ) 减少至 O(N)O(N)。为什么是 O(N)O(N) 呢？这是因为在枚举的过程每一步中，「左指针」会向右移动一个位置（也就是题目中的 bb），而「右指针」会向左移动若干个位置，这个与数组的元素有关，但我们知道它一共会移动的位置数为 O(N)O(N)，均摊下来，每次也向左移动一个位置，因此时间复杂度为 O(N)O(N)。

链接：https://leetcode-cn.com/problems/3sum/solution/san-shu-zhi-he-by-leetcode-solution/

**双指针格式**
```

while :
    if 
        i += 1
    if 
        j -= 1



for i in range():
    if :
        j -= 1
```

#### 2️⃣(90m) 


```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums = sorted(nums)
        n = len(nums)
        if n < 3: return []
        res = []
        for i in range(n):
            # 如果第一个数都＞0，和不可能==0；
            # 保证和上一次枚举数不同（去重）
            if i>0 and nums[i] == nums[i-1]:
                continue
                
            k = n - 1  # 第三个指针指向最右端
            target = -nums[i]
            for j in range(i+1, n):
                # 保证除了紧邻上一个的位置外，和上一次枚举数不同（去重）
                if j > i+1 and nums[j] == nums[j-1]:
                    continue
                    
                # 指针j 在 指针k 左侧
                while j < k and nums[j] + nums[k] > target:
                    k -= 1
                if j == k: 
                    break
                if nums[j] + nums[k] == target:
                    res.append([nums[i],nums[j],nums[k]])
        
        return res
        
```


```python
nums = [-1, 0, 1, 2, -1, -4] 
solution = Solution()
result = solution.threeSum(nums)
result

```


```python
a = [1,2]
a.index(2)
a.index?
```

#### 2️⃣（1h）

### √(50m) 11. (双指针)盛最多水的容器
给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器，且 n 的值至少为 2。
![](https://cdn.jsdelivr.net/gh/sunqinghu/PicRepo/img/2020/20201023173241.png)




图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。


```
示例：

输入：[1,8,6,2,5,4,8,3,7]
输出：49
```


```python
# 动态规划 -- 自己写的，超时
class Solution:
    def maxArea(self, height: List[int]) -> int:
        dp = [0 for _ in range(len(height))]
        for i in range(len(height)):
            if i == 0:  continue
            dp[i] = max(dp[i-1], max(min(height[i], height[j]) * (i-j) for j in range(i)))
        return dp[-1]
```


```python
# 双指针
class Solution:
    def maxArea(self, height: List[int]) -> int:
        l, r = 0, len(height) - 1
        ans = 0
        while l < r:
            area = min(height[l], height[r]) * (r-l) 
            ans = max(ans,area)
            if height[l] <= height[r]:
                l = l+1
            else:
                r = r-1
        return ans
```

#### 2️⃣(20m)


```python
# 双指针
class Solution:
    def maxArea(self, height: List[int]) -> int:
        maxArea = 0
        n = len(height)
        i, j = 0, n-1
        while i < j:
            area = min(height[i], height[j]) * (j-i)  
            maxArea = max(area, maxArea)
            if height[i] <= height[j]:  # 判断哪个要动
                i += 1
            else: j-=1
            
        return maxArea
    
                
```


```python
from typing import List

nums = [1,8,6,2,5,4,8,3,7]
solution = Solution()
result = solution.maxArea(nums)
result
```


```python

```

## 二分查找
* 要求
    1. 数据结构排好序
    2. 线性表具有随机访问的特点(如数组)
    3. 线性表可以根据中间元素特点推测两侧元素性质


###  167. 两数之和 II - 输入有序数组
给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。

函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。

说明:

返回的下标值（index1 和 index2）不是从零开始的。
你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。
``` python
示例:

输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
```


#### 二分法步骤


```python
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        n = len(numbers)
        for i in range(n):
            if 2 * numbers[i] > target:
                break
            
            a = i+1
            b = n-1
            while a <= b:
                c = (a+b)//2                
                if numbers[c] == target - numbers[i]:
                    return [i+1, c+1]
                elif numbers[c] < target - numbers[i]: # 注意必须是elif
                    a = c + 1  # 注意有+1 -1，保证不在边界，确保不会死循环
                else:
                    b = c - 1
```


```python
from typing import List

# numbers = [2, 3, 4]
# target = 6
# numbers = [-1, 0]
# target = -1
# numbers = [2,7,11,15]
# target = 9
numbers = [5,25,75]
target = 100
solution = Solution()
result = solution.twoSum(numbers, target)
result
```

### √(30m) 349. 两个数组的交集
给定两个数组，编写一个函数来计算它们的交集。

 

``` python
示例 1：

输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
示例 2：

输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
 

说明：

输出结果中的每个元素一定是唯一的。
我们可以不考虑输出结果的顺序。
```


```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        nums1 = sorted(list(set(nums1)))
        nums2 = sorted(list(set(nums2)))
        n1 = len(nums1)
        n2 = len(nums2)
        i, j = 0, 0
        ans = []
        while i<n1 and j<n2:
            if nums1[i] == nums2[j]:
                ans.append(nums1[i])
                i += 1
                j += 1
            elif nums1[i] < nums2[j]:
                i += 1
            elif nums1[i] > nums2[j]:
                j += 1
            
        return ans
            
                        
```


```python
from typing import List

nums1 = [1,2,2,1]
nums2 = [2,2]
solution = Solution()
result = solution.intersection(nums1, nums2)
result
```

###  287. 寻找重复数
给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

``` python
示例 1:

输入: [1,3,4,2,2]
输出: 2
示例 2:

输入: [3,1,3,4,2]
输出: 3
说明：

不能更改原数组（假设数组是只读的）。
只能使用额外的 O(1) 的空间。
时间复杂度小于 O(n2) 。
数组中只有一个重复的数字，但它可能不止重复出现一次。
```

#### 关键字：重复 想哈希表（O(n),O(n)）


```python
# 二分查找，小于等于i的个数  icnt[i]≤i
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        n = len(nums)
        l, r, ans = 1, n-1, -1
        while l<=r:
            mid = (l+r)//2 
            cnt = 0
            for i in range(n):
                cnt += nums[i] <= mid
            if cnt <= mid:
                l = mid + 1
            else:
                r = mid -1
                ans = mid
        return ans
```


```python
from typing import List

nums = [1,3,4,2,2]
solution = Solution()
result = solution.findDuplicate(nums)
result
```

###  300. 最长上升子序列
给定一个无序的整数数组，找到其中最长上升子序列的长度。

``` python
示例:

输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
说明:

可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
你算法的时间复杂度应该为 O(n2) 。
进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?
```


```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        
```


```python

from typing import List

nums = [10,9,2,5,3,7,101,18]
solution = Solution()
result = solution.lengthOfLIS(nums)
result
```


```python

```

###  378. 有序矩阵中第K小的元素
给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。
请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。

 

``` python
示例：

matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

返回 13。
 

提示：
你可以假设 k 的值永远是有效的，1 ≤ k ≤ n2 。
```


```python
# 官解

class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        n = len(matrix)
        def check(mid):
            i, j = n-1, 0
            num = 0
            while i >= 0 and j<n:
                if matrix[i][j] <= mid:
                    num += i +1
                    j += 1
                else:
                    i -= 1
            return num>=k
        
        left, right = matrix[0][0], matrix[-1][-1]  # 注意是从-1，-1
        while left < right:
            mid = (left + right)//2
            if check(mid):
                right = mid
            else:
                left = mid + 1
        return left

```


```python
from typing import List

matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
] 
k = 8 
solution = Solution()
result = solution.kthSmallest(matrix, k)
result
```

## 贪心算法
贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。

贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。


### √(20m) 455. 分发饼干
假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj >= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

注意：

你可以假设胃口值为正。
一个小朋友最多只能拥有一块饼干。

``` python
示例 1:

输入: [1,2,3], [1,1]

输出: 1

解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。
示例 2:

输入: [1,2], [1,2,3]

输出: 2

解释: 
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.
```


```python


class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        if len(g)==0 or len(s) == 0: return 0
        g.sort()
        s.sort()
        i = 0
        j = 0
        while i<len(g) and j<len(s):
            if s[j] >= g[i]:
                i += 1
            j += 1     
    
            
        return i
    
```


```python
from typing import List
g = [1,2,3,2]
s = [1,4]
solution = Solution()
result = solution.findContentChildren(g,s)
result
```

### √(20m) 392. 判断子序列
给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 <=100）。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

``` python
示例 1:
s = "abc", t = "ahbgdc"

返回 true.

示例 2:
s = "axc", t = "ahbgdc"

返回 false.

后续挑战 :

如果有大量输入的 S，称作S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？
```


```python
# 双指针
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        n, m = len(s), len(t)  
        i = j = 0
        while i < n and j < m:
            if t[j] == s[i]:
                i += 1
            j += 1
        return i == n
                
```

## 位操作
位操作包括：

  * ¬ 取反（NOT）
  * ∩∩ 按位或（OR）
  * ⊕⊕ 按位异或（XOR）
  * ∪∪ 按位与（AND）
  * 移位

移位是一个二元运算符，用来将一个二进制数中的每一位全部都向一个方向移动指定位，溢出的部分将被舍弃，而空缺的部分填入一定的值。

移位又分为
* 算术移位
* 逻辑移位

###  421. 数组中两个数的最大异或值
给定一个非空数组，数组中元素为 a0, a1, a2, … , an-1，其中 0 ≤ ai < 231 。

找到 ai 和aj 最大的异或 (XOR) 运算结果，其中0 ≤ i,  j < n 。

你能在O(n)的时间解决这个问题吗？

``` python
示例:

输入: [3, 10, 5, 25, 2, 8]

输出: 28

解释: 最大的结果是 5 ^ 25 = 28.
```


```python
class Solution:
    def findMaximumXOR(self, nums: List[int]) -> int:
```



###  260. 只出现一次的数字 III
给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。

``` python
示例 :

输入: [1,2,1,3,2,5]
输出: [3,5]
注意：

结果输出的顺序并不重要，对于上面的例子， [5, 3] 也是正确答案。
你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？
```

#### 使用 collection counter 例子

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> List[int]:
        from collections import Counter
        hashmap = Counter(nums)
        return [x for x in hashmap if hashmap[x] == 1]
```



## 数学

### √7.整数反转  

给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

``` python
示例 1:

输入: 123
输出: 321
示例 2:

输入: -123
输出: -321
示例 3:

输入: 120
输出: 21
注意:

假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。
```


```python
num = 123
num_reverse = num//100 + (num%100//10)*10 + (num%100%10)*100
num_reverse
```


```python
2**31
```

#### 2️⃣  
#### (1h)2️⃣  

#### 负数的python数学操作
```python
在python这个神奇的语言里，负数取模和负数地板除和其他语言是不一样的。
需要把取模替换成%(-val)
把地板除替换成int(x / val)

ans += (x % 10) if x>0 else (x%-10)
x = x // 10 if x>0 else int(x/10)

```

#### √ (30m)  7. 整数反转


```python
class Solution:
    def reverse(self, x: int) -> int:
        string = list(str(x))
        if string[0] == '-':
            string.pop(0)
            ans = 0
    #         print (string)
            for i in range(len(string)):
                ans = int(string[i])*10**i + ans
            ans = -ans
        else:
            ans = 0
    #         print (string)
            for i in range(len(string)):
                ans = int(string[i])*10**i + ans 
        if ans<-2**31 and ans>2**31-1: return 0
        return ans
```


```python
# m数学法
class Solution:
    def reverse(self, x): 
        ans = 0
        while (x != 0): 
            pop = x % 10
            ans = ans * 10 + pop
            x = x//10
        return ans

```


```python
from typing import List

nums = 123
solution = Solution()
result = solution.reverse(nums)
result
```

###  4. 寻找两个正序数组的中位数
给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。

请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 nums1 和 nums2 不会同时为空。


```
示例 1:

nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0

示例 2:

nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5
```

#### 2️⃣  


```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        
        
        
        
```


```python
nums1 = [1, 2]
nums2 = [3, 4]
solution = Solution()
result = solution.findMedianSortedArrays(nums1,nums2)
result
```

## 二叉树

#### 做题思路
我们在做二叉树题目时候，第一想到的应该是用**递归**来解决。

递归返回值：

        return root  #  注意返回的是root，此时root为空
一定注意 root 是树， root.val 是值

        valuePerDepth[index].append(root.val)   # 一定注意 root 是树， root.val 是值

注意用数组形式可以把root树加入队列        

        queue = [root]  # 注意用数组形式可以把root树加入队列

**注意递归时, return 里的false 和true的关系, 看是and 还是or**

### √101. 对称二叉树(二叉树不明白)  
给定一个二叉树，检查它是否是镜像对称的。

```
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

    1
   / \
  2   2
 / \ / \
3  4 4  3
但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

    1
   / \
  2   2
   \   \
   3    3
说明:

如果你可以运用递归和迭代两种方法解决这个问题，会很加分。
```


```python
# 自己写的 判断数组 二叉树不行
class Solution:
    def isSymmetric(self, root) -> bool:
        import math
        length = len(root)
        line_sum = math.log(length+1, 2)
#         print(line_sum)
        if line_sum % 1 != 0:return False
        

        for i in range(int(line_sum)):
            for j in range(int(math.pow(2,(i-1)))): 
                if root[int(math.pow(2,i)-1+j)] != root[int(math.pow(2,(i+1))-2-j)]:
                    return False
        return True
```


```python
global null
null = '#'
root = [1,2,2,null,3,null,3]
root = [1,2,2,3,4,4,3]
solution = Solution()
result = solution.isSymmetric(root)
print(result)
```


```python
# 递归方法
class Solution(object):
	def isSymmetric(self, root):
		"""
		:type root: TreeNode
		:rtype: bool
		"""
		if not root:
			return True
		def dfs(left,right):
			# 递归的终止条件是两个节点都为空
			# 或者两个节点中有一个为空
			# 或者两个节点的值不相等
			if not (left or right):
				return True
			if not (left and right):
				return False
			if left.val!= right.val:
				return False
			return dfs(left.left,right.right) and dfs(left.right,right.left)
		# 用递归函数，比较左节点，右节点
		return dfs(root.left,root.right)
```


```python
root = [1,2,2,null,3,null,3]
solution = Solution()
result = solution.isSymmetric(root)
print(result)
```

#### (40m)2️⃣  


```python
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if not root: return True
        def helper(root1, root2):
            if not (root1 or root2): return True
            elif not (root1 and root2):  return False

            if root1.val != root2.val: return False
            return helper(root1.left, root2.right) and helper(root1.right, root2.left)

        return helper(root, root)
```

### √104. 二叉树的最大深度  
给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

```
示例：
给定二叉树 [3,9,20,null,null,15,7]，

    3
   / \
  9  20
    /  \
   15   7
返回它的最大深度 3 。

````


```python
# 树节点TreeNode定义
class TreeNode(object):
    """ Definition of a binary tree node."""
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
```


```python
# 递归-DFS深度搜索策略
class Solution:
    def maxDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """ 
        if root is None: 
            return 0 
        else: 
            left_height = self.maxDepth(root.left) 
            right_height = self.maxDepth(root.right) 
            return max(left_height, right_height) + 1
```


```python
# 迭代
class Solution:
    def maxDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """ 
        stack = []
        if root is not None:
            stack.append((1, root))
        
        
        depth = 0
        while stack != []:
            current_depth, root = stack.pop()
            if root is not None:
                depth = max(depth, current_depth)
                stack.append((current_depth + 1, root.left))
                stack.append((current_depth + 1, root.right))
        
        return depth
```

#### 2️⃣(50m)   


```python
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        def helper( root, depth):
            if not root:
                return 0
            
            self.maxdepth = max(self.maxdepth,depth + 1)
                    
            helper(root.left, depth + 1)
            helper(root.right, depth + 1)
            
            return self.maxdepth

        self.maxdepth = 0
        return helper(root, 0)
```

### (50m) 108. 将有序数组转换为二叉搜索树
将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

```
示例:

给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5
```

#### 2️⃣


```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        if not nums: return None
        
        # 因为是平衡二叉树, 故找中间节点
        mid = len(nums)//2
        node = TreeNode(nums[mid])  # 注意root是一个值!
        
        left = nums[:mid]
        right = nums[mid+1:]
    
    
        node.left = sortedArrayToBST(left)
        node.right = sortedArrayToBST(right)
        
        return node
    
        
```


    ---------------------------------------------------------------------------
    
    NameError                                 Traceback (most recent call last)
    
    <ipython-input-6-a9ae52dc2c7f> in <module>
    ----> 1 class Solution:
          2     def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
          3         if not nums: return None
          4 
          5         # 因为是平衡二叉树, 故找中间节点


    <ipython-input-6-a9ae52dc2c7f> in Solution()
          1 class Solution:
    ----> 2     def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
          3         if not nums: return None
          4 
          5         # 因为是平衡二叉树, 故找中间节点


    NameError: name 'List' is not defined


#### 递归法带helper函数求解标准步骤


```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        def helper(left,right):   # 注意没有self
            # 基准情况，二叉树为空
            if left > right:  # 左右位置做标
                return None
            
            # 选中间偏左的结点为root
            mid = (left+right)//2
            
            root = TreeNode(nums[mid])  # root = TreeNode(0) # 用0作为根节点
            root.left = helper(left, mid - 1)
            root.right = helper(mid + 1, right)
            
            return root 
        
        return helper(0, len(nums) - 1)
    
```


```python
from typing import List

nums = [1,2,0,2,2]
solution = Solution()
result = solution.sortedArrayToBST(nums)
result
```

### √(50m) 226. 翻转二叉树
翻转一棵二叉树。

```
示例：

输入：

     4
   /   \
  2     7
 / \   / \
1   3 6   9
输出：

     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

![image.png](https://pic.leetcode-cn.com/0f91f7cbf5740de86e881eb7427c6c3993f4eca3624ca275d71e21c5e3e2c550-226_2.gif)

#### 递归法不带helper函数标准步骤


```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
# 递归
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:  # root is empty then return, 即使子树为空也没关系应该
            return None

        root.left, root.right = root.right, root.left
        
        self.invertTree(root.left)
        self.invertTree(root.right)

        return root  #  注意返回的是root，此时root为空


            
```

#### 迭代法标准步骤


```python
# 迭代
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return None
        queue = [root]  # 注意用数组形式可以把root树加入队列
        while queue:
            tmp = queue.pop(0)
            tmp.left, tmp.right = tmp.right, tmp.left
            
            if tmp.left:
                queue.append(tmp.left)
            if tmp.right:
                queue.append(tmp.right)
        
        return root 
```

### (40m) 543. 二叉树的直径
给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

 

```
示例 :
给定二叉树

          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
```

#### 深度优先搜索
1. 大多使用递归函数
2. 递归函数三要素
    1. 子问题原问题做相同的事情
    2. 需要递归结束的出口
    3. 递归表达式
    c

#### 当return输出和helper子任务不同时


```python
# 递归过程：
# 求depth（1）要求depth（2），depth（3）
# 求depth（2）要 ‘’‘
# ’‘’
# 递归表达式：
# depth(rt) = max(depth(rt->left), depth(rt->right))+1
class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:        
        self.ans = 1
        def depth(root):
            if not root: return 0
            self.ans = self.ans, depthdepth(root.left) + depth(root.right)+1
            return max(depth(root.left), depth(root.right))+1
        
        depth(root)
        return self.ans - 1
```

#### 2️⃣ 


```python
class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:        
        self.ans = 1
        def depth():  # 返回该节点为根的子树的深度( max(L,R)+1 )
            if not root: return 0
            L = depth(node.left)
            R = depth(node.right)
            self.ans = max(self.ans, L+R+1)
            return max(L,R) + 1
        depth(root)
        return self.ans - 1

```


```python

```

### √ 102. 二叉树的层序遍历
给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

 

```
示例：
二叉树：[3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回其层次遍历结果：

[
  [3],
  [9,20],
  [15,7]
]
```

#### 2️⃣(50m) 


```python
# 递归
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        valuePerDepth = []
        def helper(root, index):
            if not root: return 0
                       
            if len(valuePerDepth) < index+1:
                valuePerDepth.append([])

            valuePerDepth[index].append(root.val)   # 一定注意 root 是树， root.val 是值

            L = root.left
            R = root.right
            if L: helper(L, index+1)
            if R: helper(R, index+1) 
        
        helper(root, 0)
        return valuePerDepth    
            
            
            
```


```python
# 官解，迭代
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root: return []
        res = []
        queue = [root]  
        while queue:
            size = len(queue)
            tmp = []
            
            for _ in xrange(size):
                r = queue.pop(0)
                tmp.append(r.val)
                if r.left:
                    queue.append(r.left)
                if r.right:
                    queue.append(r.right)
            res.append(tmp)
        return res



```

### √ (7m) 107. 二叉树的层次遍历 II
给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）
```
例如：
给定二叉树 [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回其自底向上的层次遍历为：

[
  [15,7],
  [9,20],
  [3]
]
```


```python
class Solution:
    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:
        valuePerDepth = []
        def helper(root, index):
            if not root: return 0
                       
            if len(valuePerDepth) < index+1:
                valuePerDepth.append([])

            valuePerDepth[index].append(root.val)   # 一定注意 root 是树， root.val 是值

            L = root.left
            R = root.right
            if L: helper(L, index+1)
            if R: helper(R, index+1) 
        
        helper(root, 0)
        valuePerDepth = valuePerDepth[::-1]  # 反转数组操作
        return valuePerDepth
            
```

###  617. 合并二叉树
给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。

``` python
示例 1:

输入: 
	Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
输出: 
合并后的树:
	     3
	    / \
	   4   5
	  / \   \ 
	 5   4   7
注意: 合并必须从两个树的根节点开始。
```


```python
class Solution:
    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:
        if not t1 and not t2: return 0
        # if not t1 or not t2:
        if t1 is None:
            return t2   # is return, 相当于给原来的left, right赋值
        if t2 is None:
            root = t1          
        t1.val += t2.val
        t1.left = self.mergeTrees(t1.left, t2.left)
        t1.right = self.mergeTrees(t1.right, t2.right)
        return t1
```

###  687. 最长同值路径
给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。

注意：两个节点之间的路径长度由它们之间的边数表示。

``` python
示例 1:

输入:

              5
             / \
            4   5
           / \   \
          1   1   5
输出:

2
示例 2:

输入:

              1
             / \
            4   5
           / \   \
          4   4   5
输出:

2
注意: 给定的二叉树不超过10000个结点。 树的高度不超过1000。
```


```python
class Solution(object):
    def longestUnivaluePath(self, root):
        self.ans = 0

        def arrow_length(node):
            if not node: return 0
            left_length = arrow_length(node.left)
            right_length = arrow_length(node.right)
            left_arrow = right_arrow = 0
            if node.left and node.left.val == node.val:
                left_arrow = left_length + 1
            if node.right and node.right.val == node.val:
                right_arrow = right_length + 1
            self.ans = max(self.ans, left_arrow + right_arrow)
            return max(left_arrow, right_arrow)

        arrow_length(root)
        return self.ans

作者：LeetCode
链接：https://leetcode-cn.com/problems/longest-univalue-path/solution/zui-chang-tong-zhi-lu-jing-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### √ 112. 路径总和
给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

说明: 叶子节点是指没有子节点的节点。

``` python
示例: 
给定如下二叉树，以及目标和 sum = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。
```

#### (20m)2️⃣ 


```python
class Solution:
    def hasPathSum(self, root: TreeNode, sum: int) -> bool:
        if not root: return False

        if root.val == sum and not(root.left or root.right):
            return True

        return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val)
```

###  257. 二叉树的所有路径
给定一个二叉树，返回所有从根节点到叶子节点的路径。

说明: 叶子节点是指没有子节点的节点。

``` python
示例:

输入:

   1
 /   \
2     3
 \
  5

输出: ["1->2->5", "1->3"]

解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3
```


```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def binaryTreePaths(self, root: TreeNode) -> List[str]:
        if not root: return []
        ans = []
        path = ''

        def dfs(root, path):
            if root: 
                path+=str(root.val)
                if not(root.left or root.right): ans.append(path)
                else:
                    path += '->'
                    dfs(root.left, path)
                    dfs(root.right, path)

        dfs(root,path)
        return ans
        
```

###  669. 修剪二叉搜索树
给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R>=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。

``` python
示例 1:

输入: 
    1
   / \
  0   2

  L = 1
  R = 2

输出: 
    1
      \
       2
示例 2:

输入: 
    3
   / \
  0   4
   \
    2
   /
  1

  L = 1
  R = 3

输出: 
      3
     / 
   2   
  /
 1
```

###  538. 把二叉搜索树转换为累加树
给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。


```
例如：

输入: 原始二叉搜索树:
              5
            /   \
           2     13

输出: 转换为累加树:
             18
            /   \
          20     13
```

### (20m) 199. 二叉树的右视图

给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

示例:

```
输入: [1,2,3,null,5,null,4]
输出: [1, 3, 4]
解释:

   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---
```


```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def rightSideView(self, root: TreeNode) -> List[int]:
        pass
```


```python
from typing import List
from typing import TreeNode

nums =  []
solution = Solution()
result = solution.maxArea(nums)
result
```

### 124. 二叉树中的最大路径和

给定一个非空二叉树，返回其最大路径和。

本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。

```
示例 1:

输入: [1,2,3]

       1
      / \
     2   3

输出: 6
示例 2:

输入: [-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7
```

### 102. 二叉树的层序遍历

给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

 

```
示例：
二叉树：[3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回其层次遍历结果：

[
  [3],
  [9,20],
  [15,7]
]
```


```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
```


```python

```


```python
p = [0,1]
p.pop(0,1)
```

### 

## 字典，哈希表

### 1.两数之和

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
```
示例:

给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```


#### 字典使用和查字典方法
* 遍历列表同时查字典 -- 字典查找速度快
* 搜索元素就想字典(hash表)
``` python
for i, n in enumerate(nums):
    if target - n in dct:
        return [dct[target - n], i]
    dct[n] = i
```


```python
nums = [2, 7, 11, 15]
target = 9
```


```python
# 主要思想: 
# 判断 if target - n in dct

class Solution:
    def twoSum(nums, target):
        dct = {}
        for i, n in enumerate(nums):
            if target - n in dct:
                return [dct[target - n], i]
            dct[n] = i
            
result = Solution.twoSum(nums,target)
result
```


```python
# 直接从数组中找
# 800ms so slow
```


```python
start = time.time()
class Solution:
    def twoSum(nums, target):
        for i, n in enumerate(nums):
            if (target - n) in nums[i+1:]:
                j = nums[i+1:].index(target - n)
                return [i, j+i+1]

result = Solution.twoSum(nums,target)
result

end = time.time()
print((start - end))
```

#### (1h)2️⃣ 


```python

```

### 136. 只出现一次的数字 
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
```
说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

输入: [2,2,1]
输出: 1
示例 2:

输入: [4,1,2,1,2]
输出: 4
```


```python
# 当nums列表长时非常费时 -- 自己写的
class Solution:
    def singleNumber(self, nums) -> int:
#         stack = []
#         map = {}
#         for num in nums:
#             if num not in stack:
#                 stack.append(num)
        length = len(nums)
        for i in range(length):
            if (nums[i] not in nums[:i]) & (nums[i] not in nums[i+1:]):
                return nums[i]
```


```python
nums = [4,1,2,1,2]
solution = Solution()
result = solution.singleNumber(nums)
print(result)
```


```python
# 数组操作
class Solution(object):
    def singleNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        no_duplicate_list = []
        for i in nums:
            if i not in no_duplicate_list: # 注意此处用2个if 的话会判断2次
                no_duplicate_list.append(i)
            else:
                no_duplicate_list.remove(i)                
        return no_duplicate_list.pop()
```


```python
nums = [4,1,2,1,2]
solution = Solution()
result = solution.singleNumber(nums)
print(result)
```


```python
# 哈希表 -- 是以要存的数字为索引,存入1
class Solution(object):
    def singleNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        hash_table = {}
        for i in nums:
            try:
                hash_table.pop(i)
            except:
                hash_table[i] = 1
        return hash_table.popitem()[0]

nums = [4,1,2,1,2]
solution = Solution()
result = solution.singleNumber(nums)
print(result)
```


```python
# 位异或方法
class Solution(object):
    def singleNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        a = 0
        for i in nums:
            a ^= i
        return a
nums = [4,1,2,1,2]
solution = Solution()
result = solution.singleNumber(nums)
print(result)
```


```python
# 数学方法
class Solution(object):
    def singleNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        return 2 * sum(set(nums)) - sum(nums) # 注意集合函数set()
nums = [4,1,2,1,2]
solution = Solution()
result = solution.singleNumber(nums)
print(result)
```

![图](https://pic.leetcode-cn.com/36d1ac5d689101cbf9947465e94753c626eab7fcb736ae2175f5d87ebc85fdf0-283_2.gif)

### 448. 找到所有数组中消失的数字

给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。

找到所有在 [1, n] 范围之间没有出现在数组中的数字。

您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。
```
示例:

输入:
[4,3,2,7,8,2,3,1]

输出:
[5,6]
```



```python
# 方法二：原地修改方法 对i处位置的值为索引将其数字*-1
```

###  104. 二叉树的最大深度
给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

```
示例：
给定二叉树 [3,9,20,null,null,15,7]，

    3
   / \
  9  20
    /  \
   15   7
返回它的最大深度 3 。
```

## SQL

### 175. 组合两个表 - SQL架构

表1: Person

```
+-------------+---------+
| 列名         | 类型     |
+-------------+---------+
| PersonId    | int     |
| FirstName   | varchar |
| LastName    | varchar |
+-------------+---------+
PersonId 是上表主键
```

表2: Address

```
+-------------+---------+
| 列名         | 类型    |
+-------------+---------+
| AddressId   | int     |
| PersonId    | int     |
| City        | varchar |
| State       | varchar |
+-------------+---------+
AddressId 是上表主键
```

编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：

 ```
 FirstName, LastName, City, State
 ```

#### SQL 

MYSQL language  

内联结：  
select ...  
from ... inner join  
on ...  

外联结：  
考虑到可能不是每个人都有地址信息，我们应该使用 outer join 而不是默认的 inner join
select ...  
frome ... left join ...  
on ...  


```python
# SQL
select FirstName, LastName, City, State
from Person left join Address
on Person.PersonID = Address.PersonID
;
```

#### 2️⃣ 


```python
select FirstName, LastName, City, State
from Person left join Address
on Person.PersonID = Address.PersonID
;
```

## 字符串操作

### √(1h) 93. 复原IP地址

给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。

有效的 IP 地址正好由四个整数（每个整数位于 0 到 255 之间组成），整数之间用 '.' 分隔。

 

```
示例:

输入: "25525511135"
输出: ["255.255.11.135", "255.255.111.35"]

```


```python
class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        count = []
        for i in range(1,4):
            for j in range(1,4):
                for k in range(1,4):
                    for l in range(1,4):
                        if len(s) == i+j+k+l:
                            printstate = True
                            if int(s[:i]) < 256 and int(s[i:i+j]) < 256 and int(s[i+j:i+j+k]) < 256 and int(s[i+j+k:i+j+k+l]) < 256:
                                for ss in [s[:i],s[i:i+j],  s[i+j:i+j+k],s[i+j+k:i+j+k+l]]:
                                    if ss[0] == '0' and len(ss)>1: 
                                        printstate = False
                                if printstate == True:
                                    count.append(s[:i] +'.'+ s[i:i+j] +'.'+ s[i+j:i+j+k] +'.'+ s[i+j+k:i+j+k+l])

                                print(count)

        return count
            
```


```python
from typing import List

nums = "25525511135"
solution = Solution()
result = solution.restoreIpAddresses(nums)
result
```

#### 

## LCOF

### √ 03数组中重复的数字
找出数组中重复的数字。


在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

```
示例 1：

输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 
```

限制：

2 <= n <= 100000

#### 回溯算法（回溯搜索算法）  
1. 深度优先遍历的特有的现象，节约空间  
全排列思路：  
在枚举第一位的时候，有 3 种情况。  
在枚举第二位的时候，前面已经出现过的数字就不能再被选取了；  
在枚举第三位的时候，前面 2 个已经选择过的数字就不能再被选取了。  



```python
# 自己做的: 排序后前后对比
# 90％ 100％
nums = [2, 3, 1, 0, 2, 5, 3]

def findRepeatNumber(nums) -> int:
    nums_sorted = sorted(nums)
    length = len(nums_sorted)
    for i in range(length-1):
        if nums_sorted[i] == nums_sorted[i+1]:
            return nums_sorted[i]
        
findRepeatNumber(nums)
```


```python
# 法2: 原地替换 不如我的高
nums = [2, 3, 1, 0, 2, 5, 3]

def findRepeatNumber(nums) -> int:
    nums_sorted = sorted(nums)
    length = len(nums_sorted)
    for i in range(length):
        while nums_sorted[i] != i:
            if nums_sorted[i] == nums_sorted[nums_sorted[i]]:
                return nums_sorted[i]
            temp = nums_sorted[i]
            nums_sorted[i] = nums_sorted[temp]
            nums_sorted[temp] = temp
            
findRepeatNumber(nums)
```


```python
# 法3: hash表
nums = [2, 3, 1, 0, 2, 5, 3]

def findRepeatNumber(nums) -> int:
    hashlist = [False for i in range(len(nums))]
    for i in range(len(nums)):
        if hashlist[nums[i]] == True:
            return nums[i]
        else: 
            hashlist[nums[i]] = True
        
        
findRepeatNumber(nums)
```



### √ 04. 二维数组中的查找
在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

示例:

现有矩阵 matrix 如下：
```
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
```
给定 target = 5，返回 true。
给定 target = 20，返回 false。


```python
matrix = [
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]]

matrix = [[5]]

def findNumberIn2DArray(matrix, target):
    if len(matrix)==0 or len(matrix[0])==0:
        return False  
    
    row = 0
    col = len(matrix[0])-1
    while True:
        if matrix[row][col]==target:
            return True

        if matrix[row][col]>target:
            if (col==0): 
                return False
            else: 
                col -= 1
        elif matrix[row][col]<target:
            if (row==len(matrix)-1):
                return False
            else: 
                row += 1
findNumberIn2DArray(matrix, 5)
```

### √ 05. 替换空格
请实现一个函数，把字符串 s 中的每个空格替换成"%20"。

 

示例 1：
```
输入：s = "We are happy."
输出："We%20are%20happy."
```


```python
s = "We are happy."
```


```python
# 90 100 
# 注意replace() 不改变原str内容能提高, 
# 在 Python 和 Java 等语言中，字符串都被设计成不可变的类型，
# 即无法直接修改字符串的某一位字符，需要新建一个字符串实现。
class Solution:
    def replaceSpace(s: str) -> str:        
        return s.replace(' ','%20')

Solution.replaceSpace(s)
```


```python
# 切割拼接法
class Solution:
    def replaceSpace(s: str) -> str:    
        lst = s.split(' ')
        return '%20'.join(lst)
Solution.replaceSpace(s)
```

###  06. 从尾到头打印链表
#### 自制链表及其函数

输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。


```
示例 1：

输入：head = [1,3,2]
输出：[2,3,1]
```


```python
head = [1,3,2]
```


```python
# 注意这道题的链表的形式
# head.val 当前value
# head.next 下一个值的地址

# Definition for singly-linked list.
class ListNode(object):
    def __init__(self):
        self.val = None
        self.next = None

class ListNode_handle:
    def __init__(self):
        self.cur_node = None
 
    def add(self, data):
        #add a new node pointed to previous node
        node = ListNode()
        node.val = data
        node.next = self.cur_node
        self.cur_node = node
        return node
 
    def print_ListNode(self, node):
        while node:
            print ('\nnode: ', node, ' value: ', node.val, ' next: ', node.next)
            node = node.next
 
    def _reverse(self, nodelist):
        list = []
        while nodelist:
            list.append(nodelist.val)
            nodelist = nodelist.next
        result = ListNode()
        result_handle = ListNode_handle()
        for i in list:
            result = result_handle.add(i)
        return result

ListNode_1 = ListNode_handle()
l1 = ListNode()
l1_list = [1,3,2]
for i in l1_list:
    l1 = ListNode_1.add(i)
l1 = ListNode_1._reverse(l1)
ListNode_1.print_ListNode(l1)
```


```python
class Solution:
    def reversePrint(head):
        res = []
        while head:
            res.append(head.val)
            head = head.next
        return res[::-1]

head = l1
Solution.reversePrint(head)
```

### 07. 重建二叉树
输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。


```
例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7
```


hash to save time  
不重复 --> 想hash表


```python
preorder = [3,9,20,15,7]
inorder = [9,3,15,20,7]
```


```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

from typing import List

class Solution:
#     def buildTree(self, preorder, inorder):
    def buildTree(self, preorder: List[int], inorder: List[int]):
        self.dic, self.po={}, preorder # position ??????? 
        for i in range(len(inorder)):
            self.dic[inorder[i]] = i
        print(self.dic)
        return self.recur(0,0,len(inorder)-1)
        
    def recur(self, pre_root, left_root, right_root):
        if left_root>right_root: return
        # 1st layer to recursion
        root = TreeNode(self.po[pre_root])
        i = self.dic[self.po[pre_root]]
        self.left = self.recur(pre_root+1,in_left,i-1)
        self.right = self.recur(i-in_left+pre_root+1,i+1,in_right)
        return root

solution = Solution()
solution.buildTree(preorder,inorder)          
```



### 09. 用两个栈实现队列
用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )
```
示例 1：

输入：
["CQueue","appendTail","deleteHead","deleteHead"]
[[],[3],[],[]]
输出：[null,null,3,-1]
示例 2：

输入：
["CQueue","deleteHead","appendTail","appendTail","deleteHead","deleteHead"]
[[],[],[5],[2],[],[]]
输出：[null,-1,null,null,5,2]
```


```python
class CQueue:

    def __init__(self):
        self.A, self.B = [], []
        
    def appendTail(self, value: int) -> None:
        self.A.append(value)

    def deleteHead(self) -> int:
        if self.B: return self.B.pop()
        if not self.A: return -1        
        while self.A:
            self.B.append(self.A.pop())
        return self.B.pop()


# Your CQueue object will be instantiated and called as such:
# obj = CQueue()
# obj.appendTail(value)
# param_2 = obj.deleteHead()
```

### 面试题10- I. 斐波那契数列
写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：

F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

```
示例 1：

输入：n = 2
输出：1
示例 2：

输入：n = 5
输出：5
```

尝试动态规划方法



```python
n = 43
```


```python
class Solution:
    def fib(self, n: int) -> int:
        if n == 0: return 0
        if n == 1: return 1
        fiblist = [0,1]
        for i in range(2,n+1):
            fiblist.append((fiblist[i-1]+fiblist[i-2])% 1000000007)
        return fiblist.pop()
        
        
        
        
```


```python
# 动态规划方法
class Solution:
    def fib(self, n: int) -> int:
        if n == 0: return 0
        if n == 1: return 1
        a, b = 0, 1
        for _ in range(n):
            a, b = b, a+b
        return a % 1000000007
```


```python
solution = Solution()
result = solution.fib(n)
result
```

### √ 10- II. 青蛙跳台阶问题
一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
```
示例 1：

输入：n = 2
输出：2
示例 2：

输入：n = 7
输出：21
```


```python
n = 7
```


```python
class Solution:
    def numWays(self, n: int) -> int:
        if n == 0: return 0
        if n == 1: return 1
        if n == 2: return 2
        a, b = 1, 2
        for _ in range(n-1):
            a, b = b, a+b
        return a%1000000007
```


```python
solution = Solution()
result = solution.numWays(n)
result
```

### 11. 旋转数组的最小数字
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  
```
示例 1：

输入：[3,4,5,1,2]
输出：1
示例 2：

输入：[2,2,2,0,1]
输出：0
```

### 12. 矩阵中的路径
请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。

[["a","b","c","e"],
["s","f","c","s"],
["a","d","e","e"]]

但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。


```
示例 1：

输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
示例 2：

输入：board = [["a","b"],["c","d"]], word = "abcd"
输出：false
```


```python
board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]]
word = "ABCCED"

```


```python
# buxing 

class Solution:    
    def exist(self, board, word: str) -> bool:    
        for i in range(len(board)):
            for j in range(len(board[0])):
                if board[i][j] == word[0]: 
                    if self.it(0,i,j):
                        return True                    
        return False
                
    def it(self, index, i, j):
        for (m,n) in [(i,j-1),(i,j+1),(i-1,j),(i+1,j)]:
            if not 0<=m<len(board) or not 0<=n<len(board[0]) or board(m,n)!=word[index+1]: # 越界→下次循环
                continue                
            if board[m][n]==word[index+1] and not vis[m][n]: # 为下一个值且没访问过
                if index+1 == len(word)-1: 
                    return True
                tmp, board[i][j] = board[i][j], '/'
                it(index+1, m, n) 
                board[i][j] = tmp

            
```


```python
class Solution:
    def exist(self, board, word: str) -> bool:
        def dfs(i, j, k):
            if not 0 <= i < len(board) or not 0 <= j < len(board[0]) or board[i][j] != word[k]: return False
            if k == len(word) - 1: return True
            tmp, board[i][j] = board[i][j], '/'
            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)
            board[i][j] = tmp
            return res

        for i in range(len(board)):
            for j in range(len(board[0])):
                if dfs(i, j, 0): return True
        return False

```


```python
solution = Solution()
solution.exist(board,word)

```

### 13. 机器人的运动范围
地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

```
示例 1：

输入：m = 2, n = 3, k = 1
输出：3
示例 2：

输入：m = 3, n = 1, k = 0
输出：1
```


```python
m = 2
n = 3
k = 1
```


```python
m = 38
n = 12
k = 9
```


```python
# copy
def digitsum(n):
    ans = 0
    while n:
        ans += n % 10
        n //= 10
    return ans

class Solution:
    def movingCount(self, m: int, n: int, k: int) -> int:
        from queue import Queue
        q = Queue()
        q.put((0, 0))
        s = set()
        while not q.empty():
            x, y = q.get()
            if (x, y) not in s and 0 <= x < m and 0 <= y < n and digitsum(x) + digitsum(y) <= k:
                s.add((x, y))
                for nx, ny in [(x + 1, y), (x, y + 1)]:
                    q.put((nx, ny))
        return len(s)
        
```


```python
solution = Solution()
solution.movingCount(m,n,k)
```





