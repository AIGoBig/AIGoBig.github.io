<h1 id="reference">Reference</h1>
<p><a href="https://www.jianshu.com/p/7197081a703f">(2018.01-简书)让你“又爱又恨”的推荐系统–程序猿篇</a></p>
<h1 id="introduction">Introduction</h1>
<h2 id="学习路线">学习路线</h2>
<ol type="1">
<li>协同过滤
<ol type="1">
<li>配合的排序方法，GBDT</li>
</ol></li>
<li>xgboost</li>
<li><code>**深度学习的推荐系统**</code></li>
</ol>
<h2 id="课程安排">课程安排</h2>
<ul>
<li><h3 id="第一部分-报名审核">第一部分 报名审核</h3></li>
</ul>
<p>申请学员（以下简称学员）填写报名申请表并附上简历，电话或远程面试通过后，才视为报名成功，然后学员和七月在线（以下简称机构）双方签订培训合同。</p>
<ul>
<li><h3 id="第二部分-内容安排">第二部分 内容安排</h3></li>
</ul>
<p>课程开始前，提供预习视频预习，课程开始后，每周安排直播、录播、实训、答疑，然后每两周考试一次，顺利通过阶段考试的学员，才能进入下一阶段的学习。未能通过考核的重新学习，做查漏补缺。</p>
<h4 id="预习阶段-掌握bat推荐系统和常用算法">预习阶段 掌握BAT推荐系统和常用算法</h4>
<p>在线视频：推荐业务、feed流产品及推荐算法策略架构解析</p>
<pre><code>* 1-推荐业务和推荐feed流产品详解
* 2-推荐策略架构分解
* 3-基于point wise 的stacking model 如何做用于推荐业务，以及相应的效果评估和模型如何升级(针对相应算法，提供data和code)</code></pre>
<p>在线视频：召回算法和业界最佳实践</p>
<pre><code>* 1-BAT里常用的CF算法以及变种（User/Item CF等变种)
* 2-Hybrid CF 算法
* 3-Model Based CF（LFM矩阵分解、NMF、SVD)
* 4-基于改进版协同过滤算法实战</code></pre>
<p>在线视频：搜索和推荐的matching技术</p>
<pre><code>* 1-NLP的基础知识，BOW， TF-IDF， BM25
* 2-word2vec， topic model
* 3-向量召回，embedding基础</code></pre>
<p>在线实训：改进版协同过滤算法实战</p>
<h4 id="第一阶段-业界前沿召回算法与特征工程">第一阶段 业界前沿召回算法与特征工程</h4>
<p>在线视频：Deep recall算法解析、主流技术方向思考及相应model的改进方案</p>
<pre><code>* 1-推荐系统的主流技术深度方向讨论及相关算法思考
* 2-如何通过deep learning model抽取推荐系统中的high-order feature
* 3-recall算法簇review，Deep recall模型解析和优化（针对相应算法，提供data和code）</code></pre>
<p>在线实训：隐语义模型实战</p>
<p>在线视频：用户建模（召回、排序都会用到）</p>
<pre><code>* 1-BAT公司里常见的用户建模
* 2-特征工程、分类模型开发</code></pre>
<p>在线实训：倒排索引项目实战</p>
<p>在线直播：召回算法进阶实战</p>
<pre><code>* 1-多路召回策略实战（热门、兴趣标签、内容属性、协同过滤、业务规则等）
* 2-Youtube召回实战</code></pre>
<p>在线直播：用户特征和Item特征的常用方法</p>
<pre><code>* 1-Embedding的数学本质和计算方法
* 2-用户特征和人群画像
* 3-手动和自动特征工程</code></pre>
<h4 id="第二阶段-业界常用排序算法">第二阶段 业界常用排序算法</h4>
<p>在线视频：排序算法&amp;深度学习模型</p>
<pre><code>* 1-BAT里基础建模流程构造（涉及样本、特征、模型、系统设计和实践）
* 2-深度召回模型最新进展（向量检索、深度学习等）
* 3-深度排序最新进展（WDL、DeepFM、DeepCross等）
* 4-用户序列建模（LSTM、GRU, word2vec等）</code></pre>
<p>在线视频：Learn to Rank</p>
<pre><code>* 1-Pointwise/Pairwise/Listwise排序（全局排序）
* 2-多目标优化（ESMM等）
* 3-多样性排序（BAT真实场景用户体验优化）</code></pre>
<p>在线实训：谷歌wide&amp;deep模型实战</p>
<p>在线视频：商品推荐方案讨论、E&amp;&amp;E算法以及deep learning如何作用于推荐系统中的排序</p>
<pre><code>* 1-电商推荐系统的难点
* 2-业界推荐系统的公开数据集和开源经典算法以及用于解决coldstart和exploit-explore问题的bandit算法簇
* 3-deep learning模型算法作用于排序及相应优化方案（针对相应算法，提供data和code）</code></pre>
<p>在线视频：CTR预估和采样</p>
<pre><code>* 1-CTR概率矫正技术
* 2-多目标和ESMM
* 3-多种多样的采样算法</code></pre>
<p>在线直播：CTR预估进阶实战（上）</p>
<pre><code>* 1-GBDT+LR 代码实战
* 2-wide&amp;deep 代码实战</code></pre>
<p>在线直播：CTR预估进阶实战（下）</p>
<pre><code>* 1-DeepFm 代码实战
* 2-DIN 代码实战</code></pre>
<h4 id="第三阶段-在线学习与实时化计算">第三阶段 在线学习与实时化计算</h4>
<p>在线视频：分布式机器学习系统及其在排序模型中的应用</p>
<pre><code>* 1-分布式机器学习系统综述
* 2-Parameter Server介绍
* 3-基于Paramer Server的大规模离线LR/FM实现介绍</code></pre>
<p>在线视频： 实时化技术升级</p>
<pre><code>* 1-Online Learning 算法（FTRL、增量学习等）
* 2-Online Learning 在BAT的系统架构</code></pre>
<p>在线实训 ：Online Learning 最新算法实现</p>
<p>在线视频：在线学习和相关技术</p>
<pre><code>* 1-L1, L2和FTRL优化算法
* 2-流式计算和流式数据
* 3-在线模型和实时特征</code></pre>
<p>在线直播：基于flink和scala的实时计算</p>
<pre><code>* 1-flink相关知识点介绍
* 2-scala的相关知识,flink scala API初步上手
* 3-flink JOIN,MAP,TIMEWINDOW等算子的使用，checkpoints等高级特性的简介
* 4-实时数据进入tensorflow,tensorflow实时reader</code></pre>
<p>在线直播：单机和分布式深度学习tensorflow实践</p>
<pre><code>* 1-掌握tensorflow单机和分布式操作
* 2-熟悉tensorflow serving
* 3-掌握对于数据进行分析和模型进行评估</code></pre>
<h4 id="第四阶段-推荐系统最新技术">第四阶段 推荐系统最新技术</h4>
<p>在线视频：学术界最新算法在BAT的应用</p>
<pre><code>* 1-电商推荐中的Delayed reward强化学习算法
* 2-GAN等技术在推荐系统的实践</code></pre>
<p>在线视频：掌握真实业务场景下的推荐算法</p>
<pre><code>* 1-社交推荐算法
* 2-短视频推荐算法
* 3-音乐推荐
* 4-新闻推荐
* 5-电商推荐</code></pre>
<p>在线直播：多目标排序</p>
<pre><code>* 1-推荐系统中的CTR、CVR任务如何共同建模
* 2-多目标排序的问题点
* 3-如何通过算法将推荐系统中的用户显式反馈行为和隐式反馈行为(浏览、点击、购买和评论)进行表征同时作用于个性化推荐（针对相应算法，提供data和code）</code></pre>
<p>在线直播：推荐系统最新技术、场景、方向解析</p>
<pre><code>* 1-推荐新场景
* 2-推荐系统可解释性
* 3-推荐系统多样性
* 4-推荐系统公平性
* 5-冷启动问题的最新解法</code></pre>
<ul>
<li><h3 id="第三部分-实战项目">第三部分 实战项目</h3></li>
</ul>
<p>在课程进行的后半段，学员根据自己的兴趣和求职的方向选择实战项目：</p>
<h4 id="第一阶段-整体流程介绍与项目任务书发布">第一阶段 整体流程介绍与项目任务书发布</h4>
<p>在线直播：项目1 单机和分布式深度学习TensorFlow实践的介绍</p>
<p>在线直播：项目2 基于Flink和Scala的实时计算实践的介绍</p>
<p>在线直播：项目3 电商平台的商品推荐系统的介绍</p>
<h4 id="第二阶段-环境配置与特征工程">第二阶段 环境配置与特征工程</h4>
<p>在线直播：项目1 单机和分布式深度学习TensorFlow实践的特征工程</p>
<p>在线直播：项目2 基于Flink和Scala的实时计算实践的特征工程</p>
<p>在线直播：项目3 电商平台的商品推荐系统的特征工程</p>
<h4 id="第三阶段-模型构建与迭代优化">第三阶段 模型构建与迭代优化</h4>
<p>在线直播：项目1 单机和分布式深度学习TensorFlow实践的模型构建</p>
<p>在线直播：项目2 基于Flink和Scala的实时计算实践的模型构建</p>
<p>在线直播：项目3 电商平台的商品推荐系统的模型构建</p>
<h4 id="第四阶段-模型的评估优化与上线">第四阶段 模型的评估、优化与上线</h4>
<p>在线直播：项目1 单机和分布式深度学习TensorFlow实践的整体实现</p>
<p>在线直播：项目2 基于Flink和Scala的实时计算实践的整体实现</p>
<p>在线直播：项目3 电商平台的商品推荐系统的整体实现</p>
<h4 id="第五阶段-次项目的整体流程和核心技能点">第五阶段 次项目的整体流程和核心技能点</h4>
<p>在线直播：项目4 游戏推荐系统的整体流程和核心技能点</p>
<p>在线直播：项目5 猜你喜欢场景下的推荐系统整体流程和核心技能点</p>
<p>在线直播：项目6 Netflix推荐竞赛整体流程和核心技能点</p>
<h2 id="个人观点">个人观点</h2>
<p>深度学习由于在图像和语音等连续信号上取得了不可置否的成绩，但CV、NLP就业现状却不容乐观。首先，其在工业界落地困难，除了一些成熟的方向（如人脸识别）外找到一个可以推广应用的技术有一定难度，而且变现能力不够。其次，其不可解释性能加增加了其在一些敏感领域的应用难度。</p>
<p>因此如果想要提升自己的竞争力，也给自己多一些选择，回退学习机器学习及其典型应用——推荐、广告系统等势在必行。加强实践能力，参加些比赛提升理解及应用落地能力。</p>
<p>发挥自身优势，将深度学习应用到推荐系统，广告系统，风控系统或者搜索引擎等。</p>
<h2 id="为什么需要个性化推荐系统">为什么需要个性化推荐系统</h2>
<p>如今，我们这代人正经历从<strong>信息时代</strong>(Information Technology,IT)到<strong>数据时代</strong>(Data Technology,DT)的变迁，DT时代比较明显的标志就是：<strong>信息过载</strong>。</p>
<figure>
<img src="/img/in-post/20_07/image-20200730091827172.png" alt="image-20200730091827172" /><figcaption>image-20200730091827172</figcaption>
</figure>
<blockquote>
<p>在DT时代，充斥着海量的信息，如何从海量的信息中快捷的帮助特定用户找到感兴趣的信息呢？有两种相关的解决技术：<strong>搜索引擎与推荐系统。</strong></p>
</blockquote>
<blockquote>
<p><strong>搜索引擎与推荐系统有什么区别？</strong><br />
搜索引擎：实现人找信息，eg.百度搜索…<br />
推荐系统：实现<strong>信息找人</strong>，eg.亚马逊的图书推荐列表…</p>
</blockquote>
<p>与搜索引擎不同，<strong>推荐系统</strong>不需要用户准确地描述出自己的需求，而是<strong>根据分析历史行为建模，主动提供满足用户兴趣和需求的信息。</strong></p>
<figure>
<img src="/img/in-post/20_07/image-20200730091945357.png" alt="image-20200730091945357" /><figcaption>image-20200730091945357</figcaption>
</figure>
<p>简单来说，对于消费者而言，他们喜欢用2个小时去看一部感兴趣的电影，却不愿意花20分钟去挑选，这就是个<strong>性化推荐系统存在的意义</strong>。</p>
<h2 id="什么是推荐系统">什么是推荐系统</h2>
<p>推荐系统通过分析、挖掘用户行为，发现用户的个性化需求与兴趣特点，将用户可能感兴趣的信息或商品推荐给用户。一个优秀的推荐系统，能够很好的<strong>串联起用户、商家以及平台方，并让三方都收益。</strong></p>
<p>本质上来讲，推荐系统就是对所有商品针对特定用户进行按照一定策略<strong>进行排序</strong>，然后筛选出若干商品推荐给用户的过程。</p>
<h1 id="传统的推荐系统方法">传统的推荐系统方法</h1>
<p><a href="https://www.jianshu.com/p/0c2835e3e662">推荐系统基础知识储备</a></p>
<ol type="1">
<li><p><strong>协同过滤推荐</strong>（Collaborative Filtering Recommendation）：该方法收集分析用户历史行为、活动、偏好，计算一个用户<strong>与其他用户的相似度</strong>，利用目标用户的相似用户对商品评价的加权评价值，来预测目标用户对特定商品的喜好程度。优点是可以给用户推荐未浏览过的新产品；<strong>缺点是对于没有任何行为的新用户存在冷启动的问题</strong>，同时也存在用户与商品之间的交互数据不够多造成的<strong>稀疏问题</strong>，会导致模型难以找到相近用户。</p></li>
<li><p><strong>基于内容过滤推荐[**<a href="http://staging.paddlepaddle.org/docs/develop/book/05.recommender_system/index.cn.html#参考文献">1</a>]（Content-based Filtering Recommendation）：该方法利用商品的内容描述，抽象出有意义的特征，通过</strong>计算用户的兴趣和商品描述之间的相似度<strong>，来给用户做推荐。优点是简单直接，不需要依据其他用户对商品的评价，而是通过商品属性进行商品相似度度量，从而推荐给用户所感兴趣商品的相似商品；缺点是对于没有任何行为的新用户同样存在</strong>冷启动**的问题。</p></li>
<li><p><strong>组合推荐</strong>[<a href="http://staging.paddlepaddle.org/docs/develop/book/05.recommender_system/index.cn.html#参考文献">2</a>]（Hybrid Recommendation）：运用<strong>不同的输入和技术共同进行推荐</strong>，以弥补各自推荐技术的缺点。</p></li>
</ol>
<h2 id="协同过滤推荐">协同过滤推荐</h2>
<p>基于协同过滤推荐算法的思想是：通过对<strong>用户历史行为数据的挖掘发现用户的偏好</strong>，<strong>基于不同的偏好对用户进行群组划分并推荐品味相似的项</strong>。在计算推荐结果的过程中，不依赖于项的任何附加信息或者用户的任何附加信息，<strong>只与用户对项的评分有关</strong>。</p>
<p><img src="/img/in-post/20_07/image-20200730102956457.png" alt="image-20200730102956457" style="zoom:50%;" /></p>
<blockquote>
<p><strong>基于用户的</strong>：User-based Collaborative Filtering，为用户推荐和他兴趣相似的用户喜欢的商品。 <strong>基于项(商品)的</strong>：tem-based Collaborative Filtering，为用户推荐与他之前喜欢的商品相似度高的商品.</p>
</blockquote>
<p>这个算法的核心，就是如<strong>何衡量用户与用户之间的相似度或者商品与商品之间的相似度</strong>。</p>
<p>相似性的度量方法有很多种，比如：<strong>欧式距离、皮尔森相关系数、余弦相似度等</strong>。</p>
<h3 id="基于用户的usercf与基于商品的itemcf推荐方法区别">基于用户的(UserCF)与基于商品的(ItemCF)推荐方法区别</h3>
<ol type="1">
<li><p><strong>UserCF:</strong> 看重<strong>用户相似的小群体的热点</strong>，偏重社会化，一般适用于<strong>新闻推荐</strong></p>
<p>缺点</p>
<ol type="1">
<li>用户数量过大时存储大</li>
<li>历史数据稀疏，相似用户找到准确率低</li>
</ol></li>
</ol>
<blockquote>
<p>改进：UserCF-IIF:（类似于TF-IDF的作用）：实际业务中用户数量太多，很难对推荐结果做出解释。</p>
</blockquote>
<ol start="2" type="1">
<li><p><strong>ItemCF</strong>: 以物找物。</p></li>
<li><blockquote>
<p>看重个性化，反应用户个人兴趣的传承性，此外商品的更新不能太快，因为实时计算物品相似度矩阵非常耗时，这也是为啥新闻一般不用ItemCF。 ItemCF在实际业务中用的比较多，可以<strong>基于用户的历史购买商品行为</strong>对推荐结果做出可理解的解释。</p>
</blockquote>
<blockquote>
<p>同时，从技术上考虑，UserCF需要维护一个用户相似度的矩阵，而ItemCF需要维护一个物品 相似度矩阵。从存储的角度说，如果用户很多，那么维护用户兴趣相似度矩阵需要很大的空间， 同理，如果物品很多，那么维护物品相似度矩阵代价较大。</p>
</blockquote></li>
</ol>
<figure>
<img src="/img/in-post/20_07/image-20200730103422074.png" alt="image-20200730103422074" /><figcaption>image-20200730103422074</figcaption>
</figure>
<h2 id="工业界的推荐系统">工业界的推荐系统</h2>
<h3 id="数据量">数据量</h3>
<p>企业级的数据一般都是G量级起步的数据量，很难使用我们参加一些小型竞赛的数据处理方式，python的Pandas等库一般使用很难操作这些业务数据，所以很多推荐系统都是搭建在<strong>集群</strong>之上的，数据存储可能是<strong>基于Hadoop的HDFS等</strong>，<strong>计算框架一般是Spark或者企业自研的数据平台</strong>(阿里的PAI平台…主要任务就是写SQL…羡慕吧)。所以，入职的第一步就是学习<strong>hadoop平台与spark的使用</strong></p>
<figure>
<img src="/img/in-post/20_07/image-20200730103851934.png" alt="image-20200730103851934" /><figcaption>image-20200730103851934</figcaption>
</figure>
<h3 id="如何合理的评价推荐系统效果">如何合理的评价推荐系统效果？</h3>
<p>参加过一些数据竞赛的推荐系统，一般平台会给出一个评价函数，可能是准确率、召回率等常见评价函数的调和函数。但在实际的业务场景中，却很难给出一个准确的评价函数来评价我们推荐系统的效果。这其中就涉及到推荐系统中<strong>多样性与精确性的两难困境</strong></p>
<p>推荐用户喜欢商品最保险的方式就是很流行或者分数很高的商品。但是这种推荐产生的用户体验不一定好：因为既然用户已知其热销，故信息量少且让用户不觉得是个性化推荐</p>
<blockquote>
<p>Mcnee等人已经警告大家，<strong>盲目崇拜精确性指标可能会伤害推荐系统</strong>，因为这样可能会导致用户得到一些信息量为0的“精准推荐”并且视野变得越来越狭窄。<strong>让用户视野变得狭窄是协同过滤算法的一个主要缺陷</strong>，这会进一步加剧长尾效应。与此同时，应用个性化推荐技术的商家，也希望推荐中有更多的品类出现，从而激发用户新的购物需求。</p>
</blockquote>
<p>遗憾的是<strong>，推荐多样性与推荐的精确性之间存在矛盾</strong>，因为前者风险很大—推荐一个没人看过或者打分较低的东西，很可能被用户憎恶，从而效果更差。很多时候，这是一个两难的问题，只能通过牺牲多样性来提高精确性，或者牺牲精确性来提高多样性。<strong>一种可行之策是直接对推荐列表进行处理</strong>，从而提升其多样性。这种方法固然在应用上是有效的，但没有任何理论的基础和优美性可言，只能算一种实用的招数。</p>
<h2 id="基于深度学习的推荐系统">基于深度学习的推荐系统</h2>
<p>其实，上面所讲协同过滤的方法是一种比较传统的方式，仍旧在工业界具有广泛的应用。<code>如今，伴随着机器学习的兴起了非常多的技术被应用到推荐系统中**，从传统的机器学习方式LR、GBDT、XGBoost到LightGBM，深度学习从最初利用word2vec用于评估用户的相似度，到CNN、RNN等模型也开始被很多的推荐小组尝试。**</code></p>
<figure>
<img src="/img/in-post/20_07/image-20200730105016143.png" alt="image-20200730105016143" /><figcaption>image-20200730105016143</figcaption>
</figure>
<p><strong>深度学习具有优秀的自动提取特征的能力</strong>，能够<strong>学习多层次的抽象特征表示</strong>，并对<strong>异质或跨域的内容信息进行学习，可以一定程度上处理推荐系统冷启动问题。</strong></p>
<figure>
<img src="/img/in-post/20_07/image-20200730105339675.png" alt="image-20200730105339675" /><figcaption>image-20200730105339675</figcaption>
</figure>
<p>在融合推荐模型的电影推荐系统中：</p>
<ol type="1">
<li>首先，使用用户特征和电影特征作为神经网络的输入，其中：</li>
<li>用户特征融合了四个属性信息，分别是用户ID、性别、职业和年龄。</li>
<li>电影特征融合了三个属性信息，分别是电影ID、电影类型ID和电影名称。</li>
<li>对用户特征，将用户ID映射为维度大小为256的向量表示，输入全连接层，并对其他三个属性也做类似的处理。然后将四个属性的特征表示分别全连接并相加。</li>
<li>对电影特征，将电影ID以类似用户ID的方式进行处理，电影类型ID以向量的形式直接输入全连接层，电影名称用文本卷积神经网络得到其定长向量表示。然后将三个属性的特征表示分别全连接并相加。</li>
<li>得到用户和电影的向量表示后，计算二者的余弦相似度作为推荐系统的打分。最后，用该相似度打分和用户真实打分的差异的平方作为该回归模型的损失函数。</li>
</ol>
<figure>
<img src="/img/in-post/20_07/image-20200730105508010.png" alt="image-20200730105508010" /><figcaption>image-20200730105508010</figcaption>
</figure>
<blockquote>
<p><strong>身处工业界，最基础的就是使用协同过滤配合其它的一些排序方法，例如GBDT，基本就能完成推荐的基本功能</strong>，基于深度学习的方式现在应用的还没有那么成熟，希望自己今后也能有业务需要我深入的研究一下<strong>如何在实际的业务场景中大规模的使用深度学习的推荐系统</strong></p>
</blockquote>
<h1 id="代码分析">代码分析</h1>
<h2 id="一段协同过滤的pyhton版demo便于理解计算的流程">一段协同过滤的Pyhton版Demo[便于理解计算的流程]</h2>
<h3 id="一usercf-基于用户的协同过滤算法">一、UserCF 基于用户的协同过滤算法:</h3>
<p>首先计算用户-用户之间的相似度 w 找出该用户u没买过的商品I`候选推荐数据集 遍历所有用户[所有买过I商品的用户U]：求和{ 用户U与用户u的相似度 * 用户U对商品I的评分 } &lt;利用所有买过候选集商品的**用户评分*用户与该用户的相似度**–&gt;得出j候选集的得分&gt;</p>
<h3 id="二itemcf-基于项的协同过滤算法是通过基于项的相似性来进行计算的">二、ItemCF 基于项的协同过滤算法:是通过基于项的相似性来进行计算的</h3>
<p>计算商品-商品之间的相似度 找出该用户u没买过的商品I`&gt;候选推荐数据集 遍历所有商品J[该用户u买过的商品J]`&gt;求和{ 商品I与商品J的相似度 * 用户u对商品J的评分 } &lt;只利用u自己的购买过的商品，然后根据**商品之间的相似度*自己对该商品的评分**—得到该候选商品的得分&gt;</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="co"># coding:utf-8</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2"></a>
<a class="sourceLine" id="cb23-3" data-line-number="3"><span class="im">import</span> numpy <span class="im">as</span> np</a>
<a class="sourceLine" id="cb23-4" data-line-number="4"><span class="im">from</span> math <span class="im">import</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5"></a>
<a class="sourceLine" id="cb23-6" data-line-number="6"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb23-7" data-line-number="7"><span class="co">相似度计算函数</span></a>
<a class="sourceLine" id="cb23-8" data-line-number="8"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb23-9" data-line-number="9"><span class="co"># 第一种计算相似度：余弦相似度， 计算两者之间相似度【计算相似度的方法有很多，这里使用余弦相似度】</span></a>
<a class="sourceLine" id="cb23-10" data-line-number="10"><span class="kw">def</span> cos_sim(x, y):</a>
<a class="sourceLine" id="cb23-11" data-line-number="11">    <span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb23-12" data-line-number="12"><span class="co">    :param x(mat): 行向量，可以是用户或商品</span></a>
<a class="sourceLine" id="cb23-13" data-line-number="13"><span class="co">    :param y(mat): 行向量，可以是用户或商品</span></a>
<a class="sourceLine" id="cb23-14" data-line-number="14"><span class="co">    :return: x 和 y 之间的余弦相似度</span></a>
<a class="sourceLine" id="cb23-15" data-line-number="15"><span class="co">    &quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb23-16" data-line-number="16">    <span class="co"># x 与 y 之间的内积</span></a>
<a class="sourceLine" id="cb23-17" data-line-number="17">    inner_product <span class="op">=</span> x <span class="op">*</span> y.T</a>
<a class="sourceLine" id="cb23-18" data-line-number="18">    norm <span class="op">=</span> np.sqrt(x <span class="op">*</span> x.T) <span class="op">*</span> np.sqrt(y <span class="op">*</span> y.T)</a>
<a class="sourceLine" id="cb23-19" data-line-number="19">    <span class="co"># 余弦相似度的结果</span></a>
<a class="sourceLine" id="cb23-20" data-line-number="20">    <span class="cf">return</span> (inner_product <span class="op">/</span> norm)[<span class="dv">0</span>, <span class="dv">0</span>]</a>
<a class="sourceLine" id="cb23-21" data-line-number="21"></a>
<a class="sourceLine" id="cb23-22" data-line-number="22"><span class="kw">def</span> similarity(data):</a>
<a class="sourceLine" id="cb23-23" data-line-number="23">    <span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb23-24" data-line-number="24"><span class="co">    :param data: 矩阵</span></a>
<a class="sourceLine" id="cb23-25" data-line-number="25"><span class="co">    :return: w(mat): 任意两行之间的相似度,相似度矩阵w是一个对称矩阵。在相似度矩阵中约定自身相似度为0。</span></a>
<a class="sourceLine" id="cb23-26" data-line-number="26"><span class="co">        [[0.         0.76912242 0.39678004 0.49377072 0.02503131],</span></a>
<a class="sourceLine" id="cb23-27" data-line-number="27"><span class="co">        [0.76912242 0.         0.84770118 0.5696552  0.44279924],</span></a>
<a class="sourceLine" id="cb23-28" data-line-number="28"><span class="co">        [0.39678004 0.84770118 0.         0.45714286 0.46348977],</span></a>
<a class="sourceLine" id="cb23-29" data-line-number="29"><span class="co">        [0.49377072 0.5696552  0.45714286 0.         0.64888568],</span></a>
<a class="sourceLine" id="cb23-30" data-line-number="30"><span class="co">        [0.02503131 0.44279924 0.46348977 0.64888568 0.        ]]</span></a>
<a class="sourceLine" id="cb23-31" data-line-number="31"><span class="co">    &quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb23-32" data-line-number="32">    <span class="co"># 用户/商品【行数决定方阵的维度】</span></a>
<a class="sourceLine" id="cb23-33" data-line-number="33">    m <span class="op">=</span>np.shape(data)[<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb23-34" data-line-number="34">    <span class="co"># 初始化相似度矩阵</span></a>
<a class="sourceLine" id="cb23-35" data-line-number="35">    w <span class="op">=</span>np.mat(np.zeros((m, m)))</a>
<a class="sourceLine" id="cb23-36" data-line-number="36">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(m):</a>
<a class="sourceLine" id="cb23-37" data-line-number="37">        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i, m):</a>
<a class="sourceLine" id="cb23-38" data-line-number="38">            <span class="cf">if</span> j <span class="op">!=</span> i:</a>
<a class="sourceLine" id="cb23-39" data-line-number="39">                <span class="co"># 计算两行之间的相似度[用户-用户 或者 商品-商品]</span></a>
<a class="sourceLine" id="cb23-40" data-line-number="40">                w[i, j] <span class="op">=</span> cos_sim(data[i], data[j])  <span class="co"># 使用余弦距离</span></a>
<a class="sourceLine" id="cb23-41" data-line-number="41">                w[j, i] <span class="op">=</span> w[i, j]</a>
<a class="sourceLine" id="cb23-42" data-line-number="42">            <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb23-43" data-line-number="43">                w[i, j] <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb23-44" data-line-number="44">    <span class="cf">return</span> w</a>
<a class="sourceLine" id="cb23-45" data-line-number="45"></a>
<a class="sourceLine" id="cb23-46" data-line-number="46"><span class="co"># 第二种计算相似度：对数似然函数</span></a>
<a class="sourceLine" id="cb23-47" data-line-number="47"><span class="kw">def</span> obtainK(a,b):</a>
<a class="sourceLine" id="cb23-48" data-line-number="48">    k11<span class="op">=</span><span class="dv">0</span></a>
<a class="sourceLine" id="cb23-49" data-line-number="49">    k12<span class="op">=</span><span class="dv">0</span></a>
<a class="sourceLine" id="cb23-50" data-line-number="50">    k21<span class="op">=</span><span class="dv">0</span></a>
<a class="sourceLine" id="cb23-51" data-line-number="51">    k22<span class="op">=</span><span class="dv">0</span></a>
<a class="sourceLine" id="cb23-52" data-line-number="52">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(a)):</a>
<a class="sourceLine" id="cb23-53" data-line-number="53">        <span class="cf">if</span> a[i]`b[i]<span class="op">!=</span><span class="dv">0</span>:</a>
<a class="sourceLine" id="cb23-54" data-line-number="54">            k11 <span class="op">+=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb23-55" data-line-number="55">        <span class="cf">if</span> a[i]`b[i]`<span class="dv">0</span>:</a>
<a class="sourceLine" id="cb23-56" data-line-number="56">            k22 <span class="op">+=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb23-57" data-line-number="57">        <span class="cf">if</span> a[i]<span class="op">!=</span><span class="dv">0</span> <span class="kw">and</span> b[i]`<span class="dv">0</span>:</a>
<a class="sourceLine" id="cb23-58" data-line-number="58">            k12 <span class="op">+=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb23-59" data-line-number="59">        <span class="cf">if</span> a[i]`<span class="dv">0</span> <span class="kw">and</span> b[i]<span class="op">!=</span><span class="dv">0</span>:</a>
<a class="sourceLine" id="cb23-60" data-line-number="60">            k21 <span class="op">+=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb23-61" data-line-number="61">    <span class="cf">return</span> k11,k12,k21,k22</a>
<a class="sourceLine" id="cb23-62" data-line-number="62"></a>
<a class="sourceLine" id="cb23-63" data-line-number="63"></a>
<a class="sourceLine" id="cb23-64" data-line-number="64"><span class="kw">def</span> Entropy(<span class="op">*</span>x):</a>
<a class="sourceLine" id="cb23-65" data-line-number="65">    <span class="bu">sum</span><span class="op">=</span><span class="fl">0.0</span></a>
<a class="sourceLine" id="cb23-66" data-line-number="66">    <span class="cf">for</span> i <span class="kw">in</span> x:</a>
<a class="sourceLine" id="cb23-67" data-line-number="67">        <span class="bu">sum</span> <span class="op">+=</span>i</a>
<a class="sourceLine" id="cb23-68" data-line-number="68">    result<span class="op">=</span><span class="fl">0.0</span></a>
<a class="sourceLine" id="cb23-69" data-line-number="69">    <span class="cf">for</span> j <span class="kw">in</span> x:</a>
<a class="sourceLine" id="cb23-70" data-line-number="70">        <span class="cf">if</span> j<span class="op">&lt;</span><span class="dv">0</span>:</a>
<a class="sourceLine" id="cb23-71" data-line-number="71">            <span class="cf">pass</span></a>
<a class="sourceLine" id="cb23-72" data-line-number="72">        pinghua<span class="op">=</span><span class="dv">1</span> <span class="cf">if</span> j`<span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb23-73" data-line-number="73">        result <span class="op">+=</span> j<span class="op">*</span>log((j<span class="op">+</span>pinghua)<span class="op">/</span><span class="bu">sum</span>)</a>
<a class="sourceLine" id="cb23-74" data-line-number="74">    <span class="cf">return</span> result</a>
<a class="sourceLine" id="cb23-75" data-line-number="75"></a>
<a class="sourceLine" id="cb23-76" data-line-number="76"><span class="kw">def</span> loglikelihood(N,a,b):</a>
<a class="sourceLine" id="cb23-77" data-line-number="77">    k11,k12,k21,k22 <span class="op">=</span> obtainK(a, b)</a>
<a class="sourceLine" id="cb23-78" data-line-number="78">    rowEntropy<span class="op">=</span>Entropy(k11,k12)<span class="op">+</span>Entropy(k21,k22)</a>
<a class="sourceLine" id="cb23-79" data-line-number="79">    colEntropy<span class="op">=</span> Entropy(k11,k21)<span class="op">+</span>Entropy(k12,k22)</a>
<a class="sourceLine" id="cb23-80" data-line-number="80">    matEntropy<span class="op">=</span>Entropy(k11,k12,k21,k22)</a>
<a class="sourceLine" id="cb23-81" data-line-number="81">    sim<span class="op">=-</span><span class="dv">2</span><span class="op">*</span>(matEntropy<span class="op">-</span>colEntropy<span class="op">-</span>rowEntropy)</a>
<a class="sourceLine" id="cb23-82" data-line-number="82">    <span class="cf">return</span> sim</a>
<a class="sourceLine" id="cb23-83" data-line-number="83"></a>
<a class="sourceLine" id="cb23-84" data-line-number="84"></a>
<a class="sourceLine" id="cb23-85" data-line-number="85"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb23-86" data-line-number="86"><span class="co">基于用户的协同过滤算法</span></a>
<a class="sourceLine" id="cb23-87" data-line-number="87"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb23-88" data-line-number="88"><span class="kw">def</span> user_based_recommend(data, w, user):</a>
<a class="sourceLine" id="cb23-89" data-line-number="89">    <span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb23-90" data-line-number="90"><span class="co">    :param data(mat): 用户商品矩阵</span></a>
<a class="sourceLine" id="cb23-91" data-line-number="91"><span class="co">    :param w(mat): 用户相似度矩阵</span></a>
<a class="sourceLine" id="cb23-92" data-line-number="92"><span class="co">    :param user(int): 用户编号</span></a>
<a class="sourceLine" id="cb23-93" data-line-number="93"><span class="co">    :return: predict(list): 推荐列表</span></a>
<a class="sourceLine" id="cb23-94" data-line-number="94"><span class="co">    &quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb23-95" data-line-number="95">    m, n <span class="op">=</span> np.shape(data)  <span class="co"># m是用户，n是商品数</span></a>
<a class="sourceLine" id="cb23-96" data-line-number="96">    user_product <span class="op">=</span> data[user, ]    <span class="co"># 用 user=0 这一行：商品信息</span></a>
<a class="sourceLine" id="cb23-97" data-line-number="97">    <span class="bu">print</span>(<span class="st">&quot;用user的买过商品信息:&quot;</span>,user_product,m,n)  <span class="co"># user0的商品信息: [[4 3 0 5 0]]，这说明只有商品3，商品5他没买过</span></a>
<a class="sourceLine" id="cb23-98" data-line-number="98"></a>
<a class="sourceLine" id="cb23-99" data-line-number="99">    <span class="co">&quot;&quot;&quot;找到用户user没有打分的商品，这是候选的推荐项&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb23-100" data-line-number="100">    not_score <span class="op">=</span> []</a>
<a class="sourceLine" id="cb23-101" data-line-number="101">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</a>
<a class="sourceLine" id="cb23-102" data-line-number="102">        <span class="cf">if</span> user_product[<span class="dv">0</span>, i] ` <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb23-103" data-line-number="103">            not_score.append(i)</a>
<a class="sourceLine" id="cb23-104" data-line-number="104"></a>
<a class="sourceLine" id="cb23-105" data-line-number="105">    <span class="co">&quot;&quot;&quot;对没有打分的商品进行预测&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb23-106" data-line-number="106">    predict <span class="op">=</span> {}</a>
<a class="sourceLine" id="cb23-107" data-line-number="107">    <span class="cf">for</span> x <span class="kw">in</span> not_score:</a>
<a class="sourceLine" id="cb23-108" data-line-number="108">        item <span class="op">=</span> data[:, x]    <span class="co"># 所有用户对该商品的打分信息  x=0: item = [[0], [0], [0], [3], [4]]</span></a>
<a class="sourceLine" id="cb23-109" data-line-number="109">        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(m):  <span class="co"># 遍历每一个用户对该商品的评分【这里包含了被推荐人，因为他的权重是0，所以不影响最终的加权权重】</span></a>
<a class="sourceLine" id="cb23-110" data-line-number="110">            <span class="cf">if</span> item[i, <span class="dv">0</span>] <span class="op">!=</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb23-111" data-line-number="111">                <span class="cf">if</span> x <span class="kw">not</span> <span class="kw">in</span> predict:</a>
<a class="sourceLine" id="cb23-112" data-line-number="112">                    <span class="co">&quot;&quot;&quot; 用户i与该用户相似度*用户i对该商品的评分  &quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb23-113" data-line-number="113">                    predict[x] <span class="op">=</span> w[user, i] <span class="op">*</span> item[i, <span class="dv">0</span>]</a>
<a class="sourceLine" id="cb23-114" data-line-number="114">                <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb23-115" data-line-number="115">                    predict[x] <span class="op">=</span> predict[x] <span class="op">+</span> w[user, i] <span class="op">*</span> item[i, <span class="dv">0</span>]</a>
<a class="sourceLine" id="cb23-116" data-line-number="116"></a>
<a class="sourceLine" id="cb23-117" data-line-number="117">    <span class="co">&quot;&quot;&quot;按照预测值大小排序&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb23-118" data-line-number="118">    <span class="cf">return</span> <span class="bu">sorted</span>(<span class="bu">list</span>(predict.items()), key<span class="op">=</span><span class="kw">lambda</span> p: p[<span class="dv">1</span>], reverse<span class="op">=</span><span class="va">True</span>)</a>
<a class="sourceLine" id="cb23-119" data-line-number="119"></a>
<a class="sourceLine" id="cb23-120" data-line-number="120"></a>
<a class="sourceLine" id="cb23-121" data-line-number="121"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb23-122" data-line-number="122"><span class="co">基于用户的协同过滤算法</span></a>
<a class="sourceLine" id="cb23-123" data-line-number="123"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb23-124" data-line-number="124"><span class="kw">def</span> item_based_recommend(data, w, user):</a>
<a class="sourceLine" id="cb23-125" data-line-number="125">    <span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb23-126" data-line-number="126"><span class="co">    :param data(mat): 用户商品矩阵</span></a>
<a class="sourceLine" id="cb23-127" data-line-number="127"><span class="co">    :param w(mat): 用户相似度矩阵</span></a>
<a class="sourceLine" id="cb23-128" data-line-number="128"><span class="co">    :param user(int): 用户编号</span></a>
<a class="sourceLine" id="cb23-129" data-line-number="129"><span class="co">    :return: predict(list): 推荐列表</span></a>
<a class="sourceLine" id="cb23-130" data-line-number="130"><span class="co">    &quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb23-131" data-line-number="131">    m, n <span class="op">=</span> np.shape(data)  <span class="co"># m为商品数量, n为用户数量</span></a>
<a class="sourceLine" id="cb23-132" data-line-number="132"></a>
<a class="sourceLine" id="cb23-133" data-line-number="133">    user_product <span class="op">=</span> data[:, user].T  <span class="co"># 用user的商品信息</span></a>
<a class="sourceLine" id="cb23-134" data-line-number="134"></a>
<a class="sourceLine" id="cb23-135" data-line-number="135">    not_score <span class="op">=</span> []  <span class="co"># 找到用户user没有打分的商品  [在他未购买的里面选出推荐项]</span></a>
<a class="sourceLine" id="cb23-136" data-line-number="136">    <span class="co">&quot;&quot;&quot;变量该用户对应的商品，找到没有评分的&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb23-137" data-line-number="137">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(m):</a>
<a class="sourceLine" id="cb23-138" data-line-number="138">        <span class="cf">if</span> user_product[<span class="dv">0</span>, i] ` <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb23-139" data-line-number="139">            not_score.append(i)</a>
<a class="sourceLine" id="cb23-140" data-line-number="140"></a>
<a class="sourceLine" id="cb23-141" data-line-number="141">    <span class="co">&quot;&quot;&quot;对没有打分的商品进行预测&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb23-142" data-line-number="142">    predict <span class="op">=</span> {}</a>
<a class="sourceLine" id="cb23-143" data-line-number="143">    <span class="cf">for</span> x <span class="kw">in</span> not_score:</a>
<a class="sourceLine" id="cb23-144" data-line-number="144">        <span class="co"># 该user对该商品的打分信息</span></a>
<a class="sourceLine" id="cb23-145" data-line-number="145">        item <span class="op">=</span> user_product</a>
<a class="sourceLine" id="cb23-146" data-line-number="146">        <span class="co"># 遍历所有g商品</span></a>
<a class="sourceLine" id="cb23-147" data-line-number="147">        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(m):</a>
<a class="sourceLine" id="cb23-148" data-line-number="148">            <span class="co"># 该用户买过这个商品</span></a>
<a class="sourceLine" id="cb23-149" data-line-number="149">            <span class="cf">if</span> item[<span class="dv">0</span>, i] <span class="op">!=</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb23-150" data-line-number="150">                <span class="cf">if</span> x <span class="kw">not</span> <span class="kw">in</span> predict:</a>
<a class="sourceLine" id="cb23-151" data-line-number="151">                    <span class="co">&quot;&quot;&quot;推荐权值 = 该商品与这个商品之间相似度*该用户过的商品的评分&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb23-152" data-line-number="152">                    predict[x] <span class="op">=</span> w[x, i] <span class="op">*</span> item[<span class="dv">0</span>, i]</a>
<a class="sourceLine" id="cb23-153" data-line-number="153">                <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb23-154" data-line-number="154">                    predict[x] <span class="op">=</span> predict[x] <span class="op">+</span> w[x, i] <span class="op">*</span> item[<span class="dv">0</span>, i]</a>
<a class="sourceLine" id="cb23-155" data-line-number="155"></a>
<a class="sourceLine" id="cb23-156" data-line-number="156">    <span class="co"># 按照预测值大小排序</span></a>
<a class="sourceLine" id="cb23-157" data-line-number="157">    <span class="cf">return</span> <span class="bu">sorted</span>(<span class="bu">list</span>(predict.items()), key<span class="op">=</span><span class="kw">lambda</span> p: p[<span class="dv">1</span>], reverse<span class="op">=</span><span class="va">True</span>)</a>
<a class="sourceLine" id="cb23-158" data-line-number="158"></a>
<a class="sourceLine" id="cb23-159" data-line-number="159"></a>
<a class="sourceLine" id="cb23-160" data-line-number="160"><span class="co"># 1、定义：我们获取并处理后的数据的格式</span></a>
<a class="sourceLine" id="cb23-161" data-line-number="161">    <span class="co"># 一行，表示某用户对各商品的评分</span></a>
<a class="sourceLine" id="cb23-162" data-line-number="162">    <span class="co"># 一列，代表不同用户对同一个商品的打分情况，若给用户没有评价过该商品，则表示这个是未购买过</span></a>
<a class="sourceLine" id="cb23-163" data-line-number="163"><span class="co">&#39;&#39;&#39;</span></a>
<a class="sourceLine" id="cb23-164" data-line-number="164"><span class="co">        商品1,商品2,商品3,商品4,商品5  </span></a>
<a class="sourceLine" id="cb23-165" data-line-number="165"><span class="co">用户A   [4, 3, 0, 5, 0],</span></a>
<a class="sourceLine" id="cb23-166" data-line-number="166"><span class="co">用户B   [5, 0, 4, 4, 0],</span></a>
<a class="sourceLine" id="cb23-167" data-line-number="167"><span class="co">        [4, 0, 5, 0, 3],</span></a>
<a class="sourceLine" id="cb23-168" data-line-number="168"><span class="co">        [2, 3, 0, 1, 0],</span></a>
<a class="sourceLine" id="cb23-169" data-line-number="169"><span class="co">        [0,4, 2, 0, 5]</span></a>
<a class="sourceLine" id="cb23-170" data-line-number="170"><span class="co">&#39;&#39;&#39;</span></a>
<a class="sourceLine" id="cb23-171" data-line-number="171"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb23-172" data-line-number="172"><span class="co">一、UserCF 基于用户的协同过滤算法:</span></a>
<a class="sourceLine" id="cb23-173" data-line-number="173"><span class="co">首先计算用户-用户之间的相似度 w</span></a>
<a class="sourceLine" id="cb23-174" data-line-number="174"><span class="co">找出该用户u没买过的商品I`候选推荐数据集</span></a>
<a class="sourceLine" id="cb23-175" data-line-number="175"><span class="co">遍历所有用户[所有买过I商品的用户U]：求和{ 用户U与用户u的相似度 * 用户U对商品I的评分 }</span></a>
<a class="sourceLine" id="cb23-176" data-line-number="176"><span class="co">&lt;利用所有买过候选集商品的用户评分*用户与该用户的相似度--&gt;得出j候选集的得分&gt;</span></a>
<a class="sourceLine" id="cb23-177" data-line-number="177"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb23-178" data-line-number="178">User1 <span class="op">=</span> np.mat([        <span class="co"># 用户-商品-评分矩阵</span></a>
<a class="sourceLine" id="cb23-179" data-line-number="179">    [<span class="dv">4</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>],</a>
<a class="sourceLine" id="cb23-180" data-line-number="180">    [<span class="dv">5</span>, <span class="dv">0</span>, <span class="dv">4</span>, <span class="dv">4</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">3</span>],</a>
<a class="sourceLine" id="cb23-181" data-line-number="181">    [<span class="dv">4</span>, <span class="dv">0</span>, <span class="dv">5</span>, <span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">2</span>],</a>
<a class="sourceLine" id="cb23-182" data-line-number="182">    [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">1</span>],</a>
<a class="sourceLine" id="cb23-183" data-line-number="183">    [<span class="dv">0</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">4</span>],</a>
<a class="sourceLine" id="cb23-184" data-line-number="184">])</a>
<a class="sourceLine" id="cb23-185" data-line-number="185">w <span class="op">=</span> similarity(np.mat(User1))  <span class="co"># 用户之间相似性矩阵：计算任意用户之间的余弦距离</span></a>
<a class="sourceLine" id="cb23-186" data-line-number="186"><span class="bu">print</span>(<span class="st">&quot;用户之间相似度：</span><span class="ch">\n</span><span class="st">&quot;</span>,w)</a>
<a class="sourceLine" id="cb23-187" data-line-number="187">predict <span class="op">=</span> user_based_recommend(User1, w, <span class="dv">0</span>)  <span class="co"># 给U0用户推荐商品(计算出未评分商品的顺序)：</span></a>
<a class="sourceLine" id="cb23-188" data-line-number="188"><span class="bu">print</span>(predict)</a>
<a class="sourceLine" id="cb23-189" data-line-number="189"></a>
<a class="sourceLine" id="cb23-190" data-line-number="190"></a>
<a class="sourceLine" id="cb23-191" data-line-number="191"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb23-192" data-line-number="192"><span class="co">二、ItemCF</span></a>
<a class="sourceLine" id="cb23-193" data-line-number="193"><span class="co">基于项的协同过滤算法:是通过基于项的相似性来进行计算的</span></a>
<a class="sourceLine" id="cb23-194" data-line-number="194"><span class="co">计算商品-商品之间的相似度</span></a>
<a class="sourceLine" id="cb23-195" data-line-number="195"><span class="co">找出该用户u没买过的商品I`候选推荐数据集</span></a>
<a class="sourceLine" id="cb23-196" data-line-number="196"><span class="co">遍历所有商品J[该用户u买过的商品J]`&gt;求和{ 商品I与商品J的相似度 * 用户u对商品J的评分 }</span></a>
<a class="sourceLine" id="cb23-197" data-line-number="197"><span class="co">&lt;只利用u自己的购买过的商品，然后根据商品之间的相似度*自己对该商品的评分---得到该候选商品的得分&gt;</span></a>
<a class="sourceLine" id="cb23-198" data-line-number="198"><span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb23-199" data-line-number="199">data <span class="op">=</span> User1.T  <span class="co"># 首先将用户-商品矩阵，转置成 商品-用户矩阵</span></a>
<a class="sourceLine" id="cb23-200" data-line-number="200"><span class="bu">print</span>(<span class="st">&quot;ItemCF:商品-用户-评分：</span><span class="ch">\n</span><span class="st">&quot;</span>,data)</a>
<a class="sourceLine" id="cb23-201" data-line-number="201">w <span class="op">=</span> similarity(data)  <span class="co"># 然后计算 商品之间相似性矩阵</span></a>
<a class="sourceLine" id="cb23-202" data-line-number="202"><span class="bu">print</span>(<span class="st">&quot;商品之间相似度：</span><span class="ch">\n</span><span class="st">&quot;</span>,w)</a>
<a class="sourceLine" id="cb23-203" data-line-number="203">predict <span class="op">=</span> item_based_recommend(data, w, <span class="dv">0</span>)  <span class="co"># 给U0用户推荐商品：</span></a>
<a class="sourceLine" id="cb23-204" data-line-number="204"><span class="bu">print</span>(predict)</a></code></pre></div>
