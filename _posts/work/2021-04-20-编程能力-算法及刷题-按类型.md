---
layout: post
Comment: true
mathjax: true
author: "Sun"
header-style: text
header-img: img/computer-code.jpg
tags:
  - Python
  - 数据结构
  - 算法
  - 计科基础
  - 编程能力
catalog: true
---

# 概要及参考书

## 相关笔记

[python相关](/Users/king/sunqinghu.github.io/_posts/2021-03-17-编程能力-python相关 .md)

## 规范
1. 每个题不超过15min思考时间，整个题做题时间不超过30min。
2. 按类别刷题时，可以先看书和相关知识点再刷题。

## 刷题方法

<img src="/img/in-post/20_07/v2-58b8892ba8db8bb452db88ec329e1dcd_1440w-20200808155245207.jpg" alt="img" style="zoom: 67%;" />

1、√ 建议未刷过题的新人按着顺序来。 

2、[-] 基本熟悉知识点后，可以一类类**标签强攻**。

3、面试前的一个月可以只做『Hard』标签的题目，因为一般两遍之后对于大部分『Medium』难度以下的题目都是肌肉记忆了。多练习『Hard』类题目可以让自己的思路更开阔，因为很多题目使用的奇淫巧技让人惊讶

4、善用收藏夹，要养成『**一道题第二次练习尚不能解就加入收藏夹**』的习惯，且需要定期清空收藏夹：每道题不需提示下通过两次后才能移出收藏夹。

5、面试前可以购买会员，**按照公司的标签来练习**，也可以结合白板练习。练习的优先级分别是：**即将面试公司的题目、收藏夹里的旧题目、剩余的新题。**

**6、冲刺阶段的练习请尽量不要打开题型标签，给自己思考的空间。**

7、如果真的刷了三遍以上还没法达到理想目标，那么一定是学习方法出了问题，请多总结

## 算法思想

各种数据结构的遍历 + 访问无非两种形式:线性的和非线性的。线性就是 for/while 迭代为代表,非线性就是递归为代表。再具体一步,无非几种框架。

所谓框架,就是套路。不管增删查改,这些代码都是永远无法脱离的结构, 你可以把这个结构作为大纲,根据具体问题在框架上添加代码就行。

## 刷题建议

1. 先刷二叉树
   1.  因为二叉树是最容易培养框架思维的,而且大部分算法技巧,本质上都是树的遍历问学习算法和刷题的框架思维。
   2. 对于一个理解二叉树的人来说,刷一道二叉树的题目花不了多⻓时间。那么如果你对刷题无从下手或者有畏惧心理,不妨从二叉树下手,前 10 道也许有点难受;结合框架再做 20 道,也许你就有点自己的理解了;刷完整个专题,再去做什么回溯动规分治专题,你就会发现只要涉及递归的问题,都是树的问题

## 知识点总结图解


### 时间复杂度(大O时间)
<img src="https://cdn.jsdelivr.net/gh/sunqinghu/PicRepo/img/2020/20201023173355.png" style="zoom: 67%;" />

### 散列表去重和缓存数据
* Python中的散列表为**字典**,散列表将键映射到值


```python
"""
防止重复
"""
voted = {} 
def check_voter(name):
    if voted.get(name):
        print ("kick them out!")
    else:
        voted[name] = True
        print ("let them vote!")
```

    In [3]: check_voter('tom')
    let them vote!
    
    In [4]: check_voter('tom')
    kick them out!

```python
"""
缓存数据
"""
cache = {} 
def get_page(url):    
    if cache.get(url):
        return cache[url]   
    else:     
        data = get_data_from_server(url)     
        cache[url] = data     
        return data
```

### 广度优先搜索(图)

```python
"""
实现图
"""
# map "you" to a list
graph = {} 
graph["you"] = ["alice", "bob", "claire"]
graph["bob"] = ["anuj", "peggy"] 
graph["alice"] = ["peggy"] 
graph["claire"] = ["thom", "jonny"] 
graph["anuj"] = [] 
graph["peggy"] = [] 
graph["thom"] = [] 
graph["jonny"] = []
graph
```


    {'you': ['alice', 'bob', 'claire'],
     'bob': ['anuj', 'peggy'],
     'alice': ['peggy'],
     'claire': ['thom', 'jonny'],
     'anuj': [],
     'peggy': [],
     'thom': [],
     'jonny': []}



<img src="https://cdn.jsdelivr.net/gh/sunqinghu/PicRepo/img/2020/20201023173422.png" style="zoom:50%;" />


```python
"""
实现算法
"""
from collections import deque 

def person_is_seller(name):     
    return name[-1] == 'm' # a seller whose name finashed by 'm'

def search(name):
    search_queue = deque()   # 可使用函数deque来创建一个双端队列
    search_queue += graph["you"]
    searched = [] # use to record the person who have searched -- it is important
    while search_queue:     
        person = search_queue.popleft()
        if not person in searched:  # only inspect while did not have searched 
            if person_is_seller(person): 
                print(person + " is a mango seller!" )
                return True 
            else: 
                search_queue += graph[person] 
                searched.append(person)
    return False
search("you")
```

    thom is a mango seller!
    
    True

#### **算法原理**

<img src="https://cdn.jsdelivr.net/gh/sunqinghu/PicRepo/img/2020/20201023173450.png" style="zoom:50%;" />

### 狄克斯特拉算法(计算有权图)
<img src="https://cdn.jsdelivr.net/gh/sunqinghu/PicRepo/img/2020/20201023173529.png" style="zoom: 67%;" />


```python
"""
Graph hash table
"""
graph = {}
graph["start"] = {} 
graph["start"]["a"] = 6 
graph["start"]["b"] = 2

graph["a"] = {} 
graph["a"]["fin"] = 1 

graph["b"] = {} 
graph["b"]["a"] = 3 
graph["b"]["fin"] = 5

graph["fin"] = {} # 终结点无邻居
```


    In [9]: # 获取起点的所有邻居
       ...: graph["start"].keys()
    Out[9]: dict_keys(['a', 'b'])
    
    In [10]: # 获得权重
        ...: graph["start"]["a"]
    Out[10]: 6




```python
"""
Costs hash table
"""
infinity = float("inf") 

costs = {} 
costs["a"] = 6 
costs["b"] = 2 
# 不知道到终点需要多长时间。对于还不知道的开销,你将其设置为无穷大。
costs["fin"] = infinity 
costs["fin"]
```


    inf




```python
"""
Parents hash table
"""
parents = {} 
parents["a"] = "start" 
parents["b"] = "start" 
parents["fin"] = None
# 最后需要一个数组,用于记录处理过的节点,你不用处理多次。  
processed = []
```

#### **算法原理**

<img src="https://cdn.jsdelivr.net/gh/sunqinghu/PicRepo/img/2020/20201023173550.png" style="zoom: 67%;" />  


```python
def find_lowest_cost_node(costs):     
    lowest_cost = float("inf")      
    lowest_cost_node = None     
    for node in costs:  
        cost = costs[node] 
        if cost < lowest_cost and node not in processed: 
            lowest_cost = cost 
            lowest_cost_node = node     
    return lowest_cost_node

node = find_lowest_cost_node(costs) 

while node is not None:     
    cost = costs[node]     
    neighbors = graph[node]     
    for n in neighbors.keys(): 
        new_cost = cost + neighbors[n] 
        if costs[n] > new_cost: 
            costs[n] = new_cost 
            parents[n] = node     
    processed.append(node)     
    node = find_lowest_cost_node(costs)
print(cost)
```

    6


![](https://cdn.jsdelivr.net/gh/sunqinghu/PicRepo/img/2020/20201023173808.png)


```python
# A -- 不对
"""
Graph hash table
"""
graph = {}
graph["start"] = {}
graph["start"]["a"] = 5
graph["start"]["b"] = 2
graph["a"] = {}
graph["a"]["c"] = 4
graph["a"]["d"] = 2
graph["b"] = {}     # init， important
graph["b"]["a"] = 8
graph["b"]["d"] = 7
graph["c"] = {}
graph["c"]["d"] = 6
graph["c"]["fin"] = 3
graph["d"] = {}
graph["d"]["fin"] = 1
graph["fin"] = {} # 终结点无邻居

"""
Costs hash table：cost to start
"""
infinity = float("inf")

costs = {}
costs["a"] = infinity
costs["b"] = 2
# 不知道到终点需要多长时间。对于还不知道的开销,你将其设置为无穷大。
costs["c"] = infinity
costs["d"] = infinity
costs["fin"] = infinity

"""
Parents hash table: only record the cost that knows
"""
parents = {}
parents["a"] = None
parents["b"] = "start"
parents["c"] = None
parents["d"] = None
parents["fin"] = None
# 最后需要一个数组,用于记录处理过的节点,你不用处理多次。
processed = []

def find_lowest_cost_node(costs):
    lowest_cost = float("inf")
    lowest_cost_node = None
    for node in costs:
        cost = costs[node]
        if cost < lowest_cost and node not in processed:
            lowest_cost = cost
            lowest_cost_node = node
    return lowest_cost_node

node = find_lowest_cost_node(costs)
while node is not None:
    cost = costs[node]
    neighbors = graph[node]
    for n in neighbors.keys():
        
        new_cost = cost + neighbors[n]
        if costs[n] > new_cost:
            costs[n] = new_cost
            parents[n] = node
        print(costs[n])
    processed.append(node)
    node = find_lowest_cost_node(costs)


```

    10
    9
    10
    14
    9
    9
    10


### 贪婪算法
* 处理没有快速算法的问题 -- NP完全问题
* 每步都寻找局部最优解

集合覆盖问题

具体方法如下。  

(1) 列出每个可能的广播台集合,这被称为幂集(power set)。可能的子集有2n个。 

(2) 在这些集合中,选出覆盖全美50个州的最小集合。

![](https://cdn.jsdelivr.net/gh/sunqinghu/PicRepo/img/2020/20201023173833.png)


```python
# 不对
states_needed = set(["mt", "wa", "or", "id", "nv", "ut", "ca", "az"])

# 有可供选择的广播台清单,我选择使用散列表来表示它。 
stations = {} 
stations["kone"] = set(["id", "nv", "ut"]) 
stations["ktwo"] = set(["wa", "id", "mt"]) 
stations["kthree"] = set(["or", "nv", "ca"]) 
stations["kfour"] = set(["nv", "ut"]) 
stations["kfive"] = set(["ca", "az"])

final_stations = set() 

while states_needed:   
    best_station = None  # 存储最优  
    states_covered = set()
    for station, states_for_station in stations.items():
        covered = states_needed & states_for_station 
        if len(covered) > len(states_covered):   
            best_station = station   
            states_covered = covered
            
states_needed -= states_covered 
final_stations.add(best_station) 
print(final_stations)
```

### 动态规划
* 只能处理没有相互依赖关系
* 横向：加入新增商品价值 与 没加入该商品时最大价值(上一行) 比较，选择大的

### 树 
![](https://cdn.jsdelivr.net/gh/sunqinghu/PicRepo/img/2020/20201023174120.png)
* 不能随机访问
* 平衡时效果才好

### 分布式算法（MapReduce)

- 并行算法的一种

* 可通过流行的开源工具Apache Hadoop来使用
* 基于两个简单的理念: 映射(map)函数和 归并(reduce)函数。


```python
# 映射函数 map
# 如果有100台计算机,而map能够自动将工作分配给这些计算机去完成就好了。
# 这样就可同时下载100个页面,下载速度将快得多!这就是MapReduce中“映射”部分基于的理念。
arr1 = [1, 2, 3, 4, 5]
arr2 = map(lambda x: 2 * x, arr1)
arr2
```


```python
map?
```


```python
# 归并reduce（)
arr1 = [1, 2, 3, 4, 5] 
reduce(lambda x,y: x+y, arr1)
```


```python
# nums = [3,4,5,1,2]
nums = [2,2,2,0,1]
# nums = [10,1,10,10,10]
```


```python
class Solution:
    def minArray(self, numbers) -> int:
        a = 0
        b = len(numbers)-1
        while a<b:
            # prior: numbers[a] > numbers[b]
            i = (a+b)//2
            # Notice compare the value of b
            # Notice need to add 1 to avoid endless loop
            if numbers[i] > numbers[b]:
                a = i + 1
            elif numbers[i] < numbers[b]:
                b = i
            # Notice this situation
            else: 
                b -= 1
        return numbers[b]
```


```python
solution = Solution()
result = solution.minArray(nums)
result
```

# 注意点

注意 == 和 =

注意如果使用 append(var) 或 = var， 如果var会改变，不能引用！而要用深拷贝或var[:]

> 如回溯算法、dfs算法、全排列里的路径

注意子函数里的变量有两种定义方式： 1. 传入参数 2.全局变量

查找时可以考虑用 $set$：定义更容易；复杂度比较低，为$O(log(n))$。虽然 $dict$复杂度为 $O(1)$，但是由于有哈希化的过程，所以时间通常也没有少。

如果遇到很难的动态规划题很难想到动态规划方程，可以考虑用回溯方法来做。（实际dp ≈ 回溯+大幅剪枝，如dp表，备忘录）

DFS 可理解为回溯

BFS 一般用队列存储节点周围的结点

extend 使用方式：`list.extend([1,2,3])`

转换类型：1. `[int(i) for i in strings]` 2. `list(map(lambda x:int(x),deadends))`

---

`yield` 用法：

```python
def fab(max): 
    n, a, b = 0, 0, 1 
    while n < max: 
        yield b      # 使用 yield
        # print b 
        a, b = b, a + b 
        n = n + 1
 
for n in fab(5): 
    print n
```

yield 的作用就是把一个函数变成一个 generator，带有 yield 的函数不再是一个普通函数，Python 解释器会将其视为一个 generator，调用 fab(5) 不会执行 fab 函数，而是返回一个 iterable 对象。可以调用next方法。

---

Counter函数：

我们先看一个简单的例子：

```javascript
#统计词频
colors = ['red', 'blue', 'red', 'green', 'blue', 'blue']
result = {}
for color in colors:
    if result.get(color)==None:
        result[color]=1
    else:
        result[color]+=1
print (result)
#{'red': 2, 'blue': 3, 'green': 1}
12345678910
```

下面我们看用

怎么实现：

```javascript
from collections import Counter
colors = ['red', 'blue', 'red', 'green', 'blue', 'blue']
c = Counter(colors)
print (dict(c))
1234
```

显然代码更加简单了，也更容易读和维护了。

# Leetcode按类型

## 未分类类型

### ✅(1.5h) [8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)



请你来实现一个 `atoi` 函数，使其能将字符串转换成整数。

首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：

  * 如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。
  * 假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。
  * 该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。

注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。

在任何情况下，若函数不能进行有效的转换时，请返回 0 。

**提示：**

  * 本题中的空白字符只包括空格字符 `' '` 。
  * 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。

```python
class Solution:
    def helper(self,s):
        for i, word in enumerate(s):
            if word not in '1234567890':
                return int(s[:i]) 
        return int(s)

    def myAtoi(self, s: str) -> int:
        for i, word in enumerate(s):
            if word not in ' -+1234567890':
                return 0
            elif word in '-+':
                if  len(s) > i+1  and s[i+1] in '1234567890':
                    res = self.helper(s[i+1:]) * -1 if word is '-' else self.helper(s[i+1:])
                    return max( min( res, 2147483647), -2147483648)
                else: return 0
            elif word  in '1234567890':
                res =  self.helper(s[i:])
                return max( min( res, 2147483647), -2147483648)
        return 0
    
        
## 法2  正则  34%
    # def myAtoi(self, s: str) -> int:
    #     return max(min(int(*re.findall('^[\+\-]?\d+', s.lstrip())), 2**31 - 1), -2**31)
```

### ✅(1.5h) [12. 整数转罗马数字](https://leetcode-cn.com/problems/integer-to-roman/)

罗马数字包含以下七种字符： `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。

**字符** **数值**
I 	1 
V 	5 
X 	10 
L 	50 
C 	100 
D	 500 
M 	1000

例如， 罗马数字 2 写做 `II` ，即为两个并列的 1。12 写做 `XII` ，即为 `X` + `II` 。 27 写做  `XXVII`, 即为 `XX` + `V` + `II` 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：

  * `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。
  * `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 
  * `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。

给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。
```
示例 1:

输入: 3
输出: "III"

示例 2:

输入: 4
输出: "IV"

示例 3:

输入: 9
输出: "IX"

示例 4:

输入: 58
输出: "LVIII"
解释: L = 50, V = 5, III = 3.

示例 5:

输入: 1994
输出: "MCMXCIV"
解释: M = 1000, CM = 900, XC = 90, IV = 4.
```

### ✅(50m) [13. 罗马数字转整数](https://leetcode-cn.com/problems/roman-to-integer/)

罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。
    
    **字符** **数值** I 1 V 5 X 10 L 50 C 100 D 500 M 1000

例如， 罗马数字 2 写做 `II` ，即为两个并列的 1。12 写做 `XII` ，即为 `X` + `II` 。 27 写做  `XXVII`, 即为 `XX` + `V` + `II` 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：

  * `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。
  * `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 
  * `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。

给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。

```
示例 1:

输入: "III"
输出: 3

示例 2:

输入: "IV"
输出: 4

示例 3:

输入: "IX"
输出: 9

示例 4:

输入: "LVIII"
输出: 58
解释: L = 50, V= 5, III = 3.

示例 5:

输入: "MCMXCIV"
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.

```

### ✅(30m) [14. 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

```
示例 1:

输入: ["flower","flow","flight"]
输出: "fl"

示例 2:

输入: ["dog","racecar","car"]
输出: ""
解释: 输入不存在公共前缀。

```

所有输入只包含小写字母 `a-z` 。


### 🚩(30m) [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下(与电话按键相同)。注意 1 不对应任何字母。

![](https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png)

**示例:**
```  
    输入："23" 
    输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]. 
```

###  🚩 [6. 最接近的三数之和](https://leetcode-cn.com/problems/3sum-closest/)

难度中等627

给定一个包括 _n_ 个整数的数组 `nums`_ _和 一个目标值 `target`。找出 `nums`_ _中的三个整数，使得它们的和与 `target` 最接近。返回这三个数的和。假定每组输入只存在唯一答案。

```
示例：

输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。
```

### ✅ (2.5h) 42. 接雨水

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

![](https://cdn.jsdelivr.net/gh/sunqinghu/PicRepo/img/2020/20201023174142.png)

上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水(蓝色部分表示雨水)。 感谢 Marcos 贡献此图。

```
示例:

输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
```




```python
class Solution:
    def onelist(self, List):
        Dict1 = {}
        for i in range(len(List)):
            if List[i] not in Dict1:
                Dict1[List[i]]=[i] 
            else:
                Dict1[List[i]].append(i)
        Dict1 = dict(sorted(Dict1.items(), key=lambda Dict1:Dict1[0], reverse=True)) # 字典排序方法
        print(Dict1)        
        
        rainNum = 0
        p = 0
        for num, i in Dict1.items():
            for j in i:
                print('******\n',num,j)
                if j <= p:
                    continue
                count = num*(j-p-1)-sum(List[i] for i in range(p+1,j))
                print('p=',p,'count=',count)
                p = j
                rainNum += count
                print('p=',p,'rain=',rainNum)

        return rainNum
           
        
    def trap(self, height):
        nums = height
        if len(nums)==0: return 0
        max_num = max(nums)
        i_max = nums.index(max_num)
        list1 = nums[:i_max+1]
        list1.reverse()
        list2 = nums[i_max:]
        
        out1 = self.onelist(list1)
        out2 = self.onelist(list2)
        return out1 + out2
```


```python
nums = [0,1,0,2,1,0,1,3,2,1,2,1]
solution = Solution()
result = solution.trap(nums)
result
```

### ✅ (1.5h) 146. LRU缓存机制

运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。

获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值(总是正数)，否则返回 -1。
写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。

 

进阶:

你是否可以在 O(1) 时间复杂度内完成这两种操作？


```
示例:

LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // 返回  1
cache.put(3, 3);    // 该操作会使得关键字 2 作废
cache.get(2);       // 返回 -1 (未找到)
cache.put(4, 4);    // 该操作会使得关键字 1 作废
cache.get(1);       // 返回 -1 (未找到)
cache.get(3);       // 返回  3
cache.get(4);       // 返回  4
```


```python
class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cacheDict = dict()
        self.st = []  #???????
        
    def get(self, key: int) -> int:
        if  (key not in self.cacheDict.keys()): 
            return -1
        while key in self.st:    # 注意要删除重复值
            self.st.remove(key) # remove() 是删除指定值 
        self.st.append(key)
        return self.cacheDict[key]

    def put(self, key: int, value: int) -> None:
        if len(self.cacheDict) >= self.capacity and key not in self.cacheDict.keys():
            self.cacheDict.pop(self.st[-self.capacity]) 
        self.cacheDict[key] = value
        while key in self.st:
            self.st.remove(key) # remove() 是删除指定值 
        self.st.append(key)
        return 

# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)
```


```python
obj = LRUCache(1)
obj.put(0,1)
param_1 = obj.get(0)
print(param_1)
obj.put(2,2)
```

### 🚩(2.0h) 31. 下一个排列

实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列(即升序排列)。

必须原地修改，只允许使用额外常数空间。

```
以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
```

算法思路：

1. 将后面的大数与前面的小数字交换
2. 增加幅度尽量小
   1. 低位交换，从后向前找 ✅
   2. 找尽量接近(小)的大数替换 ✅
   3. 重置为升序排序 


```python
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        if len(nums) < 2: return 0
        for i in range(len(nums)-1,0,-1):
            if nums[i] > nums[i-1]: 
                nums[i:] = sorted(nums[i:])  
                for j in range(i, len(nums)):
                    if nums[j] > nums[i-1]:  # 找最接近的进行替换
                        nums[j], nums[i-1] = nums[i-1], nums[j]
                        break
                return
        nums.sort()
```


```python
from typing import List

nums = [1,3,2]
solution = Solution()
result = solution.nextPermutation(nums)
result
```

### ✅ (1.5h) 135. 分发糖果

老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。

你需要按照以下要求，帮助老师给这些孩子分发糖果：

每个孩子至少分配到 1 个糖果。
相邻的孩子中，评分高的孩子必须获得更多的糖果。
那么这样下来，老师至少需要准备多少颗糖果呢？

```
示例 1:

输入: [1,0,2]
输出: 5
解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。
示例 2:

输入: [1,2,2]
输出: 4
解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这已满足上述两个条件。
```

#### 2️⃣字典的方法


```python
# 自己做的，有点慢
class Solution:
    def candy(self, ratings: List[int]) -> int:
        if len(ratings) == 1: return 1
        # list to dict 用列表生成字典方法
        ratings_dict = {}  
        for i in range(len(ratings)):
            if ratings[i] not in ratings_dict.keys(): 
                ratings_dict[ratings[i]] = [i]
            else:
                ratings_dict[ratings[i]].append(i)
#         print(ratings_dict)
        # sort
        ratings_sorted = dict(sorted(ratings_dict.items(), key = lambda ratings_dict:ratings_dict[0])) # 字典排序方法
        print(ratings_sorted)
        
        cnt = 0
        candy = [0 for _ in range(len(ratings))]
        for key, indexs in ratings_sorted.items():
#             if cnt == 0: 
#                 candy[index] = 1 for index in indexs
#                 cnt = 1
#                 continue
            temps = []
            for index in indexs:
                if index == 0: 
                    temps.append(candy[index+1] + 1) 
                    continue
                if index == len(candy)-1: 
                    temps.append(candy[index-1] + 1)
                    continue
                temps.append(max(candy[index-1], candy[index+1]) + 1)
            cnt = 0
            for i in range(len(indexs)):
                candy[indexs[i]] = temps[i]   # 同时赋值
        return sum(candy)
```


```python
from typing import List

nums = [1,0,2,2]
solution = Solution()
result = solution.candy(nums)
result
```

#### 3️⃣满足左原则和满足右原则(贪心)

从左向右一次， 从右向左一次，取最大


```python
class Solution:
    def candy(self, ratings: List[int]) -> int:
        left = [1 for _ in range(len(ratings))]
        right = left[:]
        for i in range(1, len(ratings)):
            if ratings[i] > ratings[i - 1]: left[i] = left[i - 1] + 1
        count = left[-1]
        for i in range(len(ratings) - 2, -1, -1):
            if ratings[i] > ratings[i + 1]: right[i] = right[i + 1] + 1
            count += max(left[i], right[i])
        return count

```

### 🚩(1.5h) 440. 字典序的第K小数字

给定整数 n 和 k，找到 1 到 n 中字典序第 k 小的数字。

注意：1 ≤ k ≤ n ≤ 109。

```
示例 :

输入:
n: 13   k: 2

输出:
10

解释:
字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。
```


```python
class Solution:
    def findKthNumber(self, n: int, k: int) -> int:
        # prefix 前缀 n 上界
        p = 1
        prefix = 1
            
        while p < k:
            count += next_prefix - cur
            cur *= 10   # 10
            next_prefix *= 10  # 20
            
        return count
            
            
```


```python
from typing import List

nums = 
solution = Solution()
result = solution.maxArea(nums)
result
```

### 🚩200. 岛屿数量

给你一个由 '1'(陆地)和 '0'(水)组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

 

```
示例 1:

输入:
[
['1','1','1','1','0'],
['1','1','0','1','0'],
['1','1','0','0','0'],
['0','0','0','0','0']
]
输出: 1
示例 2:

输入:
[
['1','1','0','0','0'],
['1','1','0','0','0'],
['0','0','1','0','0'],
['0','0','0','1','1']
]
输出: 3
解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。
```



### ✅(40m) [89. 格雷编码](https://leetcode-cn.com/problems/gray-code/)

## 数组

### 数组遍历框架
```C++
数组遍历框架,典型的线性迭代结构: 
void traverse(int[] arr) 
{     
    for (int i = 0; i < arr.length; i++) {         
        // 迭代访问 arr[i]     
    } 
}      
```

### 总结

#### 标准数组生成字典及字典排序方法

```python
        ratings_dict = {}  
        for i in range(len(ratings)):
            if ratings[i] not in ratings_dict.keys(): 
                ratings_dict[ratings[i]] = [i]
            else:
                ratings_dict[ratings[i]].append(i)
        # sort
        ratings_sorted = dict(sorted(ratings_dict.items(), key = lambda ratings_dict:ratings_dict[0])) 
        print(ratings_sorted)
```

#### 集合移除左半部分方法

```python
while s[i] in lookup:
    lookup.remove(s[left])
```



### ✅ 3.寻找最长无重复字符串

给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 
```
shi'li：
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

#### 2️⃣


```python
# 自己写的
s = "abcabcbb"
lists = list(s)
start = 0
end = 0
noduplicate = []
length_max = 0
for i, item in enumerate(lists,1):
    if item not in noduplicate:
        length_new = i - start
        noduplicate.append(item)
        if length_new > length_max:
            length_max = length_new        
    else:
        start += noduplicate.index(item) + 1
length_max
```


```python
# 主要思想:滑动窗口 
s = "abcabcbb"
# s = "abca"
# s = "pwwkew"

class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        if not s: 0
        left = 0
        lookup = set()
        n = len(s)
        max_len = 0
        cur_len = 0
        for i in range(n):
            cur_len += 1
            while s[i] in lookup:
                lookup.remove(s[left])
                left += 1
                cur_len -= 1
            if cur_len > max_len:max_len = cur_len
            lookup.add(s[i])  # 新建了一个滑动窗口
        return max_len


solution = Solution() # 实例化!!!!!
solution.lengthOfLongestSubstring(s)
print((solution.lengthOfLongestSubstring(s)))
```

### ✅155. 最小栈
设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。

push(x) -- 将元素 x 推入栈中。
pop() -- 删除栈顶的元素。
top() -- 获取栈顶元素。
getMin() -- 检索栈中的最小元素。
```
示例:

MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```


```python
# 核心思想: 定义辅助栈helper() 提升查找最小值速度
class MinStack:

    def __init__(self):
        """
        initialize your data structure here.
        """
        self.mylist = []
        self.helper = []

    def push(self, x: int) -> None:
        self.mylist.append(x)
        if len(self.helper) == 0 or x <= self.helper[-1]:
            self.helper.append(x)

    def pop(self) -> None:
        top = self.mylist.pop()
        if self.helper and top == self.helper[-1]:
            self.helper.pop()
        return top

    def top(self) -> int:
        return self.mylist[-1]

    def getMin(self) -> int:
        # 注意此处不能是等于 否则会改变一个另一个也会变
        if self.helper:
             return self.helper[-1]
           


# Your MinStack object will be instantiated and called as such:
obj = MinStack()
obj.push(-2)
obj.push(0)
obj.push(-3)
# obj.mylist
# print(obj.getMin())
# obj.pop()
obj.mylist
# print(obj.top())
print((obj.getMin()))
```

### ✅ 169. 多数元素
给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。
```

示例 1:

输入: [3,2,3]
输出: 3
示例 2:

输入: [2,2,1,1,1,2,2]
输出: 2
```


```python
# 排序法,自己写的
class Solution:
    def majorityElement(self, nums) -> int:
        nums.sort()
        return nums[(len(nums)-1)//2]
        
nums = [2,2,1,1,1,2,2]
solution = Solution()
result = solution.majorityElement(nums)
print(result)
```


```python
# Boyer-Moore 投票算法
class Solution:
    def majorityElement(self, nums) -> int:
        count = 0
        candidate = None
        for num in nums:
            if count == 0:
                candidate = num
            count += (1 if num == candidate else -1)
        
        return candidate
        
        
nums = [2,2,1,1,1,2,2]
solution = Solution()
result = solution.majorityElement(nums)
print(result)
```

### ✅ 283. 移动零 
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

```
示例:

输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
说明:

必须在原数组上操作，不能拷贝额外的数组。
尽量减少操作次数。
```



```python
# 自己写的,费时 数组操作
class Solution:
    def moveZeroes(self, nums) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        count = 0
        while True:
            try:
                nums.remove(0)
                count += 1

            except:
                nums.extend([0]*count)
                break
        
nums = [0,1,0,3,12]
solution = Solution()
result = solution.moveZeroes(nums)
nums
```


```python
# 法2: 一次遍历,双指针,检测到0则交换,省时间
class Solution:
    def moveZeroes(self, nums) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        if not nums:
            return 0
        j = 0
        for i in range(len(nums)):
            if nums[i] != 0:   # 只有nums[i] != 0 时,j才会加1往前走
                nums[j],nums[i] == nums[i],nums[j]
                j += 1 
                
nums = [0,1,0,3,12]
solution = Solution()
result = solution.moveZeroes(nums)
nums
```

### ✅ 461. 汉明距离 
两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。

给出两个整数 x 和 y，计算它们之间的汉明距离。

注意：
0 ≤ x, y < 2^31.
```
示例:

输入: x = 1, y = 4

输出: 2

解释:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑  ↑

上面的箭头指出了对应二进制位不同的位置。
```


```python
class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        return bin(x^y).count('1')  # .count()  计数
        
x = 1
y = 14
solution = Solution()
result = solution.hammingDistance(x,y)
result
```

### ✅ 581. 最短无序连续子数组

**注意中括号[]不能随便用,要表示先后关系只能用()**

给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。

你找到的子数组应是最短的，请输出它的长度。
```
示例 1:

输入: [2, 6, 4, 8, 10, 9, 15]
输出: 5
解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。
说明 :

输入的数组长度范围在 [1, 10,000]。
输入的数组可能包含重复元素 ，所以升序的意思是<=。
```


```python

```


```python
class Solution:
    def findUnsortedSubarray(self, nums) -> int:
        nums_sorted = sorted(nums)
        print((nums,nums_sorted))
        if not [(nums > nums_sorted) - (nums < nums_sorted)]:
            return 0  
        else:
            end = 0
            start = 0
            for i in range(len(nums)):
                if nums[i] != nums_sorted[i]:
                    start = i
                    break
            for i in range(1,len(nums)):
                if nums[-i] != nums_sorted[-i]:
                    end = len(nums)-i
                    break

            length = end - start + 1
            return length

    
# nums = [2,6,4,8,9,22,15]
nums = [1,2,3,4]
solution = Solution()
result = solution.findUnsortedSubarray(nums)
result
```

### 🚩4. 寻找两个有序数组的中位数 
给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。

请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 nums1 和 nums2 不会同时为空。
``` python
示例 1:

nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0
示例 2:

nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5
```


#### 2️⃣ 


```python
nums1 = [1, 2]
nums2 = [3, 4]

```


```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        
```


```python
solution = Solution()
result = solution.findMedianSortedArrays(nums1,nums2)
result
```

### ✅(1.5h) [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

给你两个有序整数数组 _nums1 _和 _nums2_，请你将 _nums2 _合并到 _nums1 _中_，_使 _nums1 _成为一个有序数组。

 

**说明：**

  * 初始化 _nums1_ 和 _nums2_ 的元素数量分别为 _m_ 和 _n _。
  * 你可以假设 _nums1 _有足够的空间(空间大小大于或等于 _m + n_)来保存 _nums2_ 中的元素。

 

**示例：**
```
输入：
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出：[1,2,2,3,5,6]·
```


```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        i = m-1
        j = n-1
        while i>=0 and j>=0:
            if nums1[i] < nums2[j]:
                nums1[i+j+1] = nums2[j]
                j -= 1
            else:
                nums1[i+j+1] = nums1[i]
                i -= 1
        if j>=0:
            nums1[:j+1] = nums2[:j+1]


```


```python
# 法2
# 注意用深拷贝
        nums1[:] = nums1[:m] + nums2
        nums1.sort()
```

### 🚩33. 搜索旋转排序数组

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。

搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。

你可以假设数组中不存在重复的元素。

你的算法时间复杂度必须是 O(log n) 级别。

```
示例 1:

输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4
示例 2:

输入: nums = [4,5,6,7,0,1,2], target = 3
输出: -1
```


#### 2️⃣


```python
# logn → 二分法
class Solution:
    def search(self, nums, target: int) -> int:
        if not nums:
            return -1
        l, r = 0, len(nums) - 1
        while l <= r:
            mid = (l + r)//2
            if nums[mid] == target: return mid
            if nums[mid] > nums[0]:  # 边界条件是最左最右
                if nums[0] <= target < nums[mid]:  # 注意有等于
                    r = mid - 1
                else:
                    l = mid + 1
            else:
                if nums[len(nums)-1] >= target > nums[mid] :
                    l = mid + 1
                else: 
                    r = mid - 1
        return  -1
                
```


```python
from typing import List

nums = [4,5,6,7,0,1,2]
solution = Solution()
result = solution.search(nums, 0)
result
```

### ✅ (6m) 215. 数组中的第K个最大元素

在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

```
示例 1:

输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
示例 2:

输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
说明:

你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。
```


```python
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        nums.sort(reverse=True)
        return nums[k-1]
```


```python
from typing import List

nums = [3,2,1,5,6,4] 
solution = Solution()
result = solution.findKthLargest(nums ,2)
result
```

### ✅(05m)[674. 最长连续递增序列](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)

难度简单164

给定一个未经排序的整数数组，找到最长且 **连续递增的子序列**，并返回该序列的长度。

**连续递增的子序列** 可以由两个下标 `l` 和 `r`（`l < r`）确定，如果对于每个 `l <= i < r`，都有 `nums[i] < nums[i + 1]` ，那么子序列 `[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]` 就是连续递增子序列。

 

**示例 1：**

```
输入：nums = [1,3,5,4,7]
输出：3
解释：最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 
```

**示例 2：**

```
输入：nums = [2,2,2,2,2]
输出：1
解释：最长连续递增序列是 [2], 长度为1。
```

```python
class Solution:
    def findLengthOfLCIS(self, nums: List[int]) -> int:
        if not nums: return 0
        dp = [1 for i in range(len(nums))]

        for i in range(1, len(nums)):
            # for j in range(i):
                if nums[i] > nums[i-1]:
                    dp[i] = dp[i-1]+1
                    
        return max(dp)        
```

### ✅(15m) [1603. 设计停车系统](https://leetcode-cn.com/problems/design-parking-system/)

## 堆栈stack

### ✅(20m) 20. 有效的括号
**注意: range(x)取不到x**

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。


``` 
示例 1:
输入: "()"
输出: true
示例 2:

输入: "()[]{}"
输出: true
示例 3:

输入: "(]"
输出: false
示例 4:

输入: "([)]"
输出: false
示例 5:

输入: "{[]}"
输出: true

```


```python
# s = "()[]{}"
# s = "{[]}"
# s = "()"
s = ")]"
# s = "([)]"
s[-1]
len(s)/2
```


```python
# answer
# 主要思想:堆栈stack
class Solution(object):
    def isValid(self, s):
        """
        :type s: str
        :rtype: bool
        """

        # The stack to keep track of opening brackets.
        stack = []

        # Hash map for keeping track of mappings. This keeps the code very clean.
        # Also makes adding more types of parenthesis easier
        mapping = {")": "(", "}": "{", "]": "["}

        # For every bracket in the expression.
        for char in s:

            # If the character is an closing bracket
            if char in mapping:

                # Pop the topmost element from the stack, if it is non empty
                # Otherwise assign a dummy value of '#' to the top_element variable
                top_element = stack.pop() if stack else '#'

                # The mapping for the opening bracket in our hash and the top
                # element of the stack don't match, return False
                if mapping[char] != top_element:
                    return False
            else:
                # We have an opening bracket, simply push it onto the stack.
                stack.append(char)

        # In the end, if the stack is empty, then we have a valid expression.
        # The stack won't be empty for cases like ((()
        return not stack
```


```python
solution = Solution() # 实例化!!!!!
solution.isValid(s)
```


```python
# try2:
class Solution:
    def isValid(self, s: str) -> bool:
        dec = {  '(': ')',
               '{': '}', 
               '[': ']' }
        s = list(s)
        print(s)
        if len(s) == 0:return True
        if (len(s) % 2) == 1:return False # 奇数个时  

#     def cellpop()
    
        while s:
            for i in range(int(len(s)/2)):  # 注意range(x)取不到x 
                print(i)
                if s[i] in dec:
                    if dec[s[i]] == s[i+1]:
                        s.pop(i+1)
                        s.pop(i)
                        print(('s=',s))
                        break
                    else:pass
            else:
                print('wrong')
                return False
        return True
```


```python
# try1:
class Solution:
    def isValid(self, s: str) -> bool:
        if len(s) == 0:return True
        if (len(s) % 2) == 1:return False # 奇数个时      
        left = s[0]
        right_exp = dec[s[0]]
        right_ind = s.index(right_exp)
        if (s.index % 2) == 0:return False 
        else:
            s_cell = s[1:(s.index-1)]
            symbolcell(s_cell)
        print(left,right_exp,right_ind)
    
    def symbolcell(self, s_cell):
        for i in range(len(s_cell)-1):
```


```python
nums1 = [1, 2] 
nums2 = [3, 4]

```

#### 2️⃣

### 🚩(0.5h)32. 最长有效括号

给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

```
示例 1:

输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"
示例 2:

输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"
```

#### 栈的例子

栈底： stack=【-1】


```python
# 栈

class Solution:
    def longestValidParentheses(self, s: str) -> int:
        stack = [-1]
        length = 0
        max_length = 0
        for i in range(len(s)):
            if s[i] == '(':
                stack.append(i)  # 对于遇到的每个‘(’ ，我们将它的下标放入栈中
            else:   # 如果是’)‘
                stack.pop()  # 弹出栈顶，表示匹配了当前’)‘
                if stack == []:
                    stack.append(i) # 括号结束，记录结束位置(更新「最后一个没有被匹配的右括号的下标」)
                else:  # 如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」
                    length = i-stack[-1]
                    max_length = max(max_length,length)
            print(i, stack, '  \tmax_length=',max_length)
        return max_length
```


```python
from typing import List

nums = ")()())"
solution = Solution()
result = solution.longestValidParentheses(nums)
result

```

### 

## 链表

### 遍历框架
链表遍历框架,兼具迭代和递归结构: 
```C++
/* 基本的单链表节点 */ 
class ListNode {     
    int val;     
    ListNode next; 
} 
void traverse(ListNode head) {     
    for (ListNode p = head; p != null; p = p.next) {         
        // 迭代访问 p.val     
    } 
} 
void traverse(ListNode head) {     
    // 递归访问 head.val     
    traverse(head.next)
}
```
Python：

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
def traverse(head)：
		p = head
    while p:      
      	# 迭代访问 p.val     
      	p = p.next
def traverse(head)：
    # 递归访问 head.val     
    traverse(head.next)
```

### 总结

#### 概念

1. 链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。链表有很多种不同的类型：单向链表，双向链表以及循环链表。
链表通常可以衍生出循环链表，静态链表，双链表等。对于链表使用，需要注意头结点的使用。

2. 
链表中的“哨兵”节点是解决边界问题的，不参与业务逻辑。如果我们引入“哨兵”节点，则不管链表是否为空，head指针都会指向这个“哨兵”节点。我们把这种有“哨兵”节点的链表称为带头链表，相反，没有“哨兵”节点的链表就称为不带头链表。

#### 基于python的自建链表类（list to linklist)


```python
# 自建库
# Definition for singly-linked list.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
    def initList(self, data):
        # 判断是否为空
        if len(data) == 0:
            return
        else:
            # 创建头结点
            self.head = ListNode(data[0])
            # 头结点
            r = self.head  
            # 指针 
            p = self.head   
            # 逐个为 data 内的数据创建结点, 建立链表
            for i in data[1:]:
                node = ListNode(i)
                p.next = node
                p = p.next
            return r
        
    def linklist2List(self, linklist):
        List = []

        while linklist:
            List.append(linklist.val)
            linklist = linklist.next
        return List
```


```python
# 使用
l1 = [1,2,4]
l2 = [1,3,4]

List2Linklist = ListNode()
l1 = List2Linklist.initList(l1)
l2 = List2Linklist.initList(l2)

print(l1.val, "->", l1.next.val, "->", l1.next.next.val)
print(l2.val, "->", l2.next.val, "->", l2.next.next.val)
print(List2Linklist.linklist2List(l1))
# List2Linklist.printLinklist(result)
```

#### 哨兵节点使用

把`prev`期初所在的位置命名为`prehead`，这样`prev`再怎么变都可以找到其起始地址。

```python
prehead = ListNode(-1)  # 哨兵节点，让我们容易的返回合并后的链表
prev = prehead  # prev指针，我们调整它的next指针，直到l1或者l2某一个指向了NULL

···

return prehead.next # 返回入口地址

```

<img src="/img/in-post/20_07/image-20210108091928739.png" alt="image-20210108091928739" style="zoom:50%;" />

#### Python的ListNode类

```python
# Definition for singly-linked list.
class ListNode:
  def __init__(self, val=0, next=None):
    self.val = val
    self.next = next
```



### 🚩21. 合并两个有序链表 

将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
```
示例：

输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4

```

<img src="/img/in-post/20_07/image-20210107215233267.png" alt="image-20210107215233267" style="zoom:50%;" />









#### 2️⃣  (1.5h)


```python
# 标准
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        # maintain an unchanging reference to node ahead of the return node.
        prehead = ListNode(-1)  # 哨兵节点，让我们容易的返回合并后的链表

        prev = prehead  # prev指针，我们调整它的next指针，直到l1或者l2某一个指向了NULL
        while l1 and l2:
            if l1.val <= l2.val:
                prev.next = l1
                l1 = l1.next  # 注意l1的指针也要移动
            else:
                prev.next = l2
                l2 = l2.next
            prev = prev.next  # 指向下一个值
        prev.next = l1 if l1 is not None else l2
        
        return prehead.next # 返回入口地址
```


```python
l1 = [1,2,4]
l2 = [1,3,4]

List2Linklist = ListNode()
l1 = List2Linklist.initList(l1)
l2 = List2Linklist.initList(l2)

solution = Solution()
result = solution.mergeTwoLists(l1,l2)

print(l1.val, "->", l1.next.val, "->", l1.next.next.val)
print(l2.val, "->", l2.next.val, "->", l2.next.next.val)
print(List2Linklist.linklist2List(result))
# List2Linklist.printLinklist(result)
```

###  ✅(10m)206. 反转链表

反转一个单链表。
```
示例:

输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```
进阶:
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？

```python
class Solution(object):
	def reverseList(self, head):
		"""
		:type head: ListNode
		:rtype: ListNode
		"""
		# 申请两个节点，pre和 cur，pre指向None
		pre = None
		cur = head
		# 遍历链表，while循环里面的内容其实可以写成一行
		# 这里只做演示，就不搞那么骚气的写法了
		while cur:
			# 记录当前节点的下一个节点
			tmp = cur.next
			# 然后将当前节点指向pre
			cur.next = pre
			# pre和cur节点都前进一位
			pre = cur
			cur = tmp
		return pre	

```

#### 2️⃣ (1.5h) 

#### 注意要返回Newhead = pre

#### 3️⃣递归解法(🚩)

```python
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        # digui
        if not head or not head.next: # 只有当前节点
            return head
        last = self.reverseList(head.next) # 拆解为子问题
        head.next.next = head
        head.next = None
        return last
```

#### 3️⃣迭代解法

```python
        # 迭代
        if not head: # 只有当前节点
            return head  
        pre, cur = None, head
        while cur:
            tmp = cur.next  
            cur.next = pre
            pre, cur = cur, tmp
        return pre
```



### ✅ (15m) 删除链表中给定的节点

请编写一个函数，使其可以删除某个链表中给定的(非末尾)节点，你将只被给定要求被删除的节点。

现有一个链表 -- head = [4,5,1,9]，它可以表示为:
![image.png](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/01/19/237_example.png)




```
示例 1:

输入: head = [4,5,1,9], node = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
示例 2:

输入: head = [4,5,1,9], node = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.

```


```python
class Solution:
    def deleteNode(self, node):
        """
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        """
        node.val = node.next.val
        node.next = node.next.next
```

### ✅(50m) 203. 移除链表元素
删除链表中等于给定值 val 的所有节点。

```
示例:

输入: 1->2->6->3->4->5->6, val = 6
输出: 1->2->3->4->5
```

哨兵节点广泛应用于树和链表中，如伪头、伪尾、标记等，它们是纯功能的，通常不保存任何数据，其主要目的是使链表标准化，如使链表永不为空、永不无头、简化插入和删除。

![image.png](https://pic.leetcode-cn.com/c650a78cb34caf9a00469651abfc14181c474e2c6152e87273092e7dfd331f19-file_1578026286317)

在这里哨兵节点将被用于伪头。


```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def removeElements(self, head: ListNode, val: int) -> ListNode:        
        if not head: return None
        while head and head.val == val:
            if head.next: head = head.next
            else: 
                head.next = None
                return None


        prehead = head

        while head.next:
            if head.next.val == val and head.next.next:
                head.next = head.next.next
            elif  head.next.val == val and not head.next.next:
                head.next = None
            else:
                head = head.next
        return prehead
        
```


```python
# 官方

class Solution:
    def removeElements(self, head: ListNode, val: int) -> ListNode:
        sentinel = ListNode(0) # 哨兵节点
        sentinel.next = head
        
        prev,curr = sentinel,head
        while curr:
            if curr.val == val:  #  双指针，如果curr删除，prev同时移动
                prev.next == curr.next
            else:
                prev = curr
            curr = curr.next
            
        return sentinel.next
```

### ✅(90m)234. 回文链表
请判断一个链表是否为回文链表。

```
示例 1:

输入: 1->2
输出: false
示例 2:

输入: 1->2->2->1
输出: true
进阶：
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？
```


```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        
            
```


```python
# 官解，数组
def isPalindrome(self, head: ListNode) -> bool:
    vals = []
    current_node = head
    while current_node is not None:
        vals.append(current_node.val)
        current_node = current_node.next
    return vals == vals[::-1]


```


```python
# 官解，反转后半部分链表
# 方法三：
# 避免使用 O(n)O(n) 额外空间的方法就是改变输入。

# 我们可以将链表的后半部分反转(修改链表结构)，然后将前半部分和后半部分进行比较。比较完成后我们应该将链表恢复原样。虽然不需要恢复也能通过测试用例，因为使用该函数的人不希望链表结构被更改。

# 算法：

# 我们可以分为以下几个步骤：

# 找到前半部分链表的尾节点。
# 反转后半部分链表。
# 判断是否为回文。
# 恢复链表。
# 返回结果。
```

#### 2️⃣

On,On版本

```python
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        prehead = head
        ln = []
        while head:
            ln.append(head.val)
            head = head.next

        if len(ln) <= 1: return True
        if ln[:len(ln)//2] == ln[-(len(ln)//2):][::-1]: # 注意！负号优先级大于//
            return True
        else:
            return False
```

#### 3️⃣

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        if not head or not head.next: 
            return True

        # 1. Find middle node by fast and slow pointer
        slow = fast = head
        while fast and fast.next:
            p = slow
            q = fast.next
            slow = slow.next
            fast = fast.next.next
        # print(slow)

        # 2. odd case
        if fast:
            p = slow
            slow = slow.next
            q = fast
        
        # 3. reverse()
        def reverse(head):
            pre,cur = None,head
            while cur:
                tmp = cur.next
                cur.next = pre
                pre,cur = cur,tmp
            return pre

        # 4 & 5. compare ListNode and restore ListNode
        left = head
        right = reverse(slow) # middle node
        # print(p,q)
        while right != None:
            # print(left.val , right.val)
            if left.val != right.val:
                p.next = reverse(q)
                return False
            left = left.next
            right = right.next
        p.next = reverse(q)
        # print(head)
        return Trueclass Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        if not head or not head.next: 
            return True

        # 1. Find middle node by fast and slow pointer
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        # print(slow)

        # 2. odd case
        if fast:
            slow = slow.next
        
        # 3. reverse()
        def reverse(head):
            pre,cur = None,head
            while cur:
                tmp = cur.next
                cur.next = pre
                pre,cur = cur,tmp
            return pre

        # 4. compare ListNode
        left = head
        right = reverse(slow) # middle node

        while right != None:
            # print(left.val , right.val)
            if left.val != right.val:
                return False
            left = left.next
            right = right.next
        return True
```



注意：

1.运算符优先级，注意符号优先级很高，大于除号！！

<img src="/img/in-post/20_07/image-20210131214828448.png" alt="image-20210131214828448" style="zoom:50%;" />

2. 注意用快慢指针来找中点

3. 注意如果是奇数的话判断fast非None则要再加1位
4. 记录下p，q和  ` p.next = reverse(q)` 可恢复原链表





### ✅(50m) 2. 两数相加

给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

```
示例：

输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807
```


```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:

        prehead = ListNode(-1)
        newlinklist = prehead

        carry = 0
        while l1 and l2:
            newlinklist.next = ListNode((l1.val+l2.val + carry)%10)  # 新建linklist的方法，注意不能linklist.val == 
            newlinklist = newlinklist.next
            carry = (l1.val+l2.val + carry)//10
            l1, l2 = l1.next, l2.next
        while l1 and l2 is None:
            newlinklist.next = ListNode((l1.val + carry)%10)
            newlinklist = newlinklist.next
            carry = (l1.val + carry)
            l1 = l1.next
        while l2 and l1 is None:
            newlinklist.next = ListNode((l2.val + carry)%10)
            newlinklist = newlinklist.next
            carry = (l2.val + carry)
            l2 = l2.next
        if carry == 1: newlinklist.next = ListNode(carry) 
        return prehead.next
                

```




```python

```


```python

```


```python

```


```python

```

### ✅ 206. 反转链表

反转一个单链表。

```
示例:

输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

进阶:
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？



```python
class Solution(object):
	def reverseList(self, head):
		"""
		:type head: ListNode
		:rtype: ListNode
		"""
		# 申请两个节点，pre和 cur，pre指向None
		pre = None
		cur = head
		# 遍历链表，while循环里面的内容其实可以写成一行
		# 这里只做演示，就不搞那么骚气的写法了
		while cur:
			# 记录当前节点的下一个节点
			tmp = cur.next
			# 然后将当前节点指向pre
			cur.next = pre
			# pre和cur节点都前进一位
			pre = cur
			cur = tmp
		return pre	

```

#### 2️⃣ (30m)


```python
class Solution(object):
    def reverseList(self, head):
        cur = head  # 注意是从head开始
        pre = None
        while cur:
            nexttmp = cur.next
            cur.next = pre
            
            pre = cur 
            cur = nexttmp
        return pre  # 返回的是起始点
```

### 🚩25. K 个一组翻转链表

给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。

k 是一个正整数，它的值小于或等于链表的长度。

如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。


```
示例：

给你这个链表：1->2->3->4->5

当 k = 2 时，应当返回: 2->1->4->3->5

当 k = 3 时，应当返回: 3->2->1->4->5
```

说明：

你的算法只能使用常数的额外空间。
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。


```python
class Solution:
    def reverseList(self, head):

        while cur:
            nexttmp = cur.next
            cur.next = pre
            
            pre = cur 
            cur = nexttmp
        return pre  # 返回的是起始点    
    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:
        cur = head  # 注意是从head开始
        pre = None
        reverseList()
```

#### 2️⃣



### 🚩23. 合并K个排序链表

合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。

示例:

```
输入:
[
  1->4->5,
  1->3->4,
  2->6
]
输出: 1->1->2->3->4->4->5->6
```

#### 2️⃣

### ✅(20m)[141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

难度简单916

给定一个链表，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

如果链表中存在环，则返回 `true` 。 否则，返回 `false` 。

 

**进阶：**

你能用 *O(1)*（即，常量）内存解决此问题吗？

 

**示例 1：**

![img](/img/in-post/20_07/circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

```python
法1：放到set里
class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        # if not head: return False
        # set_node = set()
        # while head:
        #     if head in set_node:
        #         return True
        #     set_node.add(head)
        #     head = head.next
        # return False
```



```python
法二：快慢指针
class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        if not head: return False
        slow = fast = head

        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if fast == slow:
                return True
        return False
```

注意：

1. 注意链表是可以放到set里的，判断链表相等要满足value和next都相等
2.  set是用add和remove的，O(1)时间复杂度

### 🚩(20m) [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

```python
class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        if not head: return None
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if fast == slow:
                fast = head
                while fast:
                    if fast == slow:  # 注意考虑特殊情况第一个环点为0时要先判断两个指针是否相同
                        return fast
                    slow = slow.next
                    fast = fast.next

```



### ✅(10m)[86. 分隔链表](https://leetcode-cn.com/problems/partition-list/)

难度中等357

给你一个链表和一个特定值 `x` ，请你对链表进行分隔，使得所有小于 `x` 的节点都出现在大于或等于 `x` 的节点之前。

你应当保留两个分区中每个节点的初始相对位置。

 

**示例：**

```
输入：head = 1->4->3->2->5->2, x = 3
输出：1->2->2->4->3->5
```

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def partition(self, head: ListNode, x: int) -> ListNode:
        node1 = ListNode(-1)
        node2 = ListNode(-1)
        prenode1 = node1
        prenode2 = node2
        while head:
            if head.val < x:
                node1.next = head
                node1 = node1.next
            else:
                node2.next = head
                node2 = node2.next
            head = head.next
        node1.next, node2.next = prenode2.next, None
        
        return prenode1.next


```

总结

1. 遍历结束后，我们将large 的 next 指针置空，这是因为当前节点复用的是原链表的节点，而其 next 指针可能指向一个小于 x 的节点，我们需要切断这个引用。

### [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

难度简单957

编写一个程序，找到两个单链表相交的起始节点。

如下面的两个链表**：**

[![img](/img/in-post/20_07/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

在节点 c1 开始相交。

 

**示例 1：**

[![img](/img/in-post/20_07/160_example_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```

OnOn版本

```python
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        set_n = set()
        while headA:
            set_n.add(headA)
            headA = headA.next
        while headB:
            if headB in set_n:
                return headB
            headB = headB.next
        return None
```

我的OnO1

```python
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        preheadA = headA
        preheadB = headB
        
        STATE_A = STATE_B = True
        while headA and headB:
            print(headA.val,headB.val,'  ')
            if headA == headB:
                return headA

            headA = headA.next
            headB = headB.next
        
            if headA == None and STATE_A:  # 要先判断下
                headA = preheadB
                STATE_A = False
            if headB == None and STATE_B:
                headB = preheadA 
                STATE_B = False
                
        return None
```

大佬OnO1版本

```python
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:

        curr1, curr2 = headA, headB
        while curr1 != curr2:
            curr1 = curr1.next if curr1 else headB
            curr2 = curr2.next if curr2 else headA

        return curr1
```



### 🚩(60m)[92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

难度中等674

反转从位置 *m* 到 *n* 的链表。请使用一趟扫描完成反转。

**说明:**
1 ≤ *m* ≤ *n* ≤ 链表长度。

**示例:**

```
输入: 1->2->3->4->5->NULL, m = 2, n = 4
输出: 1->4->3->2->5->NULL
```





```python
    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:
        # 官解
        if not head: # 只有当前节点
            return None  
        # dummy = head
        # pos = 1
        
        # i = dummy
        cur, prev = head, None
        # while pos < m:
    
        while m > 1:   # 一直循环到m==1的情况
            prev = cur
            cur = cur.next
            m, n = m-1, n-1   # 注意，这样就不需要记录当前位置
        #     pos += 1
        # j = dummy

        tail, con = cur, prev  

        while n:
            thrid = cur.next  
            cur.next = prev
            prev, cur = cur, thrid
            n -= 1
            # pos += 1
        
        if con:  # 如果i从1开始，则con==None，无next，则直接令head = prev
            con.next = prev
        else:
            head = prev
        tail.next = cur

        return head
```

#### 3️⃣ (40m) 注意停止条件是        while head:

注意：

1. m, n = m-1, n-1   # 注意，这样就不需要记录当前位置
2. 最后要分情况，是否直接从第一个节点就开始反转

## 二叉树

### 二叉树遍历框架

二叉树算法的设计的总路线:**明确一个节点要做的事情,然后剩下的事抛给框架。**

```C++
/* 基本的二叉树节点 */ 
class TreeNode {     
  int val;     
  TreeNode left, right; 
} 

void traverse(TreeNode root) {     
    // 前序遍历    
    traverse(root.left)     
    // 中序遍历    
    traverse(root.right)     
    // 后序遍历
}
```

Python:

```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
        
def traverse(root) :
    if not root return None
	  # node需要做什么在这里做, 其他的交给框架
    # ... your task
    # 前序遍历
    traverse(root.left)
    # 中序遍历
    traverse(root.right)
    # 后序遍历
```

1. 如果dfs

   1. ```python
      def binaryTreePaths(self, root: TreeNode) -> List[str]:
        if not root: return []
        ans = []
        path = ''
      
        def dfs(root, path):
          if root: 
            # do sth
            path+=str(root.val)
            # 满足条件
            if not(root.left or root.right): 
              ans.append(path)
            # 不满足继续循环
            else:
              path += '->'
              dfs(root.left, path)
              dfs(root.right, path)
      
          dfs(root,path)
          return ans
              
      ```

      

2. 

### BST遍历框架

**二叉搜索树(Binary Search Tree,简称 BST)**, 是一种很常用的的二叉树。它的定义是:**一个二叉树中,任意节点的值要大于等于左子树所有节点的值, 且要小于等于右边子树的所有节点的值。**

<img src="/img/in-post/20_07/image-20210116112419058.png" alt="image-20210116112419058" style="zoom: 33%;" />



1. 查
2. 改 — 返回TreeNode类型（如root）。

```c++
void BST(TreeNode root, int target) {     
  if (root.val == target)         
    // 找到目标,做点什么    
  if (root.val < target)         
    BST(root.right, target);     
  if (root.val > target)         
    BST(root.left, target); 
}
```



### 总结

#### N 叉树的遍历框架

二叉树框架可以扩展为 N 叉树的遍历框架:

```C++
/* 基本的 N 叉树节点 */ 
class TreeNode {     
  int val;     
  TreeNode[] children; 
} 

void traverse(TreeNode root) {     
  for (TreeNode child : root.children)         
    traverse(child) 
}
```

Python（🚩待研究）:

N 叉树的遍历又可以扩展为图的遍历,因为图就是好几 N 叉棵树的结合体。你说图是可能出现环的?这个很好办,用个布尔数组 visited 做标记就行了。

#### 做题思路

我们在做二叉树题目时候，第一想到的应该是用**递归**来解决。

递归返回值：

        return root  #  注意返回的是root，此时root为空

一定注意 root 是树， root.val 是值

        valuePerDepth[index].append(root.val)   # 一定注意 root 是树， root.val 是值

注意用数组形式可以把root树加入队列        

        queue = [root]  # 注意用数组形式可以把root树加入队列

**注意递归时, return 里的false 和true的关系, 看是and 还是or**

#### 递归法带helper函数求解标准步骤


```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        def helper(left,right):   # 注意没有self
            # 基准情况，二叉树为空
            if left > right:  # 左右位置做标
                return None
            
            # 选中间偏左的结点为root
            mid = (left+right)//2
            
            root = TreeNode(nums[mid])  # root = TreeNode(0) # 用0作为根节点
            root.left = helper(left, mid - 1)
            root.right = helper(mid + 1, right)
            
            return root 
        
        return helper(0, len(nums) - 1)
    
```


```python
from typing import List

nums = [1,2,0,2,2]
solution = Solution()
result = solution.sortedArrayToBST(nums)
result
```

#### 递归法不带helper函数标准步骤


```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
# 递归
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:  # root is empty then return, 即使子树为空也没关系应该
            return None

        root.left, root.right = root.right, root.left
        
        self.invertTree(root.left)
        self.invertTree(root.right)

        return root  #  注意返回的是root，此时root为空


            
```

#### 迭代法标准步骤


```python
# 迭代
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return None
        queue = [root]  # 注意用数组形式可以把root树加入队列
        while queue:
            tmp = queue.pop(0)
            tmp.left, tmp.right = tmp.right, tmp.left
            
            if tmp.left:
                queue.append(tmp.left)
            if tmp.right:
                queue.append(tmp.right)
        
        return root 
```

#### 深度优先搜索

1. 大多使用**递归**函数
2. **递归函数三要素**:
   1. 子问题原问题做相同的事情
   2. 需要递归结束的出口
   3. 递归表达

#### 当return输出和helper子任务不同时


```python
# 递归过程：
# 求depth（1)要求depth（2)，depth（3)
# 求depth（2)要 ‘’‘
# ’‘’
# 递归表达式：
# depth(rt) = max(depth(rt->left), depth(rt->right))+1
class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:        
        self.ans = 1
        def depth(root):
            if not root: return 0
            self.ans = self.ans, depthdepth(root.left) + depth(root.right)+1
            return max(depth(root.left), depth(root.right))+1
        
        depth(root)
        return self.ans - 1
```

#### 二叉树遍历方式

二叉树遍历方法二叉树的遍历方式可以很多,如果我们限制了从左到右的习惯方式,那么主要就分为四种: 

1.前序遍历规则是若二叉树为空,则空操作返回,否则**先访问根结点,然后前序遍历左子树,再前序遍历右子树。**如图6-8-2所示,遍历的顺序为: ABDGH-CEIF。

<img src="/img/in-post/20_07/image-20210116165251179.png" alt="image-20210116165251179" style="zoom:33%;" />

2.中序遍历规则是若树为空,则空操作返回,否则**从根结点开始(注意并不是先访问根结点),中序遍历根结点的左子树,然后是访问根结点,最后中序遍历右子树**。如图6-8-3所示,遍历的顺序为:GDHBAE-ICF。

<img src="/img/in-post/20_07/image-20210116165308451.png" alt="image-20210116165308451" style="zoom:33%;" />

3.后序遍历规则是若树为空,则空操作返回,否则**从左到右先叶子后结点的方式遍历访问左右子树,最后是访问根结点**。如图6-8-4所示,遍历的顺序为:GHDBIEFCA。

<img src="/img/in-post/20_07/image-20210116170012938.png" alt="image-20210116170012938" style="zoom:33%;" />

4.层序遍历规则是若树为空,则空操作返回,否则从树的第一层,也就是根结点开始访问,从上而下逐层遍历,在同一层中,按从左到右的顺序对结点逐307 个访问。如图6-8-5所示,遍历的顺序为:ABCDEFGHI。

<img src="/img/in-post/20_07/image-20210116170000354.png" alt="image-20210116170000354" style="zoom:33%;" />

### ✅101. 对称二叉树(二叉树不明白)  

给定一个二叉树，检查它是否是镜像对称的。

```
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

    1
   / \
  2   2
 / \ / \
3  4 4  3
但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

    1
   / \
  2   2
   \   \
   3    3
说明:

如果你可以运用递归和迭代两种方法解决这个问题，会很加分。
```


```python
# 自己写的 判断数组 二叉树不行
class Solution:
    def isSymmetric(self, root) -> bool:
        import math
        length = len(root)
        line_sum = math.log(length+1, 2)
#         print(line_sum)
        if line_sum % 1 != 0:return False
        

        for i in range(int(line_sum)):
            for j in range(int(math.pow(2,(i-1)))): 
                if root[int(math.pow(2,i)-1+j)] != root[int(math.pow(2,(i+1))-2-j)]:
                    return False
        return True
```


```python
global null
null = '#'
root = [1,2,2,null,3,null,3]
root = [1,2,2,3,4,4,3]
solution = Solution()
result = solution.isSymmetric(root)
print(result)
```


```python
# 递归方法
class Solution(object):
	def isSymmetric(self, root):
		"""
		:type root: TreeNode
		:rtype: bool
		"""
		if not root:
			return True
		def dfs(left,right):
			# 递归的终止条件是两个节点都为空
			# 或者两个节点中有一个为空
			# 或者两个节点的值不相等
			if not (left or right):
				return True
			if not (left and right):
				return False
			if left.val!= right.val:
				return False
			return dfs(left.left,right.right) and dfs(left.right,right.left)
		# 用递归函数，比较左节点，右节点
		return dfs(root.left,root.right)
```


```python
root = [1,2,2,null,3,null,3]
solution = Solution()
result = solution.isSymmetric(root)
print(result)
```

#### 2️⃣(40m)  


```python
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if not root: return True
        def helper(root1, root2):
            if not (root1 or root2): return True
            elif not (root1 and root2):  return False

            if root1.val != root2.val: return False
            return helper(root1.left, root2.right) and helper(root1.right, root2.left)

        return helper(root, root)
```

### ✅104. 二叉树的最大深度  

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

```
示例：
给定二叉树 [3,9,20,null,null,15,7]，

    3
   / \
  9  20
    /  \
   15   7
返回它的最大深度 3 。

````


```python
# 树节点TreeNode定义
class TreeNode(object):
    """ Definition of a binary tree node."""
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
```


```python
# 递归-DFS深度搜索策略
class Solution:
    def maxDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """ 
        if root is None: 
            return 0 
        else: 
            left_height = self.maxDepth(root.left) 
            right_height = self.maxDepth(root.right) 
            return max(left_height, right_height) + 1
```


```python
# 迭代
class Solution:
    def maxDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """ 
        stack = []
        if root is not None:
            stack.append((1, root))
        
        
        depth = 0
        while stack != []:
            current_depth, root = stack.pop()
            if root is not None:
                depth = max(depth, current_depth)
                stack.append((current_depth + 1, root.left))
                stack.append((current_depth + 1, root.right))
        
        return depth
```

#### 2️⃣(50m)   


```python
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        def helper( root, depth):
            if not root:
                return 0
            
            self.maxdepth = max(self.maxdepth,depth + 1)
                    
            helper(root.left, depth + 1)
            helper(root.right, depth + 1)
            
            return self.maxdepth

        self.maxdepth = 0
        return helper(root, 0)
```

### 🚩(50m) 108. 将有序数组转换为二叉搜索树

将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

```
示例:

给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5
```

#### 2️⃣


```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        if not nums: return None
        
        # 因为是平衡二叉树, 故找中间节点
        mid = len(nums)//2
        node = TreeNode(nums[mid])  # 注意root是一个值!
        
        left = nums[:mid]
        right = nums[mid+1:]
    
    
        node.left = sortedArrayToBST(left)
        node.right = sortedArrayToBST(right)
        
        return node
    
        
```


    ---------------------------------------------------------------------------
    
    NameError                                 Traceback (most recent call last)
    
    <ipython-input-6-a9ae52dc2c7f> in <module>
    ----> 1 class Solution:
          2     def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
          3         if not nums: return None
          4 
          5         # 因为是平衡二叉树, 故找中间节点


    <ipython-input-6-a9ae52dc2c7f> in Solution()
          1 class Solution:
    ----> 2     def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
          3         if not nums: return None
          4 
          5         # 因为是平衡二叉树, 故找中间节点


    NameError: name 'List' is not defined

### ✅(50m) 226. 翻转二叉树

翻转一棵二叉树。

```
示例：

输入：

     4
   /   \
  2     7
 / \   / \
1   3 6   9
输出：

     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

<img src="https://pic.leetcode-cn.com/0f91f7cbf5740de86e881eb7427c6c3993f4eca3624ca275d71e21c5e3e2c550-226_2.gif" alt="image.png" style="zoom:50%;" />

**递归法不带helper函数标准步骤**


```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
# 递归
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:  # root is empty then return, 即使子树为空也没关系应该
            return None

        root.left, root.right = root.right, root.left
        
        self.invertTree(root.left)
        self.invertTree(root.right)

        return root  #  注意返回的是root，此时root为空


            
```

**迭代法标准步骤**


```python
# 迭代
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return None
        queue = [root]  # 注意用数组形式可以把root树加入队列
        while queue:
            tmp = queue.pop(0)
            tmp.left, tmp.right = tmp.right, tmp.left
            
            if tmp.left:
                queue.append(tmp.left)
            if tmp.right:
                queue.append(tmp.right)
        
        return root 
```

### 🚩(40m) 543. 二叉树的直径

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

 

```
示例 :
给定二叉树

          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
```

**深度优先搜索**

1. 大多使用递归函数
2. 递归函数三要素
   1. 子问题原问题做相同的事情
   2. 需要递归结束的出口
   3. 递归表达式

**当return输出和helper子任务不同时**


```python
# 递归过程：
# 求depth（1)要求depth（2)，depth（3)
# 求depth（2)要 ‘’‘
# ’‘’
# 递归表达式：
# depth(rt) = max(depth(rt->left), depth(rt->right))+1
class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:        
        self.ans = 1
        def depth(root):
            if not root: return 0
            self.ans = self.ans, depthdepth(root.left) + depth(root.right)+1
            return max(depth(root.left), depth(root.right))+1
        
        depth(root)
        return self.ans - 1
```

#### 2️⃣ 


```python
class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:        
        self.ans = 1
        def depth():  # 返回该节点为根的子树的深度( max(L,R)+1 )
            if not root: return 0
            L = depth(node.left)
            R = depth(node.right)
            self.ans = max(self.ans, L+R+1)
            return max(L,R) + 1
        depth(root)
        return self.ans - 1

```


```python

```

### ✅ 102. 二叉树的层序遍历

给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 (即逐层地，从左到右访问所有节点)。

 

```
示例：
二叉树：[3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回其层次遍历结果：

[
  [3],
  [9,20],
  [15,7]
]
```

#### 2️⃣(50m) 


```python
# 递归
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        valuePerDepth = []
        def helper(root, index):
            if not root: return 0
                       
            if len(valuePerDepth) < index+1:
                valuePerDepth.append([])

            valuePerDepth[index].append(root.val)   # 一定注意 root 是树， root.val 是值

            L = root.left
            R = root.right
            if L: helper(L, index+1)
            if R: helper(R, index+1) 
        
        helper(root, 0)
        return valuePerDepth    
            
            
            
```


```python
# 官解，迭代
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root: return []
        res = []
        queue = [root]  
        while queue:
            size = len(queue)
            tmp = []
            
            for _ in xrange(size):
                r = queue.pop(0)
                tmp.append(r.val)
                if r.left:
                    queue.append(r.left)
                if r.right:
                    queue.append(r.right)
            res.append(tmp)
        return res



```

### ✅ (7m) 107. 二叉树的层次遍历 II

给定一个二叉树，返回其节点值自底向上的层次遍历。 (即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历)

```
例如：
给定二叉树 [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回其自底向上的层次遍历为：

[
  [15,7],
  [9,20],
  [3]
]
```


```python
class Solution:
    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:
        valuePerDepth = []
        def helper(root, index):
            if not root: return 0
                       
            if len(valuePerDepth) < index+1:
                valuePerDepth.append([])

            valuePerDepth[index].append(root.val)   # 一定注意 root 是树， root.val 是值

            L = root.left
            R = root.right
            if L: helper(L, index+1)
            if R: helper(R, index+1) 
        
        helper(root, 0)
        valuePerDepth = valuePerDepth[::-1]  # 反转数组操作
        return valuePerDepth
            
```

###  ✅617. 合并二叉树

给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。

``` python
示例 1:

输入: 
	Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
输出: 
合并后的树:
	     3
	    / \
	   4   5
	  / \   \ 
	 5   4   7
注意: 合并必须从两个树的根节点开始。
```


```python
class Solution:
    def mergeTrees(self, node1: TreeNode, node2: TreeNode) -> TreeNode:
        if not node1: return node2
        elif not node2: return node1

        node1.val = node1.val + node2.val
        node1.left = self.mergeTrees(node1.left, node2.left)
        node1.right = self.mergeTrees(node1.right, node2.right)
        return node1
        
```

#### 2️⃣

#### 3️⃣(30m)

```python
class Solution:
    def mergeTrees(self, node1: TreeNode, node2: TreeNode) -> TreeNode:
        if not node1: return node2
        elif not node2: return node1

        node = TreeNode(node1.val + node2.val)
        node.left = self.mergeTrees(node1.left, node2.left)
        node.right = self.mergeTrees(node1.right, node2.right)
        return node
        
```



###  🚩687. 最长同值路径

给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。

注意：两个节点之间的路径长度由它们之间的边数表示。

``` python
示例 1:

输入:

              5
             / \
            4   5
           / \   \
          1   1   5
输出:

2
示例 2:

输入:

              1
             / \
            4   5
           / \   \
          4   4   5
输出:

2
注意: 给定的二叉树不超过10000个结点。 树的高度不超过1000。
```


```python
class Solution(object):
    def longestUnivaluePath(self, root):
        self.ans = 0

        def arrow_length(node):
            if not node: return 0
            left_length = arrow_length(node.left)
            right_length = arrow_length(node.right)
            left_arrow = right_arrow = 0
            if node.left and node.left.val == node.val:
                left_arrow = left_length + 1
            if node.right and node.right.val == node.val:
                right_arrow = right_length + 1
            self.ans = max(self.ans, left_arrow + right_arrow)
            return max(left_arrow, right_arrow)

        arrow_length(root)
        return self.ans

```

#### 2️⃣



### ✅ 112. 路径总和

给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

说明: 叶子节点是指没有子节点的节点。

``` python
示例: 
给定如下二叉树，以及目标和 sum = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。
```

#### 2️⃣ (20m)


```python
class Solution:
    def hasPathSum(self, root: TreeNode, sum: int) -> bool:
        if not root: return False

        if root.val == sum and not(root.left or root.right):
            return True

        return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val)
```

###  🚩257. 二叉树的所有路径

给定一个二叉树，返回所有从根节点到叶子节点的路径。

说明: 叶子节点是指没有子节点的节点。

``` python
示例:

输入:

   1
 /   \
2     3
 \
  5

输出: ["1->2->5", "1->3"]

解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3
```


```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def binaryTreePaths(self, root: TreeNode) -> List[str]:
        if not root: return []
        ans = []
        path = ''

        def dfs(root, path):
            if root: 
                path+=str(root.val)
                if not(root.left or root.right): 
                    ans.append(path)
                else:
                    path += '->'
                    dfs(root.left, path)
                    dfs(root.right, path)

        dfs(root,path)
        return ans
        
```

#### 2️⃣(30m)

注意： 

1. dfs 找路径时，除了传入当前节点（`node`），还要传入`path`.
2. 

###  🚩669. 修剪二叉搜索树

给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R>=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。

``` python
示例 1:

输入: 
    1
   / \
  0   2

  L = 1
  R = 2

输出: 
    1
      \
       2
示例 2:

输入: 
    3
   / \
  0   4
   \
    2
   /
  1

  L = 1
  R = 3

输出: 
      3
     / 
   2   
  /
 1
```

#### 2️⃣(40m)

令 `trim(node)` 作为该节点上的子树的理想答案,进行构建

###  ✅(40m) 538. 把二叉搜索树转换为累加树

给定一个二叉搜索树（Binary Search Tree)，把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。


```
例如：

输入: 原始二叉搜索树:
              5
            /   \
           2     13

输出: 转换为累加树:
             18
            /   \
          20     13
```

#### 2️⃣ # 一定注意，此题要用全局变量，而不能只是传参

```python

# 一定注意，此题要用全局变量，而不能只是传参
class Solution:
    def convertBST(self, root: TreeNode) -> TreeNode:
        def helper(node, ):
            global nums_sum
            if not node:
                return None
            helper(node.right,)
            # 中序            
            nums_sum += node.val
            node.val = nums_sum  # ?
            helper(node.left,)
        
        global nums_sum
        nums_sum = 0
        helper(root)
        return root

# class Solution:
#     def convertBST(self, root: TreeNode) -> TreeNode:
#         def helper(node, nums_sum):
#             if not node:
#                 return None
#             helper(node.right,nums_sum)
#             # 中序            
#             nums_sum += node.val
#             node.val = nums_sum  # ?
#             helper(node.left,nums_sum)
        
#         nums_sum = 0
#         helper(root, nums_sum)
#         return root
```



### ✅ (20m) 199. 二叉树的右视图

给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

示例:

```
输入: [1,2,3,null,5,null,4]
输出: [1, 3, 4]
解释:

   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---
```

#### 2️⃣

cur = stack.pop(0)  # 一定注意是pop(0)

```python
class Solution:
    def rightSideView(self, root: TreeNode) -> List[int]:
        if not root:
            return []
        stack = [root]
        ans = []
        while stack:
            for i in range(len(stack)):
                cur = stack.pop(0)  # 一定注意是pop(0)
                if cur.left: stack.append(cur.left)
                if cur.right: stack.append(cur.right)
            ans.append(cur.val)
        return ans
```

### 🚩（困难）124. 二叉树中的最大路径和

给定一个非空二叉树，返回其最大路径和。

本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。

```
示例 1:

输入: [1,2,3]

       1
      / \
     2   3

输出: 6
示例 2:

输入: [-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7
```

#### 2️⃣



### ✅ (10m) 102. 二叉树的层序遍历

给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 (即逐层地，从左到右访问所有节点)。

#### 2️⃣

```python
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        stack = [root]
        ans = []
        while stack:
            tmp = []
            for i in range(len(stack)):
                cur = stack.pop(0)
                tmp.append(cur.val)
                if cur.left: stack.append(cur.left)
                if cur.right: stack.append(cur.right)
            ans.append(tmp)
        return ans

```




### 🚩(1.0h) [95. 不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)

给定一个整数 *n*，生成所有由 1 ... *n* 为节点所组成的 **二叉搜索树** 。

### 🚩(33m)  [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

```python
class Solution:
    def flatten(self, root: TreeNode) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        if root == None:
            return 

        self.flatten(root.left)
        self.flatten(root.right)
    
        #/**** 后序遍历位置 ****/
        #// 1、左右子树已经被拉平成一条链表
        left = root.left
        right = root.right

        #// 2、将左子树作为右子树
        root.left = None
        root.right = left

        #// 3、将原先的右子树接到当前右子树的末端
        p = root 
        while(p.right):
            p = p.right
        p.right = right

```

### ✅(90m)[116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

步骤：

1. 使用queue构建层序遍历
2. 加循环使每层进行一次输出

```python
class Solution:
    def connect(self, root: 'Node') -> 'Node':
        # 层序遍历
        if not root: return None
        queue = [root]
        while queue:
            for i in range(len(queue)-1):
                queue[i].next = queue[i+1]

            for i in range(len(queue)):
                cur = queue.pop(0)
                if cur.left: queue.append(cur.left)
                if cur.right: queue.append(cur.right)
        
        return root
```

### 🚩[297. 序列化二叉树](https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/)

```python
class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """

        s = ""
        queue = []
        queue.append(root)
        
        while queue:
            root = queue.pop(0)
            if root:
                s += str(root.val)
                queue.append(root.left)
                queue.append(root.right)
            else:
                s += "n"
            s += " "        
        return s


    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        tree = data.split()
        print(tree)
        if tree[0] == "n":
            return None
        queue = []
        root = TreeNode(int(tree[0]))
        queue.append(root)

        i = 1
        while queue:
            cur = queue.pop(0)
            if cur == None:
                continue
            cur.left = TreeNode(int(tree[i])) if tree[i] != "n" else None
            cur.right = TreeNode(int(tree[i + 1])) if tree[i + 1] != "n" else None
            i += 2
            queue.append(cur.left)
            queue.append(cur.right)
        return root
```

#### 2️⃣



### ✅(30m)[103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

难度中等378

给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

例如：
给定二叉树 `[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

返回锯齿形层序遍历如下：

```
[
  [3],
  [20,9],
  [15,7]
]
```

```python
class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root: return []
        queue = [root]
        ans = []
        forward = True
        while queue:
            size = len(queue)
            temp = []
            for i in range(size):
                node = queue.pop(0)
                temp.append(node.val)  # 注意寸的是node的值
                if node.left: queue.append(node.left)
                if node.right: queue.append(node.right)
                # queue.pop(0)
            if forward == True:
                ans.append(temp)
                forward = False
            else:
                ans.append(temp[::-1])
                forward = True                
        return ans
```

总结：

1. 记得放temp

### ✅(20m)[144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

难度中等511

给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

**示例 1：**

![img](/img/in-post/20_07/inorder_1.jpg)

```
输入：root = [1,null,2,3]
输出：[1,2,3]
```



```python
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        def helper(node):
            if not node:
                return 
            ans.append(node.val)
            helper(node.left)
            helper(node.right)
        
        ans = []
        helper(root)
        return ans 
```

迭代法官解：🚩

```python
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        res = list()
        if not root:
            return res
        stack = []
        node = root
        while stack or node:
            while node:
                res.append(node.val)
                stack.append(node)
                node = node.left
            node = stack.pop()
            node = node.right
        return res
```



### ✅(10m)[145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

难度中等517

给定一个二叉树，返回它的 *后序* 遍历。

**示例:**

```
输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [3,2,1]
```

```python
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        def helper(node):
            if not node: 
                return 
            helper(node.left)
            helper(node.right)
            ans.append(node.val)
        ans = []
        helper(root)
        return ans 
```

## 排序算法

### 总结

[数据结构和排序可视化](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)

[lc官解](https://leetcode-cn.com/problems/sort-an-array/solution/pai-xu-shu-zu-by-leetcode-solution/)

[各种排序算法，吐血总结](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/ge-chong-pai-xu-suan-fa-tu-xie-zong-jie-by-ke-ai-x/)

<img src="/img/in-post/20_07/image-20210108095912068-0071723.png" alt="image-20210108095912068" style="zoom:67%;" />

![image-20210518104454321](/img/in-post/20_07/image-20210518104454321-1306343.png)

> <img src="/img/in-post/20_07/image-20210518104646541.png" alt="image-20210518104646541" style="zoom: 33%;" />
>
> 1. 简单排序里，插入排序最好（样本小且基本有序时，效率较高）

#### 冒泡排序 — 逐个比较，最大的后移

#### 选择排序 — 遍历选择最小的，放到最前

#### 插入排序（熟悉） — 发现小数字，向前交换

简单排序里，插入排序最好（**样本小且基本有序时，效率较高，效果好**）

```python
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        for ind in range(1,len(nums)):
            i = ind
            while i > 0 and nums[i] < nums[i-1]:
                nums[i], nums[i-1] = nums[i-1], nums[i]
                i -= 1
        return nums
```



#### 希尔排序 — 改进的插入排序，间隔由大到小排序

#### 🚩 归并排序（掌握）

最坏情况效果最好

```python
class Solution:
    def merge_sort(self, nums, l, r):
        if l == r:
            return
        mid = (l + r) // 2
        self.merge_sort(nums, l, mid)
        self.merge_sort(nums, mid + 1, r)
        tmp = []
        i, j = l, mid + 1
        while i <= mid or j <= r:
            if i > mid or (j <= r and nums[j] < nums[i]):
                tmp.append(nums[j])
                j += 1
            else:
                tmp.append(nums[i])
                i += 1
        nums[l: r + 1] = tmp

    def sortArray(self, nums: List[int]) -> List[int]:
        self.merge_sort(nums, 0, len(nums) - 1)
        return nums
```

#### 快速排序 （掌握）

```python
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        def partition(nums, left_bound, right_bound):
            pivot = nums[right_bound]
            l,r = left_bound, right_bound - 1
            while l <= r:
                while l <= r and nums[l] <= pivot:
                    l += 1
                while l <= r and nums[r] > pivot:
                    r -= 1
                if l < r:
                    nums[l], nums[r] = nums[r], nums[l]
            # 注意要把轴放在中间, 因为最后一次循环一定是走的l++，即当前l和r指向的是大值，互换l和锚点
            nums[l], nums[right_bound] = nums[right_bound], nums[l]
            return l  
        def quick_sort(nums, left_bound, right_bound):
            if left_bound>=right_bound: 
                return
            mid = partition(nums, left_bound, right_bound)
            quick_sort(nums, left_bound, mid - 1)
            quick_sort(nums, mid + 1, right_bound) # 注意是mid+1

        quick_sort(nums, 0, len(nums)-1)
        return nums
```

 快速排序是每个程序员都应当掌握的排序算法。当然我们接触的第一个排序算法可能是插入排序或者冒泡排序，但数据量一旦超过几万，插入和冒泡的性能会非常差。这时时间复杂度的渐进优势就表现出来了。 **平均情况下快速排序的时间复杂度是Θ(𝑛lg𝑛)，最坏情况是𝑛2，但通过随机算法可以避免最坏情况。由于递归调用，快排的空间复杂度是Θ(lg𝑛)**。时间复杂度$O(nlogn)$，空间复杂度$O(logn)$。

**步骤：**

1. 找基准
2. 分区
3. 递归

> 快速排序算法其实很简单，采用**分治策略**。步骤如下：
>
> 1. 选取一个基准元素（pivot)
> 2. 比pivot小的放到pivot左边，比pivot大的放到pivot右边
> 3. 对pivot左边的序列和右边的序列分别递归的执行步骤1和步骤2

> **基本思想:**通过一趟排序将待排记录分隔成独立的两部分,其中一部分记录的关键字均比另一部分的关键字小,则可分别对这两部分记录继续进行排序,以达到整个序列有序。
> **算法描述:** 快速排序使用分治法来把一个串(list)分为两个子串(sub-lists)。具体算法描述如下: 
>
> 1. 从数列中挑出一个元素,称为 **“基准”(pivot);** 
> 2. 重新排序数列,所有元素比基准值小的摆放在基准前面,所有元素比基准值大的摆在基准的后面(相同的数可以到任一边)。在这个分区退出之后,该基准就处于数列的中间位置。这个称为**分区(partition)**操作; 
> 3. **递归地(recursive)**把小于基准值元素的子数列和大于基准值元素的子数列排序。

##### **快速排序时间复杂度**：



平均情况下快速排序的时间复杂度是Θ(𝑛\lgn)，最坏情况是Θ(𝑛2)。

当划分产生的两个子问题分别包含 n-1 和 0 个元素时，**最坏情况**发生。划分操作的时间复杂度为Θ(𝑛)，𝑇(0)=Θ(1)，这时算法运行时间的递归式为 𝑇(𝑛)=𝑇(𝑛−1)+𝑇(0)+Θ(𝑛)=𝑇(𝑛−1)+Θ(𝑛)，解为𝑇(𝑛)=Θ(𝑛2)T(n)=Θ(n2)。

当划分产生的两个子问题分别包含⌊𝑛/2⌋和⌈𝑛/2⌉−1个元素时，**最好情况**发生。算法运行时间递归式为 𝑇(𝑛)=2𝑇(𝑛/2)+Θ(𝑛)，解为𝑇(𝑛)=Θ(𝑛lg𝑛)。

> 事实上只要划分是常数比例的，算法的运行时间总是𝑂(𝑛lg𝑛)。 假设按照 9:1 划分，每层代价最多为 cn，递归深度为 log10/9𝑛=Θ(lg𝑛)，故排序的总代价为𝑂(𝑛lg𝑛)。

快排的空间复杂度是Θ(lgn)，因为快排的实现是**递归调用**的， 而且每次函数调用中**只使用了常数的空间**，**因此空间复杂度等于递归深度Θ(lgn)**。

##### **随机算法**

可以通过在算法中引入随机性，使得算法对所有输入都能获得较好的期望性能。比如我们随机地选择pivot，这样上述的最坏情况就很难发生。 伪码描述是这样的：

```
//新的划分程序，只是在真正进行划分前进行一次交换
RANDOMIZED-PARTITION(A, p, r)
	i = RANDOM(p, r)
	exchange A[r] with A[i]
	return PARTITION(A, p, r)
```

C++实现也很简单，只需要在排序前随机去一个元素和末端元素交换。

```
void rand-quicksort(vector<int>& v, int begin, int end){
    if(end-begin<=1) return;

    int pindex = rand()%(end-begin) + begin;
    swap(v[end-1], v[pindex]);

    quicksort(v, begin, end);
}
```

**随机算法保证了对任何的输入而言，都可以保证Θ(𝑛lg𝑛)的时间复杂度。**



##### **python示例：**


```python
def quicksort(array):
    if len(array) < 2:
        return array
    else:
        pivot = array[0]
        less = [i for i in array[1:] if i <= pivot]
        greater = [i for i in array[1:] if i > pivot]
        return quicksort(less) + [pivot] + quicksort(greater) 
print((quicksort([10, 5, 2, 3])))
```

##### C++实现

按照上述`PARTITION`过程，实现`quicksort`方法，用来排序数组`v`中的[𝑏𝑒𝑔𝑖𝑛,𝑒𝑛𝑑)[begin,end)部分。

```
void quicksort(vector<int>& v, int begin, int end){
    if(end - begin<=1) return;
    int pivot = v[end-1], less_end = begin;

    for(int i=begin; i<end-1; i++)
        if(v[i]<pivot) swap(v[i], v[less_end++]);

    swap(v[end-1], v[less_end]);
    quicksort(v, begin, less_end);
    quicksort(v, less_end + 1, end);
}
```

实现思路是这样的：

1. 当只有一个元素时，它总是已经排好序的直接返回。
2. 取最后一个为`pivot`，比`pivot`小的元素存储在[0,𝑙𝑒𝑠𝑠𝑒𝑛𝑑)中。
3. 遍历[𝑏𝑒𝑔𝑖𝑛,𝑒𝑛𝑑−1)，如果它小于`pivot`就把它添加到[0,𝑙𝑒𝑠𝑠𝑒𝑛𝑑)中，同时让`less_end++`。
4. 将`pivot`放到[0,𝑙𝑒𝑠𝑠𝑒𝑛𝑑)的结尾。
5. 为[𝑏𝑒𝑔𝑖𝑛,𝑙𝑒𝑠𝑠𝑒𝑛𝑑)排序，此时`less_end`处的元素是`pivot`；同样为右边的[𝑙𝑒𝑠𝑠𝑒𝑛𝑑+1,𝑒𝑛𝑑)也排序。

<img src="/img/in-post/20_07/image-20210108095645510.png" alt="image-20210108095645510" style="zoom: 33%;" />



#### 计数排序— 适合量大但是范围小的情况，桶思想

#### 基数排序 — 多关键词排序，桶思想





### 🚩[215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

难度中等891

在未排序的数组中找到第 **k** 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

**示例 1:**

```
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
```

**示例 2:**

```
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
```

**总结：**

1. 快速排序思想

   ```python
   class Solution:
       def findKthLargest(self, nums: List[int], k: int) -> int:
   #         # 暴力   O(nlogn)
   #         nums.sort(reverse=True)
   #         return nums[k-1]
   
           # 快排思想
           k = len(nums) - k  # 升序排列后，index为len(nums)-k
           low = 0
           high = len(nums) - 1
           while low <= high:
               p = self.patition(nums, low, high)  # 中点坐标
               if k < p:  
                   high = p-1
               elif k > p:
                   low = p+1
               else:               # k == p, 该中点位置即要找的第K大的值
                   return nums[p]
           return -1
   
       # 进行一次分治排序
       def patition(self, alist, low, high):
           mid_value = alist[low]  # 初始化中间值为最左边的值
           while low < high:    
               while low < high and alist[high] >= mid_value: 
                   high -= 1
               alist[low] = alist[high] # 因为初始化中间值为最左边的值，所以直接赋值即可
   
               while low < high and alist[low] <= mid_value:
                   low += 1
               alist[high] = alist[low] # 右侧的一定操作过了
           alist[low] = mid_value
           return low  # 返回中点坐标
   
   ```
   
   
   
1. 考点
   <img src="/img/in-post/20_07/image-20210220141429722.png" alt="image-20210220141429722" style="zoom:50%;" />

   > 1. 可以利用快排优化O(nlogn)到O(n)
   > 2. 时间O(n)，最差O(nlogn)，空间复杂度：O(log n)，递归使用栈空间的空间代价的期望为 O(logn)。
   > 3. 

2. 快速排序

   ```python
   # 时间复杂度：o(nlogn)
   def quick_sort(alist, start, end):
       if start >= end:
           return
   
       mid_value = alist[start]
       low = start
       hight = end
   
       while low < hight:
           while low<high and alist[high] >= mid_value:
               high -= 1
           alist[low] = alist[high]
   
           while low < high and alist[low] <= mid_value:
               low += 1
           alist[high] = alist[low]
       alist[low] = mid_value
   
       quick_sort(alist, start, low-1)
       quick_sort(alist, low+1, end)
   
   if __name__ == '__main__':
       li = [54, 26, 93, 17, 77, 31, 44, 55, 20, 13]
       quick_sort(li, 0, len(li)-1)
       print(li)
   
   ```

   



## 动态规划

### 动态规划框架

**形式**: 动态规划问题的一般形式就是**求最值**。（比如说让你求最⻓递增子序列呀,最小编辑距离）

**步骤**:

1. 动态转移方程(如dp[n]与dp[n-1], dp[n-2]的关系)
2. 边界条件

[**例子**1]斐波那契数列

动态规划方程:`dp[i] = dp[i-1] + dp[i-1]`

边界条件:`dp[1]=dp[2]=1`

![image-20200801003343501](/img/in-post/20_07/image-20200801003343501.png)

[**例子**2]最长回文子串

动态规划方程:`P(i,j)=P(i+1,j−1)∧(Si==Sj)`

动态规划的边界条件：`P(i,i)=true, P(i,i+1)=(Si ==Si+1)`

[**例子**3]不同路径

动态转移方程: `dp[i,j] = dp[i-1,j] + dp[i,j-1]`

边界条件: `dp[0,j]=dp[i,0]=1`

[**例子**4]最小路径和

动态转移方程:`dp[i][j]=min(dp[i][j-1],dp[i-1][j])`

边界条件`dp[0][0]=dp[0][0], dp[m][0]+=dp[m-1][0], dp[0][n]+=dp[0][n-1]`



### 总结

#### 一维动态规划核心思想:


动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分(即**子问题**)，再根据子问题的解以得出原问题的解。

步骤：
    1. 确定初始条件
       

2. 讨论 最后加入最后一个元素 和 不加入最后一个元素 的情况， 建立动态规划数组dp

3. > 如：dp[i] = max(dp[i-1], dp[i-2] + nums[i-1])


要求：
* 只能处理没有相互依赖关系

####  二维动态规划
横向：加入新增商品价值 与 没加入该商品时最大价值(上一行) 比较，选择大的

大致上，若要解一个给定问题，**我们需要解其不同部分**(即子问题)，再根据子问题的解以得出原问题的解。动态规划往往用于**优化递归问题**，例如斐波那契数列，如果运用递归的方式来求解会重复计算很多相同的子问题，利用动态规划的思想可以减少计算量。

公式
![](https://cdn.jsdelivr.net/gh/sunqinghu/PicRepo/img/2020/20201023173011.png)

【例1】背包问题
![](https://cdn.jsdelivr.net/gh/sunqinghu/PicRepo/img/2020/20201023173114.png)

【例2】旅游行程最优化

横向：加入新增商品价值 与 没加入该商品时最大价值(上一行) 比较，选择大的
![](https://cdn.jsdelivr.net/gh/sunqinghu/PicRepo/img/2020/20201023173157.png)

#### 递归和动态规划

模式识别：一旦涉及子问题(状态转移)，**就可以使用自顶向下的递归和自底向上的动态规划**  

**递归(自顶向下) -- 大量冗余操作**

1. 定义递归出口
2. 最后字符相同，向前推以为
3. 否则，搜索插入删除替换动作

**动态规划(自底向上)：**  

1. 构造初始解
2. 抽象状态转移方程，根据转移方程构造更上层的解
   ![](https://tva1.sinaimg.cn/large/007S8ZIlly1ggxgoz3c8bj30hk0520t0.jpg)

### ✅ (10m) 70. 爬楼梯(程序自己写)  

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

#### 2️⃣

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        dp = [0] * (n+1)
        dp[0] = dp[1] = 1

        for i in range(2,n+1):
            dp[i] = dp[i-1] + dp[i-2]
        print(dp)
        return dp[n]
```





### ✅ (50m) 53. 最大子序和

给定一个整数数组 nums ，找到一个具有最大和的连续子数组(子数组最少包含一个元素)，返回其最大和。

```
示例:

输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
进阶:
```
如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。

```python
nums = [-2,1,-3,4,-1,2,1,-5,4]
max_sum = 0
for i in range(1,len(nums)):
    if nums[i-1] > 0:
        nums[i] = nums[i-1] + nums[i]
    max_sum = max(nums[i], max_sum)
max_sum
```


```python
# 贪心算法
nums = [-2,1,-3,4,-1,2,1,-5,4]
class Solution:
    def maxSubArray(self, nums: 'List[int]') -> 'int':
        n = len(nums)
        curr_sum = max_sum = nums[0]
        for i in range(1, n):
            curr_sum = max(nums[i], curr_sum + nums[i])
            max_sum = max(curr_sum, max_sum)
        return max_sum

solution = Solution()
result = solution.maxSubArray(nums)
print(result)
```


```python
# 动态规划 -- 实时改变数组
nums = [-2,1,-3,4,-1,2,1,-5,4]
class Solution:
    def maxSubArray(self, nums: 'List[int]') -> 'int':
        n = len(nums)
        max_sum = nums[0]

        for i in range(1, n):
            if nums[i-1] > 0:
                nums[i] += nums[i-1] 
            max_sum = max(nums[i], max_sum)

        return max_sum
    
solution = Solution()
result = solution.maxSubArray(nums)
print(result) 
```

总结：

如果只和低维的状态有关系，则可以进行状态压缩，从而节省空间。

### ✅(1.5h) 70. 爬楼梯(程序自己写)

    2月18,5:36 - 2月18， 6：03

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。
```
示例 1：

输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
示例 2：

输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶

```


```python
# 动态规划法核心公式: 
# 加入最后一个台阶即：到达第 ii 阶的方法总数就是到第 (i-1)(i−1) 阶和第 (i-2)(i−2) 阶的方法数之和。
# dp[i]=dp[i−1]+dp[i−2]
```


```python
n = 5
dp = [1, 1]
for i in range(2,n+1):
    dp.append(dp[i-1] + dp[i-2])
dp
dp[-1]
```

#### 2️⃣ (7m)


```python
n=10
dp = [0, 1, 2]
for i in range(3,n+1):
    dp.append(dp[i-1] + dp[i-2])
dp
dp[-1]
```

### ✅ 121. 买卖股票的最佳时机
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易(即买入和卖出一支股票)，设计一个算法来计算你所能获取的最大利润。

注意你不能在买入股票前卖出股票。

``` python
示例 1:

输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天(股票价格 = 1)的时候买入，在第 5 天(股票价格 = 6)的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
示例 2:

输入: [7,6,4,3,1]
输出: 0 
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```



```python
nums = [7,1,5,3,6,4]

num_min = nums[0]
profit = [0]

for i in range(1,len(nums)):
    num_min = min(nums[i], num_min)
    profit.append(max(nums[i] - num_min, profit[i-1]))
profit
profit[-1]
        
    
```

### ✅ 198. 打家劫舍
2月18, 4:54 - 2月18, 5:27

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

```
示例 1:

输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
示例 2:

输入: [2,7,9,3,1]
输出: 12
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

* 不能偷相邻的两栋房子，方案无非两种：
* 方案一：挑选的房子中包含最后一栋；
* 方案二：挑选的房子中不包含最后一栋；
* 获得的最大收益的最终方案，一定在这两种方案中产生


```python
# 核心思想:
# 动态规划公式:dp[i] = max(dp[i-1], dp[i-2] + nums[i-1])
# 不能偷相邻的两栋房子，方案无非两种：
# 方案一：挑选的房子中包含最后一栋；
# 方案二：挑选的房子中不包含最后一栋；
# 获得的最大收益的最终方案，一定在这两种方案中产生
nums = [2,7,9,3,1]
dp = []  # save the max_value in each length of given list
dp.extend([nums[0],max(nums[0],nums[1])])
```


```python
dp[1] = max(nums)
for i in range(2,len(nums)):
    dp.append(max(dp[i-1], dp[i-2]+nums[i]))
dp
dp[-1]
```

### ✅(5m)303. 区域和检索 - 数组不可变
给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。

```
示例：

给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()

sumRange(0, 2) -> 1
sumRange(2, 5) -> -1
sumRange(0, 5) -> -3
```


```python
# 官解 缓存法
class NumArray:

    def __init__(self, nums: List[int]):
        self.nums = nums

    def sumRange(self, i: int, j: int) -> int:
        ans = sum(self.nums[i:j+1])
        return ans

```

### ✅  (1.5h)  5. 最长回文子串
给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

```
示例 1：

输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
示例 2：

输入: "cbbd"
输出: "bb"
```


```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        if len(s)==0: return ""
        max_len_list = []
        for i in range(len(s)):
            if i==0: continue
            if s[i-1] == s[i]:
                j = 1
                while i-1-j>=0 and i+j<=len(s)-1 and s[i-1-j] == s[i+j]:
                    j += 1
                length = 2*j 
                if length > len(max_len_list):
                    max_len_list = s[i-j:i+j]       
            if i == len(s)-1: continue
            if s[i-1] == s[i+1]:
                j = 1
                while i-1-j>=0 and i+1+j<=len(s)-1 and s[i-1-j] == s[i+1+j]:
                    j += 1
                length = 2*j + 1
                if length > len(max_len_list):
                    max_len_list = s[i-j:i+j+1]
        if len(max_len_list)<=1: return s[0]
        return max_len_list
```


```python
# nums = "cbbd"
nums = "dd"
solution = Solution()
result = solution.longestPalindrome(nums)
result
```


```python
# 动态规划
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        dp =[[False] * n for _ in range(n)]
        ans = ""
        for l in range(n):
            for i in range(n):
                j = i+1
                if j >= len(s):
                    break
                if l == 0:
                    dp[i][j] = True
                elif l==1:
                    dp[i][j] = (s[i]==s[j])
                else:
                    dp[i][j]=(dp[i+1][j+1] and s[i]==s[j])
                if dp[i][j] and l+1 > len(ans):
                    ans = s[i:j+1]
            return ans
                
```

#### 2️⃣ (1.5h) 5. 最长回文子串
动态规划方程:`P(i,j)=P(i+1,j−1)∧(Si==Sj)`

动态规划的边界条件：`P(i,i)=true, P(i,i+1)=(Si ==Si+1)`

注意：在状态转移方程中，我们是从长度较短的字符串向长度较长的字符串进行转移的，因此一定要注意动态规划的循环顺序。
![](https://tva1.sinaimg.cn/large/007S8ZIlly1gjs5oeah1uj30zk0c2t9o.jpg)
![](https://tva1.sinaimg.cn/large/007S8ZIlly1gjs5vv9x00j30z40dm3zb.jpg)



```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        dp = [[False ]*n for i in range(n)]
        ans = ''
        l_ans, length = 0, 0
        for i in range(n):
            dp[i][i] = True 
        
        for r in range(1, n):
            for l in range(r):
                dp[l][r] = (s[l] == s[r]) and (dp[l+1][r-1] or r-l<3)
                if dp[l][r] and r-l+1 > length:
                    l_ans, length = l, r-l+1
        ans = s[l_ans:l_ans+length]
        return ans
```


```python
nums = "babab"
# nums = "dd"
solution = Solution()
result = solution.longestPalindrome(nums)
result
```

### ✅ (1.5h)  [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

难度中等718

一个机器人位于一个 _m x n _网格的左上角 (起始点在下图中标记为“Start” )。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角(在下图中标记为“Finish”)。

问总共有多少条不同的路径？

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png)

例如，上图是一个7 x 3 的网格。有多少可能的路径？

```
示例 1:

输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右
示例 2:

输入: m = 7, n = 3
输出: 28
```


**提示：**

  * `1 <= m, n <= 100`

1. 动态转移方程: `dp[i,j] = dp[i-1,j] + dp[i,j-1]`
2. 边界条件: `dp[0,j]=dp[i,0]=1`

空间优化:
1. O(2n):`cur[j] = pre[j] + cur[j-1]` 
2. O(n):`cur[j] += cur[j-1]`


```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        dp = [[1] * n] + [[1] + [0 for _ in range(m-1)]]
        
        for i in range(1,m):
            for j in range(1,n):
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
                
        return dp[-1][-1]
```


```python
m, n = 3, 2
solution = Solution()
result = solution.uniquePaths(m, n)
result
```

### ✅ (40m)  [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

难度中等425

一个机器人位于一个 _m x n _网格的左上角 (起始点在下图中标记为“Start” )。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角(在下图中标记为“Finish”)。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

![](https://cdn.jsdelivr.net/gh/sunqinghu/PicRepo/img/2020/robot_maze.png)

网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。

**说明：**_m_ 和 _n _的值均不超过 100。

**示例 1:**

```
输入:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
输出: 2
解释:
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```

#### 2️⃣

本题要再初始化一个dp数组，否则会变麻烦。


```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        if not obstacleGrid or not obstacleGrid[0] or obstacleGrid[0][0]==1:
            return 0
        m, n = len(obstacleGrid), len(obstacleGrid[0])
        # 考虑 [[0],[0]]情况
        if m == n == 1:
            return 1

        for i in range(1,n):
            if obstacleGrid[0][i] == 0:
                obstacleGrid[0][i] = 1
            else:
                for j in range(i, n):
                    obstacleGrid[0][j] = 0
                break
        for i in range(1,m):
            if not obstacleGrid[i][0]:
                obstacleGrid[i][0] = 1
            else:
                for j in range(i, m):
                    obstacleGrid[j][0] = 0
                break
        # print(obstacleGrid)

        for i in range(1, m):
            for j in range(1, n):
                if obstacleGrid[i][j]:
                    obstacleGrid[i][j] = 0
                else:
                    obstacleGrid[i][j] = obstacleGrid[i][j - 1] + obstacleGrid[i - 1][j]

        # print(obstacleGrid)
        return obstacleGrid[m - 1][n - 1]

```



### ✅(30m) [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

难度中等696

给定一个包含非负整数的 _m_ x _n_ 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

**示例:**
```
    
输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。    ```

1. 动态转移方程:`dp[i][j]=min(dp[i][j-1],dp[i-1][j])`
2. 边界条件`dp[0][0]=dp[0][0], dp[m][0]+=dp[m-1][0], dp[0][n]+=dp[0][n-1]`


​```python
class Solution:
    def minPathSum(self, grid) -> int:
        dp = grid
        m = len(dp)
        n = len(dp[0])
        
        dp[0][0]=dp[0][0]
        for i in range(1, m):
            dp[i][0]+=dp[i-1][0]
        for j in range(1, n):
            dp[0][j]+=dp[0][j-1]

        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] += min(dp[i][j-1],dp[i-1][j])

        return dp[-1][-1]
```


```python
nums = [
  [1,3,1],
  [1,5,1],
  [4,2,1]
    
]
solution = Solution()
result = solution.minPathSum(nums)
result
```

### 🚩（困难）(1.5h) (动态规划)72. 编辑距离

给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

插入一个字符
删除一个字符
替换一个字符


```
示例 1：

输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
示例 2：

输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')

```




```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        
```


```python
from typing import List

nums = 
solution = Solution()
result = solution.maxArea(nums)
result = 
```

### 10. 正则表达式匹配

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

说明:

s 可能为空，且只包含从 a-z 的小写字母。
p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。

```
示例 1:

输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
示例 2:

输入:
s = "aa"
p = "a*"
输出: true
解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
示例 3:

输入:
s = "ab"
p = ".*"
输出: true
解释: ".*" 表示可匹配零个或多个('*')任意字符('.')。
示例 4:

输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
示例 5:

输入:
s = "mississippi"
p = "mis*is*p*."
输出: false
```


```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        def Iter(s,p):
            if  s == [] and p == []:
                return True

            if (s[0] == p[0] or p[0] == '.') and p[1] != '*':
                s.pop(0)
                p.pop(0)
            if len(p) > 1:
                if p[0] == '.' and p[1] == '*':
                    p.pop(0)
                    p.pop(0)
                    for _ in range(len(s)):
                        Iter(s,p)
                        s.pop(0)
                if p[1] == '*':
                    findstr = p[0]
                    p.pop(0)
                    p.pop(0)
                    while len(s) != 0 and s[0] == findstr:
                        Iter(s,p)
                        s.pop(0)
        s = list(s)
        p = list(p)
        while not (s == [] and p == []):
            Iter(s,p)
        return False
                    
                    
                    
                
                
                
                
```


```python
from typing import List

s = "aab"
p = "aab"
solution = Solution()
result = solution.isMatch(s,p)
result
```

####  2️⃣(0.5h)

### ✅  9. 回文数

判断一个整数是否是回文数。回文数是指正序(从左向右)和倒序(从右向左)读都是一样的整数。

```
示例 1:

输入: 121
输出: true
示例 2:

输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
示例 3:

输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。
进阶:

你能不将整数转为字符串来解决这个问题吗？
```


```python
# 法1：自己写的 效率低
class Solution:
    def isPalindrome(self, num: int) -> bool:
        if num<0: return False
        c=0
        x = num
        while x != 0:
            x = x // 10
            c += 1
        print(c)
        num1 = num2 =num
        for i in range(c // 2):
            a = num1 % 10
            num1 = num1 //10
            
            b = num2 // 10**(c-1) % 10
            num2 = num2 * 10
            
            print(a, b)
            print(num1, num2)
            if  a != b: 
                return False
        return True
    
            
```


```python
from typing import List

nums = 11
solution = Solution()
result = solution.isPalindrome(nums)
result

```

#### int 整数翻转标准操作


```python
# 法2：
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if (x < 0 or (x % 10 == 0 and x != 0)) :
            return False
        revertedNumber = 0
        while(x> revertedNumber):
            revertedNumber = revertedNumber * 10 + x % 10  # int 数字翻转操作
            x = x // 10
            print(revertedNumber, x)
        return x == revertedNumber or x == revertedNumber //10
```


```python
from typing import List

nums = 113311
solution = Solution()
result = solution.isPalindrome(nums)
result

```


```python
s = "12"
s[:: -1]
int(s[1:])>0
```

### ✅ (40m)[322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

给定不同面额的硬币 `coins` 和一个总金额 `amount`。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 `-1`。

你可以认为每种硬币的数量是无限的。

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

#### 2️⃣

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [float('inf')] * (amount+1)
        dp[0] = 0
        
        for i in range(1, amount+1):
            for coin in coins:             
                if coin <= i:
                    dp[i] = min(dp[i-coin] + 1, dp[i])
        # print(dp)
        return dp[-1] if dp[-1] != float('inf') else -1  # 注意数值类型的要用 != 和 =，布尔型用 is 和 is not
 
```

总结：

1. dp方程：`dp[n] = min([1 + dp[n - coin] for coin in coins if (n - coin) >= 0]+ [amount+1])`

> 理解方式：从后向前思考（类似青蛙跳台阶问题），新的amount出现时，先遍历所有可选择的硬币**作为最后一个硬币的选择**，并分别从前面的子问题中得到计算剩下（amount-coin）硬币情况时的最优解。

2. 也可以初始化为无穷大 `float('inf')`
3. [贪心+dfs+剪枝 更快方法](https://leetcode-cn.com/problems/coin-change/solution/322-by-ikaruga/)

4.  **注意数值类型的要用 != 和 =，布尔型用 is 和 is not**

### ✅ (30m)[300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

难度中等1287

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

**示例 1：**

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

**示例 2：**

```
输入：nums = [0,1,0,3,2,3]
输出：4
```

**示例 3：**

```
输入：nums = [7,7,7,7,7,7,7]
输出：1
```

#### 2️⃣

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        if not nums: return 0
        dp = [1 for i in range(len(nums))]

        for i in range(1, len(nums)):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i],dp[j]+1)
        return max(dp)
```

### 🚩（困难）(30m)[354. 俄罗斯套娃信封问题](https://leetcode-cn.com/problems/russian-doll-envelopes/)

难度困难263

给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 `(w, h)` 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。

请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。

**说明:**
不允许旋转信封。

**示例:**

```
输入: envelopes = [[5,4],[6,4],[6,7],[2,3]]
输出: 3 
解释: 最多信封的个数为 3, 组合为: [2,3] => [5,4] => [6,7]。
```

```python
class Solution:
    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:
        envelopes.sort(key=lambda x:(x[0],-x[1]))

        nums = [envelopes[i][1] for i in range(len(envelopes))]
        print(nums)
        if not nums: return 0
        dp = [1 for i in range(len(nums))]

        for i in range(1, len(nums)):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i],dp[j]+1)
        return max(dp)
```

总结： 

1. 排序、lambda函数使用：

   ```python
   envelopes.sort(key=lambda x:(x[0],-x[1]))
   ```



### ✅(30m)[120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle/)

难度中等681

给定一个三角形 `triangle` ，找出自顶向下的最小路径和。

每一步只能移动到下一行中相邻的结点上。**相邻的结点** 在这里指的是 **下标** 与 **上一层结点下标** 相同或者等于 **上一层结点下标 + 1** 的两个结点。也就是说，如果正位于当前行的下标 `i` ，那么下一步可以移动到下一行的下标 `i` 或 `i + 1` 。

 

**示例 1：**

```
输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
输出：11
解释：如下面简图所示：
   2
  3 4
 6 5 7
4 1 8 3
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。
```

```python
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        # dp[0] = triangle[-1]
        n = len(triangle)
        if n<=1:
            return triangle[0][0] 
        for i in range(n-2, -1, -1): # 注意别忘了步长-1
            for j in range(i+1):
                # print(i,j,triangle)
                triangle[i][j] += min(triangle[i+1][j],triangle[i+1][j+1])
        
        # print(triangle)
        return triangle[0][0]
```

注意：

for i in range(n-2, -1, -1): # 注意别忘了步长-1

### 🚩(50m)[494. 目标和](https://leetcode-cn.com/problems/target-sum/)

难度中等540

给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 `+` 和 `-`。对于数组中的任意一个整数，你都可以从 `+` 或 `-`中选择一个符号添加在前面。

返回可以使最终数组和为目标数 S 的所有添加符号的方法数。



**示例：**

```
输入：nums: [1, 1, 1, 1, 1], S: 3
输出：5
解释：

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

一共有5种方法让最终目标和为3。
```

```python
class Solution:
    def findTargetSumWays(self, nums: List[int], S: int) -> int:
        target = (sum(nums) - S) / 2 
        if (sum(nums) - S) % 2 == 1:
            return 0
        
        dp = [[0 for i in range(2001)] for j in range(len(nums))]
        dp[0][nums[0] + 1000] = 1
        dp[0][-nums[0] + 1000] += 1
        for i in range(1, len(nums)):
            for suma in range(-1000,1001):
                if dp[i - 1][suma + 1000] > 0:
                    dp[i][suma + nums[i] + 1000] += dp[i - 1][suma + 1000]
                    dp[i][suma - nums[i] + 1000] += dp[i - 1][suma + 1000]
        return 0 if S > 1000 else dp[len(nums) - 1][S + 1000]
        
```

```python
class Solution(object):
    def largestDivisibleSubset(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        # The container that holds all intermediate solutions.
        # key: the largest element in a valid subset.
        subsets = {-1: set()}
        
        for num in sorted(nums):
            subsets[num] = max([subsets[k] for k in subsets if num % k == 0], key=len) | {num}
            print(subsets)

        return list(max(subsets.values(), key=len))

```

注意：

1. subsets 每次都会更新，并且会加入当前num到set里。
2. basecase为：{-1，set()}

#### 2️⃣

### ✅ (20m)[152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

难度中等928

给你一个整数数组 `nums` ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

**示例 1:**

```
输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

**示例 2:**

```
输入: [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
```

#### 2️⃣

```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        dp_min = nums[0] 
        dp_max = nums[0] 
        res = dp_max
        for i in range(1, len(nums)):
            dp_min,dp_max = min(nums[i], nums[i]*dp_max, nums[i]*dp_min), max(nums[i], nums[i]*dp_max, nums[i]*dp_min)                
            res = max(res, dp_max)
        return res
```

总结：

1. 🚩dp方程压缩，同时**注意dpmax和dpmin同时更新！！！！！！！！！！！！！否则会出错**

### ✅(50m)[91. 解码方法](https://leetcode-cn.com/problems/decode-ways/)

难度中等634

一条包含字母 `A-Z` 的消息通过以下映射进行了 **编码** ：

```
'A' -> 1
'B' -> 2
...
'Z' -> 26
```

要 **解码** 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，`"111"` 可以将 `"1"` 中的每个 `"1"` 映射为 `"A"` ，从而得到 `"AAA"` ，或者可以将 `"11"` 和 `"1"`（分别为 `"K"` 和 `"A"` ）映射为 `"KA"` 。注意，`"06"` 不能映射为 `"F"` ，因为 `"6"` 和 `"06"` 不同。

给你一个只含数字的 **非空** 字符串 `num` ，请计算并返回 **解码** 方法的 **总数** 。

题目数据保证答案肯定是一个 **32 位** 的整数。

 

**示例 1：**

```
输入：s = "12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
```

#### 2️⃣

## 深度优先搜索DFS+递归

### 总结

#### 步骤

1. 沿着树的深度遍历树的节点，尽可能深的搜索树的分支。
2. 当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。
3. 如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。

#### 概括
深度优先搜索的步骤分为 
1. 递归下去 
2. 回溯上来。

顾名思义，深度优先，则是以深度为准则，先**一条路走到底**，直到达到目标。这里称之为递归下去。

否则既没有达到目标又无路可走了，那么则**退回到上一步的状态**，走其他路。这便是回溯上来。

### 🚩(20m)  101. 对称二叉树
给定一个二叉树，检查它是否是镜像对称的。

```

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

    1
   / \
  2   2
 / \ / \
3  4 4  3
 

但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

    1
   / \
  2   2
   \   \
   3    3
 
 

进阶：

你可以运用递归和迭代两种方法解决这个问题吗？
```

#### 2️⃣使用递归的思想
 如果同时满足下面的条件，两个树互为镜像：

1. 它们的两个根结点具有相同的值
2. 每个树的右子树都与另一个树的左子树镜像对称


```python
# guanjie
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if not root: return 
        return self.check(root.left, root.right)
        
    def check(self, left, right):
        if left is None and right is None: return True
        if left is None or right is None: return False
        if left.val != right.val : return False
        return self.check(left.left, right.right) and self.check(left.right, right.left)
        
        
            
```

### 🚩(60m)  394. 字符串解码
给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。

 

```
示例 1：

输入：s = "3[a]2[bc]"
输出："aaabcbc"
示例 2：

输入：s = "3[a2[c]]"
输出："accaccacc"
示例 3：

输入：s = "2[abc]3[cd]ef"
输出："abcabccdcdcdef"
示例 4：

输入：s = "abc3[cd]xyz"
输出："abccdcdcdxyz"
```

#### 2️⃣栈和递归使用


```python
class Solution:
    def decodeString(self, s: str) -> str:
        def dfs(i):
            res, multi = "", 0
            while i<len(s):
                if '0' <= s[i] <= '9':
                    multi = multi*10 + s[i]
                elif s[i] == '[':
                    # 注意，返回i的含义是更新上层递归指针位置，因为内层递归已经吃掉一串str，若不跟新i，
                    # 外层仍然从i+1开始，则会重复处理内层处理过的一串str。
                    i, tmp = dfs(i+1)  
                    res += multi * tmp
                    multi = 0
                elif s[i] == ']':
                    return i,res
                else: res += s[i]
                i+=1
            return res
        return dfs(0)
```

###  🚩105. 从前序与中序遍历序列构造二叉树
根据一棵树的前序遍历与中序遍历构造二叉树。

注意:

你可以假设树中没有重复的元素。

例如，给出
```
前序遍历 preorder = [3,9,20,,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7
```

#### 2️⃣


```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        # def helper():
            if not preorder:
                return None
            root = TreeNode(preorder[0])
            mid = inorder.index(preorder[0])

            root.left = self.buildTree(preorder[1:mid+1], inorder[:mid]) # 主要要+1
            root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])
            
            return root
```

###  🚩114. 二叉树展开为链表
给定一个二叉树，原地将它展开为一个单链表。


```
例如，给定二叉树

    1
   / \
  2   5
 / \   \
3   4   6
将其展开为：

1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
```


```python
# 前序遍历
class Solution:
    def flatten(self, root: TreeNode) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        if root.left:
            root.next = root.left
        elif root.right:
            root.next = flatten(root.left)
```


###   🚩（困难）679. 24 点游戏
你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 *，/，+，-，(，) 的运算得到 24。

```python
示例 1:

输入: [4, 1, 8, 7]
输出: True
解释: (8-4) * (7-1) = 24
示例 2:

输入: [1, 2, 1, 2]
输出: False
注意:

除法运算符 / 表示实数除法，而不是整数除法。例如 4 / (1 - 2/3) = 12 。
每个运算符对两个数进行运算。特别是我们不能用 - 作为一元运算符。例如，[1, 1, 1, 1] 作为输入时，表达式 -1 - 1 - 1 - 1 是不允许的。
你不能将数字连接在一起。例如，输入为 [1, 2, 1, 2] 时，不能写成 12 + 12 。
```


```python
class Solution:
    def judgePoint24(self, nums: List[int]) -> bool:
        for i in range(4):
            if 
        def dfs(nums, depth):
            
```


```python
from typing import List

nums = [4, 1, 8, 7]
solution = Solution()
result = solution.judgePoint24(nums)
result

```

### 🚩(80m)[79. 单词搜索](https://leetcode-cn.com/problems/word-search/)

给定一个二维网格和一个单词，找出该单词是否存在于网格中。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。



```
# 示例
board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

给定 word = "ABCCED", 返回 true
给定 word = "SEE", 返回 true
给定 word = "ABCB", 返回 false
```

```python
# 官解
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

        def check(i: int, j: int, k: int) -> bool:
            if board[i][j] != word[k]:
                return False
            if k == len(word) - 1:
                return True
            
            visited.add((i, j)) # 增加至访问表
            result = False
            for di, dj in directions:  # 遍历每一个子节点
                newi, newj = i + di, j + dj
                if 0 <= newi < len(board) and 0 <= newj < len(board[0]):
                    if (newi, newj) not in visited:
                        if check(newi, newj, k + 1):   # 判断下一个节点
                            result = True
                            break
            
            visited.remove((i, j)) # 移除访问表
            return result

        h, w = len(board), len(board[0])
        visited = set()
        for i in range(h):
            for j in range(w):
                if check(i, j, 0):
                    return True
        
        return False

```



```python
class Solution:
    result = False
    directions=[(-1,0),(1,0),(0,-1),(0,1)]
    def exist(self, board: List[List[str]], word: str) -> bool:
        def dfs(board, word,str_one,n, visited, i, j):
            if self.result == True:
                return

            if len(str_one) > len(word):
                return
            str_one += board[i][j]
            print(str_one)
            if str_one == word:
                self.result = True
                return

            if board[i][j]==word[n]:
                for direction in self.directions:
                    new_i = i + direction[0]
                    new_j = j + direction[1]
                    if new_i<0 or new_j<0 or new_i>(len(board)-1) or \
                    new_j>(len(board[0])-1) or visited[new_i][new_j]:
                        continue
                    else:
                        visited[new_i][new_j] = True
                        dfs(board,word,str_one,n+1,visited, new_i,new_j)
                        visited[new_i][new_j] = False
        for i in range(len(board)):
            for j in range(len(board[0])):
                if board[i][j] == word[0]:
                    visited = [[False for i in range(len(board[0]))] 
                    for j in range(len(board))]
                    visited[i][j] = True
                    dfs(board,word,"",0,visited,i,j)
        return self.result
```

#### 2️⃣

## 宽度优先BFS

### BFS 算法框架

![image-20200801002743343](/img/in-post/20_07/image-20200801002743343.png)![image-20200801002801390](/img/in-post/20_07/image-20200801002801390.png)

### ✅ (30m)[111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的**节点数量**。

**说明：**叶子节点是指没有子节点的节点。

 

**示例 1：**

<img src="/img/in-post/20_07/ex_depth.jpg" alt="img" style="zoom:50%;" />

```
输入：root = [3,9,20,null,null,15,7]
输出：2
```

**示例 2：**

```
输入：root = [2,null,3,null,4,null,5,null,6]
输出：5
```

```python
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if not root: return 0
        deque = [root]  
        step = 1
        while deque:
            for i in range(len(deque)):  # 重要，要先把deque里的所有并列节点遍历完后，在遍历子节点，并找新节点，step+1
                node = deque.pop(0)
                if not node.left and not node.right:
                    return step
                if node.left: deque.append(node.left) # 注意先判断左右子节点是否是None
                if node.right: deque.append(node.right)
            step += 1
        return 0
```

总结：

1. `for i in range(len(deque)): `  很重要，要先把deque里的所有并列节点遍历完后，在遍历子节点，并找新节点，step+1
2. `if node.left: deque.append(node.left)` 注意先判断左右子节点是否是None

#### 2️⃣

### ✅(2.0h) [752. 打开转盘锁](https://leetcode-cn.com/problems/open-the-lock/)

难度中等211

你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： `'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'` 。每个拨轮可以自由旋转：例如把 `'9'` 变为 `'0'`，`'0'` 变为 `'9'` 。每次旋转都只能旋转一个拨轮的一位数字。

锁的初始数字为 `'0000'` ，一个代表四个拨轮的数字的字符串。

列表 `deadends` 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。

字符串 `target` 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。

 

**示例 1:**

```
输入：deadends = ["0201","0101","0102","1212","2002"], target = "0202"
输出：6
解释：
可能的移动序列为 "0000" -> "1000" -> "1100" -> "1200" -> "1201" -> "1202" -> "0202"。
注意 "0000" -> "0001" -> "0002" -> "0102" -> "0202" 这样的序列是不能解锁的，
因为当拨动到 "0102" 时这个锁就会被锁定。
```

**示例 2:**

```
输入: deadends = ["8888"], target = "0009"
输出：1
解释：
把最后一位反向旋转一次即可 "0000" -> "0009"。
```

**示例 3:**

```
输入: deadends = ["8887","8889","8878","8898","8788","8988","7888","9888"], target = "8888"
输出：-1
解释：
无法旋转到目标数字且不被锁定。
```

**示例 4:**

```
输入: deadends = ["0000"], target = "8888"
输出：-1
```

**提示：**

1. 死亡列表 `deadends` 的长度范围为 `[1, 500]`。
2. 目标数字 `target` 不会在 `deadends` 之中。
3. 每个 `deadends` 和 `target` 中的字符串的数字会在 10,000 个可能的情况 `'0000'` 到 `'9999'` 中产生。

```python
class Solution:
    def openLock(self, deadends: List[str], target: str) -> int:
        if "0000" in deadends: return -1
        deque = ["0000"]  
        step = 0
        visited = set(["0000"]+ deadends)  # list内类型变化方式

        # add
        def num_add(arr, idx):
            if arr[idx] == '9':
                newnum = '0'
            else: 
                newnum = str(int(arr[idx])+1)
            return arr[:idx] + newnum + arr[idx+1:]
        def num_red(arr, idx):
            if arr[idx] == '0':
                newnum = '9'
            else:
                newnum = str(int(arr[idx])-1)
            return arr[:idx] + newnum + arr[idx+1:]

        while deque:
            for num in range(len(deque)):  # 重要，要先把deque里的所有并列节点遍历完后，在遍历子节点，并找新节点，step+1
                node = deque.pop(0)
                visited.add(node)
                if node == target:
                    return step
                next_node = []
                for j in range(4):
                    next_node_add = num_add(node,j)
                    next_node_red = num_red(node,j)
                    next_node.append(next_node_add)
                    next_node.append(next_node_red)

                next_node = [i for i in next_node if i not in visited]  # 实现数组过滤
                deque.extend(next_node) 
                visited.update(next_node)  # set 传入可迭代元素的方式
            # print("visited",visited)
            # print("deque",deque)
            step += 1
        return -1

```

```python
# 官解
class Solution(object):
    def openLock(self, deadends, target):
        def neighbors(node):
            for i in xrange(4):
                x = int(node[i])
                for d in (-1, 1):
                    y = (x + d) % 10
                    yield node[:i] + str(y) + node[i+1:]

        dead = set(deadends)
        queue = collections.deque([('0000', 0)])
        seen = {'0000'}
        while queue:
            node, depth = queue.popleft()
            if node == target: return depth
            if node in dead: continue
            for nei in neighbors(node):
                if nei not in seen:
                    seen.add(nei)
                    queue.append((nei, depth+1))
        return -1

```

总结：

1. 关于防止进位的写法：

        def neighbors(node):
            for i in xrange(4):
                x = int(node[i])
                for d in (-1, 1):
                    y = (x + d) % 10
                    yield node[:i] + str(y) + node[i+1:]



### 🚩（困难）(90m) [773. 滑动谜题](https://leetcode-cn.com/problems/sliding-puzzle/)

在一个 2 x 3 的板上（`board`）有 5 块砖瓦，用数字 `1~5` 来表示, 以及一块空缺用 `0` 来表示.

一次移动定义为选择 `0` 与一个相邻的数字（上下左右）进行交换.

最终当板 `board` 的结果是 `[[1,2,3],[4,5,0]]` 谜板被解开。

给出一个谜板的初始状态，返回最少可以通过多少次移动解开谜板，如果不能解开谜板，则返回 -1 。

**示例：**

```
输入：board = [[1,2,3],[4,0,5]]
输出：1
解释：交换 0 和 5 ，1 步完成
输入：board = [[1,2,3],[5,4,0]]
输出：-1
解释：没有办法完成谜板
输入：board = [[4,1,2],[5,0,3]]
输出：5
解释：
最少完成谜板的最少移动次数是 5 ，
一种移动路径:
尚未移动: [[4,1,2],[5,0,3]]
移动 1 次: [[4,1,2],[0,5,3]]
移动 2 次: [[0,1,2],[4,5,3]]
移动 3 次: [[1,0,2],[4,5,3]]
移动 4 次: [[1,2,0],[4,5,3]]
移动 5 次: [[1,2,3],[4,5,0]]
输入：board = [[3,2,4],[1,5,0]]
输出：14
```

## 回溯算法

### 回溯算法框架

![image-20200801002556141](/img/in-post/20_07/image-20200801002556141.png)

### 总结

[leetcode全排列解析+回溯人们详解+练习](https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/)

#### 回溯算法

1. 深度优先遍历的特有的现象，节约空间  
   全排列思路：  
   在枚举第一位的时候，有 3 种情况。  
   在枚举第二位的时候，前面已经出现过的数字就不能再被选取了；  
   在枚举第三位的时候，前面 2 个已经选择过的数字就不能再被选取了。  
   ![image.png](https://pic.leetcode-cn.com/0bf18f9b86a2542d1f6aa8db6cc45475fce5aa329a07ca02a9357c2ead81eec1-image.png)
   ![](https://pic.leetcode-cn.com/6a464ba95a7ad1c247aa39610535984c241e6b95148f8bc36b02908a190b1d54-image.png)

第 1 步都是先画图，画图是非常重要的，只有画图才能帮助我们想清楚递归结构，想清楚如何剪枝

步骤，即在画图的过程中思考清楚：

1、分支如何产生；

2、题目需要的解在哪里？是在叶子结点、还是在非叶子结点、还是在从跟结点到叶子结点的路径？

3、哪些搜索是会产生不需要的解的？例如：产生重复是什么原因，如果在浅层就知道这个分支不能产生需要的结果，应该提前剪枝，剪枝的条件是什么，代码怎么写？

给定一个 没有重复 数字的序列，返回其所有可能的全排列。

**示例 :**

```
输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```


```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        def dfs(nums, size, depth, path, used, res):
            if depth == size:
                res.append(path[:])  # 注意相当于这里做一次拷贝。否则输出为全空
                return
            
            for i in range(size):  
                if not used[i]:
                    used[i] = True
                    path.append(nums[i]) # 添加到路径
                    
                    dfs(nums, size, depth+1, path, used, res)
                    
                    used[i] = False
                    path.pop()  # 从路径取出
                    
        size = len(nums)
        if len(nums) == 0:
            return []
        
        used = [False for _ in range(size)]
        res = []
        dfs(nums, size, 0, [], used, res)
        return res

```

#### 数组深拷贝、浅拷贝

    res.append(path[:])  # 注意相当于这里做一次拷贝。否则输出为全空


```python
# 浅拷贝, 指向同一地址
a = [2,3,34,4]
b = a
a.append(222)
a, b
```


```python
# 深拷贝， 不同地址
a = [2,3,34,4]
b = a[:]
c = list(a)
d = a*1
import copy
e = copy.copy(a)
a.append(222)
a, b, c, d, e
```

### ✅ 56. 合并区间

给出一个区间的集合，请合并所有重叠的区间。

```
示例 1:

输入: [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
示例 2:

输入: [[1,4],[4,5]]
输出: [[1,5]]
解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。
```


```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort(key=lambda x:x[0])
        
        merged = []
        for interval in intervals:
            if not merged or merged[-1][1] < interval[0]:
                merged.append(interval)
            else:
                merged[-1][1] = max(merged[-1][1], interval[1])
                
        return merged
```

#### 2️⃣  (10m)


```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        if intervals == []: return []
        intervals.sort()

        ans = [intervals[0]]
        for i in range(len(intervals)):
            if ans[-1][1] < intervals[i][0]:
                ans.append(intervals[i])
            else: 
                ans[-1][1] = max(ans[-1][1], intervals[i][1])   # 合并的方法        
        return ans
```


```python
from typing import List

nums = [[1,3],[2,6],[8,10],[15,18]]
solution = Solution()
result = solution.merge(nums)
result
```

### ✅ (20m) [46. 全排列](https://leetcode-cn.com/problems/permutations/)

给定一个 **没有重复** 数字的序列，返回其所有可能的全排列。

**示例:**

```
输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
] 
```

#### 2️⃣   


```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        if depth == size:
            res.append(path[:])
            return 
        
        for i in range(size):
            if not used[i]:
                used[i] = True
                path.append(nums[i])
                
                dfs(nums, size, depth+1, path, used, res)
                
                used[i] = False
                path.pop()
                
        size = len(nums)
        if size == 0:
            return []
        
        used = [False for _ in range(size)]
        res = []
        dfs(nums, size, 0, [], used, res)
        return res
        
```


```python
from typing import List

nums = [1,2,4]
solution = Solution()
result = solution.permute(nums)
result
```

#### 3️⃣

```python
class Solution:
    def __init__(self):
        self.result = [] 
    def permute(self, nums: List[int]) -> List[List[int]]:
        def permute_sub(nums,path):
            if len(path) == len(nums):
                self.result.append(path[:])
            for num in nums:
                if num not in path:
                    path.append(num) # 做选择
                    permute_sub(nums,path) # 递归
                    path.pop() # 撤销选择
        
        permute_sub(nums,[])
        return self.result
```

#### ④

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        def backtrack(path, nums):
            if len(path)==len(nums) :
                result.append(path[:])
                return                  # 注意，满足条件了就要return出去
            for i in range(len(nums)):
                if not visited[nums[i]]:  # 做选择前添加判断，跳过不满足条件的选择
                    path.append(nums[i])
                    visited[nums[i]] = True
                    backtrack(path,nums)
                    visited[nums[i]] = False
                    path.pop()

        result = []
        path = []
        visited = {key:False for key in nums}
        backtrack(path,nums)
        return result
```

总结：

1. 在basecase里，注意，满足条件了就要return出去
2. 组合问题需要做选择前添加判断，跳过不满足条件的选择



### ✅(60m) [51. N 皇后](https://leetcode-cn.com/problems/n-queens/)

难度困难725

**n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。

每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。

 

**示例 1：**

<img src="/img/in-post/20_07/queens.jpg" alt="img" style="zoom:50%;" />

```
输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
解释：如上图所示，4 皇后问题存在两个不同的解法。
```

**示例 2：**

```
输入：n = 1
输出：[["Q"]]
```

```python
class Solution:
    def __init__(self):
        self.result = [] 
    def solveNQueens(self, n: int) -> List[List[str]]:
        def solveNQueens_sub(n, path, diagonal1, diagonal2):
            if len(path) == n:
                self.result.append(path[:])
            for num in range(n):
                if num not in path and len(path) - num not in diagonal1 and len(path) + num not in diagonal2:
                    diagonal1.add(len(path) - num)
                    diagonal2.add(len(path) + num)
                    path.append(num) # 做选择
                    solveNQueens_sub(n,path,diagonal1,diagonal2) # 递归
                    path.pop() # 撤销选择
                    diagonal1.remove(len(path) - num)  # 注意长度要是当前的长度，和上面的add保持一致
                    diagonal2.remove(len(path) + num)

        diagonal1, diagonal2 = set(), set()   # 用set定义更容易，复杂度比较低，为O(log(n))
        solveNQueens_sub(n,[],diagonal1,diagonal2)
        self.result.sort()
        return [["."*index + "Q" + (n-index-1)*"." for index in path] for path in self.result]
```

总结：

1. 查找时可以考虑用 $set$，定义更容易，复杂度比较低，为$O(log(n))$。虽然 $dict$复杂度为 $O(1)$，但是由于有哈希化的过程，所以时间通常也没有少。

2. 注意回溯前后，长度要是当前的长度，和上面的add保持一致

   ```python
                       diagonal1.add(len(path) - num)
                       diagonal2.add(len(path) + num)
                       path.append(num) # 做选择
                       solveNQueens_sub(n,path,diagonal1,diagonal2) # 递归
                       path.pop() # 撤销选择
                       diagonal1.remove(len(path) - num)  # 注意长度要是当前的长度，和上面的add保持一致
                       diagonal2.remove(len(path) + num)
   ```


#### 🚩(30m)[78. 子集](https://leetcode-cn.com/problems/subsets/)

难度中等995

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

 

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

**示例 2：**

```
输入：nums = [0]
输出：[[],[0]]
```



```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        def backtrack(nums,start,track): 
            res.append(track[:])
            for i in range(start,len(nums)): # 从start开始可以避免重复
                track.append(nums[i])
                backtrack(nums,i+1,track)
                track.pop()

        res = []
        track = []
        backtrack(nums,0,track)
        return res
```

### ✅(40m)[77. 组合](https://leetcode-cn.com/problems/combinations/)

难度中等499

给定两个整数 *n* 和 *k*，返回 1 ... *n* 中所有可能的 *k* 个数的组合。

**示例:**

```
输入: n = 4, k = 2
输出:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

总结：

1. 回溯算法

```python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        def backtrack(start,path): 
            if len(path) == k:
                print(path)
                result.append(path[:])
            for i in range(start,n+1):
                path.append(i)
                backtrack(i+1,path)  # 注意这里是i+1
                path.pop()
        
        result = []
        path = []
        backtrack(1,path)
        return result
        

```

2. 注意开始的位置： `backtrack(i+1,path)  # 注意这里是i+1`， 这样才能保证每次都比当前大。

### [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

难度中等1566

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

 

**示例 1：**

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

**示例 2：**

```
输入：n = 1
输出：["()"]
```



```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        def backtrack(left,right,track,res):
            if left<0 or right<0:
                return 
            if right < left:
                return 
            if left==0 and right ==0:
                res.append(track)
                return 
            
            backtrack(left-1,right,track+'(',res)
            backtrack(left,right-1,track+')',res)
        
        if n==0:
            return {}
        res = []
        track = ""
        backtrack(n,n,track,res)
        return res
```



## 图

### 总结

#### 图定义

```python
# Definition for a Node.
class Node:
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []
```

### 🚩(1.0h) [133. 克隆图](https://leetcode-cn.com/problems/clone-graph/)

为了防止多次遍历同一个节点，陷入死循环，我们需要用一种数据结构记录已经被克隆过的节点。

```python
class Solution(object):

    def __init__(self):
        self.visited = {}

    def cloneGraph(self, node):
        """
        :type node: Node
        :rtype: Node
        """
        if not node:
            return node
        
        if node is self.visited:
            return self.visited[node]
        
        clone_node = Node(node.val, [])
        
        self.visited[node] = clone_node

        if node.neighbors:
            clone_node.neighbors = [self.cloneGraph(n) for n in node.neighbors]
        return clone_node
```



## 双指针

### 总结

1. 左右指针
2. 快慢指针
   1. <font size="4" color="red"><b>应用有哪些？</b></font>
      1. 判断链表又换
      2. 返回环的起始位置
      3. 找无环单链表中点

#### 经典，双指针定义, 典型例题，注意去重操作


当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从 O(N^2) 减少至 O(N)。为什么是 O(N) 呢？这是因为在枚举的过程每一步中，「左指针」会向右移动一个位置(也就是题目中的 b)，而「右指针」会向左移动若干个位置，这个与数组的元素有关，但我们知道它一共会移动的位置数为 O(N)，均摊下来，每次也向左移动一个位置，因此时间复杂度为 O(N)。

链接：https://leetcode-cn.com/problems/3sum/solution/san-shu-zhi-he-by-leetcode-solution/

### ✅(20m) 26. 删除排序数组中的重复项
给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

 

``` python
示例 1:

给定数组 nums = [1,1,2], 

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 

你不需要考虑数组中超出新长度后面的元素。
示例 2:

给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。
 

说明:

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```


```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        i = 0
        for j in range(len(nums)):
            if nums[i] != nums[j]:
                i += 1
                nums[i] = nums[j]
        return i+1
```


```python
from typing import List

nums = [0,0,1,1,1,2,2,3,3,4]
solution = Solution()
result = solution.removeDuplicates(nums)
result
```

### 🚩(40m) 15. 三数之和
给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。


```
示例：

给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```

#### 2️⃣**双指针格式**

```

while :
    if 
        i += 1
    if 
        j -= 1



for i in range():
    if :
        j -= 1
```

#### 2️⃣ (90m) 


```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums = sorted(nums)
        n = len(nums)
        if n < 3: return []
        res = []
        for i in range(n):
            # 如果第一个数都＞0，和不可能==0；
            # 保证和上一次枚举数不同(去重)
            if i>0 and nums[i] == nums[i-1]:
                continue
                
            k = n - 1  # 第三个指针指向最右端
            target = -nums[i]
            for j in range(i+1, n):
                # 保证除了紧邻上一个的位置外，和上一次枚举数不同(去重)
                if j > i+1 and nums[j] == nums[j-1]:
                    continue
                    
                # 指针j 在 指针k 左侧
                while j < k and nums[j] + nums[k] > target:
                    k -= 1
                if j == k: 
                    break
                if nums[j] + nums[k] == target:
                    res.append([nums[i],nums[j],nums[k]])
        
        return res
        
```


```python
nums = [-1, 0, 1, 2, -1, -4] 
solution = Solution()
result = solution.threeSum(nums)
result

```


```python
a = [1,2]
a.index(2)
a.index?
```

#### 2️⃣(1.5h)

#### 3️⃣(30m) 模板法

```
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        def twoSum(nums,start,target):
            res = []
            lo, hi = start,len(nums)-1
            while lo < hi:
                left, right = lo, hi
                if nums[lo] + nums[hi] < target:
                    lo += 1
                elif nums[lo] + nums[hi] > target:
                    hi -= 1
                elif nums[lo] + nums[hi] == target:
                    res.append([nums[lo],nums[hi]]) 
                    while lo<hi and nums[lo] == nums[left]:
                        lo += 1
                    while lo<hi and nums[hi] == nums[right]:
                        hi -= 1
            return res
        
        nums.sort()
        res = []
        target = 0
        for i in range(len(nums)):
            if 0<i<len(nums)-1 and nums[i] == nums[i-1]:  # 需要加上i>0 条件，否则会漏掉前两个相同且只有三个元素的情况
                continue
            result_double = twoSum(nums,i+1,target-nums[i]) # from i-1
            for result in result_double:
                result.append(nums[i])  # 注意这里的写法
                res.append(result[:])  
        return res
```



### ✅(50m) 11. (双指针)盛最多水的容器
给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器，且 n 的值至少为 2。
![](https://cdn.jsdelivr.net/gh/sunqinghu/PicRepo/img/2020/20201023173241.png)




图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水(表示为蓝色部分)的最大值为 49。


```
示例：

输入：[1,8,6,2,5,4,8,3,7]
输出：49
```


```python
# 动态规划 -- 自己写的，超时
class Solution:
    def maxArea(self, height: List[int]) -> int:
        dp = [0 for _ in range(len(height))]
        for i in range(len(height)):
            if i == 0:  continue
            dp[i] = max(dp[i-1], max(min(height[i], height[j]) * (i-j) for j in range(i)))
        return dp[-1]
```


```python
# 双指针
class Solution:
    def maxArea(self, height: List[int]) -> int:
        l, r = 0, len(height) - 1
        ans = 0
        while l < r:
            area = min(height[l], height[r]) * (r-l) 
            ans = max(ans,area)
            if height[l] <= height[r]:
                l = l+1
            else:
                r = r-1
        return ans
```

#### 2️⃣(20m)


```python
# 双指针
class Solution:
    def maxArea(self, height: List[int]) -> int:
        maxArea = 0
        n = len(height)
        i, j = 0, n-1
        while i < j:
            area = min(height[i], height[j]) * (j-i)  
            maxArea = max(area, maxArea)
            if height[i] <= height[j]:  # 判断哪个要动
                i += 1
            else: j-=1
            
        return maxArea
    
                
```


```python
from typing import List

nums = [1,8,6,2,5,4,8,3,7]
solution = Solution()
result = solution.maxArea(nums)
result
```


```python

```

### ✅（困难）(60m) [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

难度困难906

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

**注意：**如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

 

**示例 1：**

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
```

**示例 2：**

```
输入：s = "a", t = "a"
输出："a"
```

#### 2️⃣

```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        need=collections.Counter(t)
        window=collections.Counter() 
        left, right = 0, 0
        start, minlen = 0, float('inf')
        valid = 0
        
        while right < len(s):
            c = s[right]
            right += 1

            # 注意只有等于的时候添加，则不会出现重复添加的情况
            if c in need:
                window[c] += 1
                if window[c]==need[c]:
                    valid+=1
                
            # print(left, right)
            # print(need, window)
            
            while valid==len(need):
                if right-left<minlen:
                    start, minlen = left, right-left
                d = s[left]
                left += 1
                
                if d in need:
                    if window[d] == need[d]:
                        valid -= 1
                    window[d] -= 1

        return "" if minlen == float('inf') else s[start: start+minlen]

```

总结：

1. counter是计数器



### ✅ (20m)[567. 字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/)

难度中等222

给定两个字符串 **s1** 和 **s2**，写一个函数来判断 **s2** 是否包含 **s1** 的排列。

换句话说，第一个字符串的排列之一是第二个字符串的子串。

**示例1:**

```
输入: s1 = "ab" s2 = "eidbaooo"
输出: True
解释: s2 包含 s1 的排列之一 ("ba"). 
```

**示例2:**

```
输入: s1= "ab" s2 = "eidboaoo"
输出: False
```

```python
class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        need=collections.Counter(s1)
        window=collections.Counter() 
        left, right = 0, 0
        valid = 0

        while right < len(s2): 
            c = s2[right]
            right += 1
            # 进行数据更新
            if c in need:
                window[c] += 1
                if window[c] == need[c]:
                    valid += 1

            while right - left >= len(s1):
                # if minlen > right - left:
                #     start = left
                #     minlen = right - left
                if valid == len(need):
                    return True

                d = s2[left]
                left += 1
                # 进行数据更新
                if d in need:
                    if window[d] == need[d]:
                        valid -= 1
                    window[d]-=1

        return False
```

#### 2️⃣

```python
class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        need = collections.Counter(s1)
        window = collections.Counter
        if len(s1)>len(s2):
            return False
        for i in range(0,len(s2)-len(s1)+1):
            print(window(s2[i:i+len(s1)]), need)
            if window(s2[i:i+len(s1)]) == need:
                return True
        return False
```



### ✅(20m)[438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)

难度中等450

给定一个字符串 **s** 和一个非空字符串 **p**，找到 **s** 中所有是 **p** 的字母异位词的子串，返回这些子串的起始索引。

字符串只包含小写英文字母，并且字符串 **s** 和 **p** 的长度都不超过 20100。

**说明：**

- 字母异位词指字母相同，但排列不同的字符串。
- 不考虑答案输出的顺序。

**示例 1:**

```
输入:
s: "cbaebabacd" p: "abc"

输出:
[0, 6]

解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的字母异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的字母异位词。
```

 **示例 2:**

```
输入:
s: "abab" p: "ab"

输出:
[0, 1, 2]

解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的字母异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的字母异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的字母异位词。
```

```python
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        need=collections.Counter(p)
        window=collections.Counter() 
        left, right = 0, 0
        valid = 0
        ans = []
        while right < len(s): 
            c = s[right]
            right += 1
            # 进行数据更新
            if c in need:
                window[c] += 1
                if window[c] == need[c]:
                    valid += 1
                    
            while right - left >= len(p):
                if valid == len(need):
                    ans.append(left) 

                d = s[left]
                left += 1
                # 进行数据更新
                if d in need:
                    if window[d] == need[d]:
                        valid -= 1
                    window[d]-=1
                # print("window: [{}, {}], win:{}, res:{}\n".format(left, right, window, ans))
        return ans
```

### 

```
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        # if not s: return 0
        window=collections.Counter() 
        left, right = 0, 0
        ans = 0
        while right < len(s): 

            c = s[right]
            right += 1
            # 进行数据更新
            # if c in need:
            window[c] += 1
            print("window: [{}, {}], ans:{}\n".format(left, right, ans))                    
            while window[c] > 1:
                d = s[left]
                left += 1
                # 进行数据更新
                window[d]-=1
                print("window: [{}, {}], ans:{}\n".format(left, right, ans))
            ans = max(ans, right - left)  # 注意这个位置，是需要在非window[c]>1的情况下进行
        return ans
```



## 二分查找

### 二分查找框架

![image-20200801002907172](/img/in-post/20_07/image-20200801002907172.png)

### 总结

还有同学指出这么一个规律：

- 当 `while (left < right)` 时，对应的更新式是 `left = middle + 1` ， `right = middle`
- 当 `while (left <= right)` 时，对应的更新式是 `left = middle + 1`，`right = middle - 1`

本题由于【当区间长度为1时，即可停止二分查找】，所以是 `while (left < right)` ，所以是 `left = middle + 1`，`right = middle`



#### 要求

1. 数据结构排好序
2. 线性表具有随机访问的特点(如数组)
3. 线性表可以根据中间元素特点推测两侧元素性质

#### 二分法步骤


```python
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        n = len(numbers)
        for i in range(n):
            if 2 * numbers[i] > target:
                break
            
            a = i+1
            b = n-1
            while a <= b:
                c = (a+b)//2                
                if numbers[c] == target - numbers[i]:
                    return [i+1, c+1]
                elif numbers[c] < target - numbers[i]: # 注意必须是elif
                    a = c + 1  # 注意有+1 -1，保证不在边界，确保不会死循环
                else:
                    b = c - 1
```

#### 关键字：重复— 想哈希表（O(n),O(n))


```python
# 二分查找，小于等于i的个数  icnt[i]≤i
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        n = len(nums)
        l, r, ans = 1, n-1, -1
        while l<=r:
            mid = (l+r)//2 
            cnt = 0
            for i in range(n):
                cnt += nums[i] <= mid
            if cnt <= mid:
                l = mid + 1
            else:
                r = mid -1
                ans = mid
        return ans
```




###  ✅(20m) 167. 两数之和 II - 输入有序数组
给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。

函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。

说明:

返回的下标值（index1 和 index2)不是从零开始的。
你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。
``` python
示例:

输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
```



#### 2️⃣ 双指针+二分

**缩减搜索空间**的思想：

<img src="/img/in-post/20_07/9ebb3ff74f0706c3c350b7fb91fea343e54750eb5b6ae6a4a3493421a019922a-20210520111010978.gif" alt="搜索空间的减小过程（动图）" style="zoom:30%;" />



实际上还有几道题也是用到了这样的缩减搜索空间的思想：

- [11. Container With Most Water](https://leetcode-cn.com/problems/container-with-most-water/)
- [240. Search a 2D Matrix II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)



普通双指针：


```python
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        i, j = 0, len(numbers)-1
        while i < j:
            m = (i + j) >> 1 
            if numbers[i] + numbers[j] == target:
                return [i+1,j+1]
            elif numbers[i] + numbers[j] < target:
                i += 1
            else:
                j -= 1
        return []
```

双指针+二分：



### ✅(30m) 349. 两个数组的交集

给定两个数组，编写一个函数来计算它们的交集。

 

``` python
示例 1：

输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
示例 2：

输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
 

说明：

输出结果中的每个元素一定是唯一的。
我们可以不考虑输出结果的顺序。
```


```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        nums1 = sorted(list(set(nums1)))
        nums2 = sorted(list(set(nums2)))
        n1 = len(nums1)
        n2 = len(nums2)
        i, j = 0, 0
        ans = []
        while i<n1 and j<n2:
            if nums1[i] == nums2[j]:
                ans.append(nums1[i])
                i += 1
                j += 1
            elif nums1[i] < nums2[j]:
                i += 1
            elif nums1[i] > nums2[j]:
                j += 1
            
        return ans
            
                        
```


```python
from typing import List

nums1 = [1,2,2,1]
nums2 = [2,2]
solution = Solution()
result = solution.intersection(nums1, nums2)
result
```

###  🚩287. 寻找重复数
给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间(包括 1 和 n)，可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

``` python
示例 1:

输入: [1,3,4,2,2]
输出: 2
示例 2:

输入: [3,1,3,4,2]
输出: 3
说明：

不能更改原数组(假设数组是只读的)。
只能使用额外的 O(1) 的空间。
时间复杂度小于 O(n2) 。
数组中只有一个重复的数字，但它可能不止重复出现一次。
```

#### 2️⃣关键字：重复— 想哈希表（O(n),O(n))


```python
# 二分查找，小于等于i的个数  icnt[i]≤i
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        n = len(nums)
        l, r, ans = 1, n-1, -1
        while l<=r:
            mid = (l+r)//2 
            cnt = 0
            for i in range(n):
                cnt += nums[i] <= mid
            if cnt <= mid:
                l = mid + 1
            else:
                r = mid -1
                ans = mid
        return ans
```




```python
from typing import List

nums = [1,3,4,2,2]
solution = Solution()
result = solution.findDuplicate(nums)
result
```

###  🚩300. 最长上升子序列
给定一个无序的整数数组，找到其中最长上升子序列的长度。

``` python
示例:

输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
说明:

可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
你算法的时间复杂度应该为 O(n2) 。
进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?
```

#### 2️⃣ 注意用贪心+二分做可优化到O(nlogn)复杂度

###  🚩378. 有序矩阵中第K小的元素

给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。
请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。

``` python
示例：

matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

返回 13。
 

提示：
你可以假设 k 的值永远是有效的，1 ≤ k ≤ n2 。
```


```python
# 官解

class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        n = len(matrix)
        def check(mid):
            i, j = n-1, 0
            num = 0
            while i >= 0 and j<n:
                if matrix[i][j] <= mid:
                    num += i +1
                    j += 1
                else:
                    i -= 1
            return num>=k
        
        left, right = matrix[0][0], matrix[-1][-1]  # 注意是从-1，-1
        while left < right:
            mid = (left + right)//2
            if check(mid):
                right = mid
            else:
                left = mid + 1
        return left

```

#### 2️⃣

走法步骤：

```
初始位置在 matrix[n - 1][0]matrix[n−1][0]（即左下角）；

设当前位置为 matrix[i][j]matrix[i][j]。若 matrix[i][j] \leq midmatrix[i][j]≤mid，则将当前所在列的不大于 midmid 的数的数量（即 i + 1i+1）累加到答案中，并向右移动，否则向上移动；

不断移动直到走出格子为止。
```

时间复杂度：O(n\log(r-l))O(nlog(r−l))，二分查找进行次数为 O(\log(r-l))O(log(r−l))，每次操作时间复杂度为 O(n)O(n)。

### ✅(30m)[35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

### 🚩(30m)[153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

难度中等352

假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` 。

请找出其中最小的元素。

 

**示例 1：**

```
输入：nums = [3,4,5,1,2]
输出：1
```

**示例 2：**

```
输入：nums = [4,5,6,7,0,1,2]
输出：0
```

**示例 3：**

```
输入：nums = [1]
输出：1
```

注意：

1. 比较时比较nums[0]即可

2. 注意停止条件是：

   ```python
               if nums[mid] > nums[mid + 1]:
                   return nums[mid + 1]
               if nums[mid - 1] > nums[mid]:
                   return nums[mid]
   ```

#### 2️⃣

```
//            疑问：为什么 high = mid;而不是 high = mid-1;
//            解答：{4,5,1,2,3}，如果high=mid-1，则丢失了最小值1
```

## 贪心算法

贪心算法(又称贪婪算法)是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。

贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。


### ✅(20m) 455. 分发饼干
假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj >= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

注意：

你可以假设胃口值为正。
一个小朋友最多只能拥有一块饼干。

``` python
示例 1:

输入: [1,2,3], [1,1]

输出: 1

解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。
示例 2:

输入: [1,2], [1,2,3]

输出: 2

解释: 
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.
```


```python


class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        if len(g)==0 or len(s) == 0: return 0
        g.sort()
        s.sort()
        i = 0
        j = 0
        while i<len(g) and j<len(s):
            if s[j] >= g[i]:
                i += 1
            j += 1     
    
            
        return i
    
```


```python
from typing import List
g = [1,2,3,2]
s = [1,4]
solution = Solution()
result = solution.findContentChildren(g,s)
result
```

### ✅(20m) 392. 判断子序列
给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长(长度 ~= 500,000)，而 s 是个短字符串(长度 <=100)。

字符串的一个子序列是原始字符串删除一些(也可以不删除)字符而不改变剩余字符相对位置形成的新字符串。(例如，"ace"是"abcde"的一个子序列，而"aec"不是)。

``` python
示例 1:
s = "abc", t = "ahbgdc"

返回 true.

示例 2:
s = "axc", t = "ahbgdc"

返回 false.

后续挑战 :

如果有大量输入的 S，称作S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？
```


```python
# 双指针
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        n, m = len(s), len(t)  
        i = j = 0
        while i < n and j < m:
            if t[j] == s[i]:
                i += 1
            j += 1
        return i == n
                
```

### ✅(50m) [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

难度中等1089

给定一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。



**示例 1：**

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

**示例 2：**

```
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
```

## 位操作

位操作包括：

  * ¬ 取反（NOT)
  * ∩∩ 按位或（OR)
  * ⊕⊕ 按位异或（XOR)
  * ∪∪ 按位与（AND)
  * 移位

移位是一个二元运算符，用来将一个二进制数中的每一位全部都向一个方向移动指定位，溢出的部分将被舍弃，而空缺的部分填入一定的值。

移位又分为
* 算术移位
* 逻辑移位

### 总结

#### 使用 collection counter 例子

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> List[int]:
        from collections import Counter
        hashmap = Counter(nums)
        return [x for x in hashmap if hashmap[x] == 1]
```



###  🚩421. 数组中两个数的最大异或值
给定一个非空数组，数组中元素为 a0, a1, a2, … , an-1，其中 0 ≤ ai < 231 。

找到 ai 和aj 最大的异或 (XOR) 运算结果，其中0 ≤ i,  j < n 。

你能在O(n)的时间解决这个问题吗？

``` python
示例:

输入: [3, 10, 5, 25, 2, 8]

输出: 28

解释: 最大的结果是 5 ^ 25 = 28.
```


```python
class Solution:
    def findMaximumXOR(self, nums: List[int]) -> int:
```



###  ✅ 260. 只出现一次的数字 III
给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。

``` python
示例 :

输入: [1,2,1,3,2,5]
输出: [3,5]
注意：

结果输出的顺序并不重要，对于上面的例子， [5, 3] 也是正确答案。
你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？
```

#### 2️⃣

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> List[int]:
        res = 0
        for num in nums:
            res ^= num
        # print(res)
        
        div = 1
        while div & res == 0:
            print(div & res)
            div <<= 1  # 位运算注意要赋值啊！！

        res1, res2 = 0, 0
        for num in nums:
            if num & div:
                res1 ^= num
            else:
                res2 ^= num
        return [res1,res2]
        
```



## 数学

### 总结

#### 负数的python数学操作

```python
在python这个神奇的语言里，负数取模和负数地板除和其他语言是不一样的。
需要把取模替换成%(-val)
把地板除替换成int(x / val)

ans += (x % 10) if x>0 else (x%-10)
x = x // 10 if x>0 else int(x/10)

```



### ✅7.整数反转  

给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

``` python
示例 1:

输入: 123
输出: 321
示例 2:

输入: -123
输出: -321
示例 3:

输入: 120
输出: 21
注意:

假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。
```


```python
num = 123
num_reverse = num//100 + (num%100//10)*10 + (num%100%10)*100
num_reverse
```


```python
2**31
```

#### 2️⃣  
#### 2️⃣ (1.5h)

#### ✅ (30m)  7. 整数反转


```python
class Solution:
    def reverse(self, x: int) -> int:
        string = list(str(x))
        if string[0] == '-':
            string.pop(0)
            ans = 0
    #         print (string)
            for i in range(len(string)):
                ans = int(string[i])*10**i + ans
            ans = -ans
        else:
            ans = 0
    #         print (string)
            for i in range(len(string)):
                ans = int(string[i])*10**i + ans 
        if ans<-2**31 and ans>2**31-1: return 0
        return ans
```


```python
# m数学法
class Solution:
    def reverse(self, x): 
        ans = 0
        while (x != 0): 
            pop = x % 10
            ans = ans * 10 + pop
            x = x//10
        return ans

```


```python
from typing import List

nums = 123
solution = Solution()
result = solution.reverse(nums)
result
```

###  🚩4. 寻找两个正序数组的中位数
给定两个大小为 m 和 n 的正序(从小到大)数组 nums1 和 nums2。

请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 nums1 和 nums2 不会同时为空。


```
示例 1:

nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0

示例 2:

nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5
```

#### 2️⃣  


```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        
        
        
        
```


```python
nums1 = [1, 2]
nums2 = [3, 4]
solution = Solution()
result = solution.findMedianSortedArrays(nums1,nums2)
result
```

### ✅(1h)[204. 计数质数](https://leetcode-cn.com/problems/count-primes/)

难度简单615

统计所有小于非负整数 *`n`* 的质数的数量。

**示例 1：**

```
输入：n = 10
输出：4
解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
```

**示例 2：**

```
输入：n = 0
输出：0
```

**示例 3：**

```
输入：n = 1
输出：0
```

 

**提示：**

- `0 <= n <= 5 * 106`

```python
class Solution:
    def countPrimes(self, n: int) -> int:
        # if n <=1 :return 0
        # not_prime = [False for i in range(n)]
        # for i in range(2,n//2+1):
        #     for j in range(2,n//i+1):
        #         if i*j >= n:
        #             break
        #         not_prime[i*j] = True

        # # print(not_prime)
        # return n-sum(not_prime)-2

        if n <=1 :return 0
        is_prime = [True for i in range(n)]
        for i in range(2,int(n**(1/2)+1)):
            # for j in range(2,n+1//i):
            if is_prime[i]:
                for j in range(i, (n-1)//i+1): # 注意i的取值，10个的话，取到9
                    is_prime[i*j] = False

        print(is_prime)
        return sum(is_prime)-2
```



![Sieve_of_Eratosthenes_animation.gif](/img/in-post/20_07/1606932458-HgVOnW-Sieve_of_Eratosthenes_animation.gif)

注意：

1. 注意每次找当前**素数 x** 的倍数时，是从 x^2 开始的。

   > 如果 x > 2，那么 2 * x 肯定被素数 2 给过滤了，以此类推，最小未被过滤的肯定是 x^2.

2. 由于（1），标记到 $\sqrt{n}$ 时停止即可
3. 细节问题：
   1. (n+1)//i 而不是 n+1//i
   2. 注意取值：`for j in range(i, (n-1)//i+1):` （10个的话，取到9）

## 字典，哈希表

### 总结

#### 字典使用和查字典方法

* 遍历列表同时查字典 -- 字典查找速度快
* 搜索元素就想字典(hash表)

``` python
for i, n in enumerate(nums):
    if target - n in dct:
        return [dct[target - n], i]
    dct[n] = i
```


```python
nums = [2, 7, 11, 15]
target = 9
```


```python
# 主要思想: 
# 判断 if target - n in dct

class Solution:
    def twoSum(nums, target):
        dct = {}
        for i, n in enumerate(nums):
            if target - n in dct:
                return [dct[target - n], i]
            dct[n] = i
            
result = Solution.twoSum(nums,target)
result
```


```python
# 直接从数组中找
# 800ms so slow
```


```python
start = time.time()
class Solution:
    def twoSum(nums, target):
        for i, n in enumerate(nums):
            if (target - n) in nums[i+1:]:
                j = nums[i+1:].index(target - n)
                return [i, j+i+1]

result = Solution.twoSum(nums,target)
result

end = time.time()
print((start - end))
```



### 🚩1.两数之和

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
```
示例:

给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```

**字典使用和查字典方法**

* 遍历列表同时查字典 -- 字典查找速度快
* 搜索元素就想字典(hash表)
``` python
for i, n in enumerate(nums):
    if target - n in dct:
        return [dct[target - n], i]
    dct[n] = i
```


```python
nums = [2, 7, 11, 15]
target = 9
```


```python
# 主要思想: 
# 判断 if target - n in dct

class Solution:
    def twoSum(nums, target):
        dct = {}
        for i, n in enumerate(nums):
            if target - n in dct:
                return [dct[target - n], i]
            dct[n] = i
            
result = Solution.twoSum(nums,target)
result
```


```python
# 直接从数组中找
# 800ms so slow
```


```python
start = time.time()
class Solution:
    def twoSum(nums, target):
        for i, n in enumerate(nums):
            if (target - n) in nums[i+1:]:
                j = nums[i+1:].index(target - n)
                return [i, j+i+1]

result = Solution.twoSum(nums,target)
result

end = time.time()
print((start - end))
```

#### 2️⃣ (1.5h)



### ✅ 136. 只出现一次的数字 
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
```
说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

输入: [2,2,1]
输出: 1
示例 2:

输入: [4,1,2,1,2]
输出: 4
```



#### 2️⃣

```PYTHOn
class Solution:
    def singleNumber(self, nums: List[int]) -> List[int]:
        res = 0
        for num in nums:
            res ^= num

        return res
```



### ✅ (40m) 448. 找到所有数组中消失的数字

给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。

找到所有在 [1, n] 范围之间没有出现在数组中的数字。

您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。
```
示例:

输入:
[4,3,2,7,8,2,3,1]

输出:
[5,6]
```

#### 2️⃣原地修改方法 对i处位置的值为索引将其数字 `*-1`

```python
class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        for num in nums:
            if num < 0:
                num = -num
            if nums[num-1] > 0:
                nums[num-1] *= -1
        
        return [i+1  for i in range(len(nums)) if nums[i] > 0]  # 顺序是从前往后的, for, if 
```



###  ✅ (5m) 104. 二叉树的最大深度
给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

```
示例：
给定二叉树 [3,9,20,null,null,15,7]，

    3
   / \
  9  20
    /  \
   15   7
返回它的最大深度 3 。
```

#### 2️⃣

## SQL

### 总结

#### SQL 

MYSQL language  

内联结：  
select ...  
from ... inner join  
on ...  

外联结：  
考虑到可能不是每个人都有地址信息，我们应该使用 outer join 而不是默认的 inner join
select ...  
frome ... left join ...  
on ...  


```python
# SQL
select FirstName, LastName, City, State
from Person left join Address
on Person.PersonID = Address.PersonID
;
```

#### 

### 🚩175. 组合两个表 - SQL架构

表1: Person

```
+-------------+---------+
| 列名         | 类型     |
+-------------+---------+
| PersonId    | int     |
| FirstName   | varchar |
| LastName    | varchar |
+-------------+---------+
PersonId 是上表主键
```

表2: Address

```
+-------------+---------+
| 列名         | 类型    |
+-------------+---------+
| AddressId   | int     |
| PersonId    | int     |
| City        | varchar |
| State       | varchar |
+-------------+---------+
AddressId 是上表主键
```

编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：

 ```
 FirstName, LastName, City, State
 ```

#### 2️⃣ 


```python
select FirstName, LastName, City, State
from Person left join Address
on Person.PersonID = Address.PersonID
;
```

## 滑动窗口

### 滑动窗口算法框架

![image-20200801003210337](/img/in-post/20_07/image-20200801003210337.png)



## 字符串操作

### ✅(1.5h) 93. 复原IP地址

给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。

有效的 IP 地址正好由四个整数(每个整数位于 0 到 255 之间组成)，整数之间用 '.' 分隔。

 

```
示例:

输入: "25525511135"
输出: ["255.255.11.135", "255.255.111.35"]

```


```python
class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        count = []
        for i in range(1,4):
            for j in range(1,4):
                for k in range(1,4):
                    for l in range(1,4):
                        if len(s) == i+j+k+l:
                            printstate = True
                            if int(s[:i]) < 256 and int(s[i:i+j]) < 256 and int(s[i+j:i+j+k]) < 256 and int(s[i+j+k:i+j+k+l]) < 256:
                                for ss in [s[:i],s[i:i+j],  s[i+j:i+j+k],s[i+j+k:i+j+k+l]]:
                                    if ss[0] == '0' and len(ss)>1: 
                                        printstate = False
                                if printstate == True:
                                    count.append(s[:i] +'.'+ s[i:i+j] +'.'+ s[i+j:i+j+k] +'.'+ s[i+j+k:i+j+k+l])

                                print(count)

        return count
            
```


```python
from typing import List

nums = "25525511135"
solution = Solution()
result = solution.restoreIpAddresses(nums)
result
```

### 🚩(1.5h) [6. Z 字形变换](https://leetcode-cn.com/problems/zigzag-conversion/)

难度中等877收藏分享切换为英文接收动态反馈

将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 `"LEETCODEISHIRING"` 行数为 3 时，排列如下：

    L C I R E T O E S I I G E D H N 

之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：`"LCIRETOESIIGEDHN"`。

请你实现这个将字符串进行指定行数变换的函数：
    

    string convert(string s, int numRows);

```
示例 1:

输入: s = "LEETCODEISHIRING", numRows = 3
输出: "LCIRETOESIIGEDHN"
示例 2:

输入: s = "LEETCODEISHIRING", numRows = 4
输出: "LDREOEIIECIHNTSG"
解释:

L     D     R
E   O E   I I
E C   I H   N
T     S     G
```



# LCOF

### ✅ 03数组中重复的数字
找出数组中重复的数字。


在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

```
示例 1：

输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 
```

限制：

2 <= n <= 100000

**回溯算法(回溯搜索算法)**  

1. 深度优先遍历的特有的现象，节约空间  
全排列思路：  
在枚举第一位的时候，有 3 种情况。  
在枚举第二位的时候，前面已经出现过的数字就不能再被选取了；  
在枚举第三位的时候，前面 2 个已经选择过的数字就不能再被选取了。  

```python
# 自己做的: 排序后前后对比
# 90％ 100％
nums = [2, 3, 1, 0, 2, 5, 3]

def findRepeatNumber(nums) -> int:
    nums_sorted = sorted(nums)
    length = len(nums_sorted)
    for i in range(length-1):
        if nums_sorted[i] == nums_sorted[i+1]:
            return nums_sorted[i]
        
findRepeatNumber(nums)
```


```python
# 法2: 原地替换 不如我的高
nums = [2, 3, 1, 0, 2, 5, 3]

def findRepeatNumber(nums) -> int:
    nums_sorted = sorted(nums)
    length = len(nums_sorted)
    for i in range(length):
        while nums_sorted[i] != i:
            if nums_sorted[i] == nums_sorted[nums_sorted[i]]:
                return nums_sorted[i]
            temp = nums_sorted[i]
            nums_sorted[i] = nums_sorted[temp]
            nums_sorted[temp] = temp
            
findRepeatNumber(nums)
```


```python
# 法3: hash表
nums = [2, 3, 1, 0, 2, 5, 3]

def findRepeatNumber(nums) -> int:
    hashlist = [False for i in range(len(nums))]
    for i in range(len(nums)):
        if hashlist[nums[i]] == True:
            return nums[i]
        else: 
            hashlist[nums[i]] = True
        
        
findRepeatNumber(nums)
```



### ✅ 04. 二维数组中的查找
在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

示例:

现有矩阵 matrix 如下：
```
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
```
给定 target = 5，返回 true。
给定 target = 20，返回 false。


```python
matrix = [
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]]

matrix = [[5]]

def findNumberIn2DArray(matrix, target):
    if len(matrix)==0 or len(matrix[0])==0:
        return False  
    
    row = 0
    col = len(matrix[0])-1
    while True:
        if matrix[row][col]==target:
            return True

        if matrix[row][col]>target:
            if (col==0): 
                return False
            else: 
                col -= 1
        elif matrix[row][col]<target:
            if (row==len(matrix)-1):
                return False
            else: 
                row += 1
findNumberIn2DArray(matrix, 5)
```

#### C++





### ✅ 05. 替换空格

请实现一个函数，把字符串 s 中的每个空格替换成"%20"。

 

示例 1：
```
输入：s = "We are happy."
输出："We%20are%20happy."
```


```python
s = "We are happy."
```


```python
# 90 100 
# 注意replace() 不改变原str内容能提高, 
# 在 Python 和 Java 等语言中，字符串都被设计成不可变的类型，
# 即无法直接修改字符串的某一位字符，需要新建一个字符串实现。
class Solution:
    def replaceSpace(s: str) -> str:        
        return s.replace(' ','%20')

Solution.replaceSpace(s)
```


```python
# 切割拼接法
class Solution:
    def replaceSpace(s: str) -> str:    
        lst = s.split(' ')
        return '%20'.join(lst)
Solution.replaceSpace(s)
```

###  🚩06. 从尾到头打印链表
#### 自制链表及其函数

输入一个链表的头节点，从尾到头反过来返回每个节点的值(用数组返回)。


```
示例 1：

输入：head = [1,3,2]
输出：[2,3,1]
```

​	


```python
head = [1,3,2]
```




```python
	# 注意这道题的链表的形式
# head.val 当前value
# head.next 下一个值的地址

# Definition for singly-linked list.
class ListNode(object):
    def __init__(self):
        self.val = None
        self.next = None

class ListNode_handle:
    def __init__(self):
        self.cur_node = None
 
    def add(self, data):
        #add a new node pointed to previous node
        node = ListNode()
        node.val = data
        node.next = self.cur_node
        self.cur_node = node
        return node
 
    def print_ListNode(self, node):
        while node:
            print ('\nnode: ', node, ' value: ', node.val, ' next: ', node.next)
            node = node.next
 
    def _reverse(self, nodelist):
        list = []
        while nodelist:
            list.append(nodelist.val)
            nodelist = nodelist.next
        result = ListNode()
        result_handle = ListNode_handle()
        for i in list:
            result = result_handle.add(i)
        return result

ListNode_1 = ListNode_handle()
l1 = ListNode()
l1_list = [1,3,2]
for i in l1_list:
    l1 = ListNode_1.add(i)
l1 = ListNode_1._reverse(l1)
ListNode_1.print_ListNode(l1)
```


```python
class Solution:
    def reversePrint(head):
        res = []
        while head:
            res.append(head.val)
            head = head.next
        return res[::-1]

head = l1
Solution.reversePrint(head)
```

### 🚩07. 重建二叉树
输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。


```
例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7
```


hash to save time  
不重复 --> 想hash表


```python
preorder = [3,9,20,15,7]
inorder = [9,3,15,20,7]
```


```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

from typing import List

class Solution:
#     def buildTree(self, preorder, inorder):
    def buildTree(self, preorder: List[int], inorder: List[int]):
        self.dic, self.po={}, preorder # position ??????? 
        for i in range(len(inorder)):
            self.dic[inorder[i]] = i
        print(self.dic)
        return self.recur(0,0,len(inorder)-1)
        
    def recur(self, pre_root, left_root, right_root):
        if left_root>right_root: return
        # 1st layer to recursion
        root = TreeNode(self.po[pre_root])
        i = self.dic[self.po[pre_root]]
        self.left = self.recur(pre_root+1,in_left,i-1)
        self.right = self.recur(i-in_left+pre_root+1,i+1,in_right)
        return root

solution = Solution()
solution.buildTree(preorder,inorder)          
```



### 🚩09. 用两个栈实现队列
用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )
```
示例 1：

输入：
["CQueue","appendTail","deleteHead","deleteHead"]
[[],[3],[],[]]
输出：[null,null,3,-1]
示例 2：

输入：
["CQueue","deleteHead","appendTail","appendTail","deleteHead","deleteHead"]
[[],[],[5],[2],[],[]]
输出：[null,-1,null,null,5,2]
```


```python
class CQueue:

    def __init__(self):
        self.A, self.B = [], []
        
    def appendTail(self, value: int) -> None:
        self.A.append(value)

    def deleteHead(self) -> int:
        if self.B: return self.B.pop()
        if not self.A: return -1        
        while self.A:
            self.B.append(self.A.pop())
        return self.B.pop()


# Your CQueue object will be instantiated and called as such:
# obj = CQueue()
# obj.appendTail(value)
# param_2 = obj.deleteHead()
```

### ✅10- I. 斐波那契数列
写一个函数，输入 n ，求斐波那契（Fibonacci)数列的第 n 项。斐波那契数列的定义如下：

F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

答案需要取模 1e9+7（1000000007)，如计算初始结果为：1000000008，请返回 1。

```
示例 1：

输入：n = 2
输出：1
示例 2：

输入：n = 5
输出：5
```

尝试动态规划方法

```python
n = 43
```


```python
class Solution:
    def fib(self, n: int) -> int:
        if n == 0: return 0
        if n == 1: return 1
        fiblist = [0,1]
        for i in range(2,n+1):
            fiblist.append((fiblist[i-1]+fiblist[i-2])% 1000000007)
        return fiblist.pop()
        
        
        
        
```


```python
# 动态规划方法
class Solution:
    def fib(self, n: int) -> int:
        if n == 0: return 0
        if n == 1: return 1
        a, b = 0, 1
        for _ in range(n):
            a, b = b, a+b
        return a % 1000000007
```


```python
solution = Solution()
result = solution.fib(n)
result
```

#### 2️⃣(32m)

```
class Solution:
    def fib(self, n: int) -> int:
        if n == 0: return 0
        if n == 1 or n == 2:
            return 1
        # 1
        # dp = [0 for i in range(n+1)]
        # dp[1], dp[2] = 1, 1
        
        # # 2
        # for i in range(3,n+1):
        #     dp[i] = dp[i-1] + dp[i-2]
        
        # return dp[n] % (10**9+7)

        pre, cur = 1, 1
        for i in range(n-2):
            sum = pre + cur 
            pre, cur = cur, sum
        
        return cur % (10**9+7)

```



### ✅ 10- II. 青蛙跳台阶问题

一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

答案需要取模 1e9+7（1000000007)，如计算初始结果为：1000000008，请返回 1。
```
示例 1：

输入：n = 2
输出：2
示例 2：

输入：n = 7
输出：21
```


```python
n = 7
```


```python
class Solution:
    def numWays(self, n: int) -> int:
        if n == 0: return 0
        if n == 1: return 1
        if n == 2: return 2
        a, b = 1, 2
        for _ in range(n-1):
            a, b = b, a+b
        return a%1000000007
```


```python
solution = Solution()
result = solution.numWays(n)
result
```

### 🚩11. 旋转数组的最小数字
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  
```
示例 1：

输入：[3,4,5,1,2]
输出：1
示例 2：

输入：[2,2,2,0,1]
输出：0
```

### 🚩12. 矩阵中的路径
请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径(路径中的字母用加粗标出)。

[["a","b","c","e"],
["s","f","c","s"],
["a","d","e","e"]]

但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。


```
示例 1：

输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
示例 2：

输入：board = [["a","b"],["c","d"]], word = "abcd"
输出：false
```


```python
board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]]
word = "ABCCED"

```


```python
# buxing 

class Solution:    
    def exist(self, board, word: str) -> bool:    
        for i in range(len(board)):
            for j in range(len(board[0])):
                if board[i][j] == word[0]: 
                    if self.it(0,i,j):
                        return True                    
        return False
                
    def it(self, index, i, j):
        for (m,n) in [(i,j-1),(i,j+1),(i-1,j),(i+1,j)]:
            if not 0<=m<len(board) or not 0<=n<len(board[0]) or board(m,n)!=word[index+1]: # 越界→下次循环
                continue                
            if board[m][n]==word[index+1] and not vis[m][n]: # 为下一个值且没访问过
                if index+1 == len(word)-1: 
                    return True
                tmp, board[i][j] = board[i][j], '/'
                it(index+1, m, n) 
                board[i][j] = tmp

            
```


```python
class Solution:
    def exist(self, board, word: str) -> bool:
        def dfs(i, j, k):
            if not 0 <= i < len(board) or not 0 <= j < len(board[0]) or board[i][j] != word[k]: return False
            if k == len(word) - 1: return True
            tmp, board[i][j] = board[i][j], '/'
            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)
            board[i][j] = tmp
            return res

        for i in range(len(board)):
            for j in range(len(board[0])):
                if dfs(i, j, 0): return True
        return False

```


```python
solution = Solution()
solution.exist(board,word)

```

### 🚩13. 机器人的运动范围
地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格(不能移动到方格外)，也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

```
示例 1：

输入：m = 2, n = 3, k = 1
输出：3
示例 2：

输入：m = 3, n = 1, k = 0
输出：1
```


```python
m = 2
n = 3
k = 1
```


```python
m = 38
n = 12
k = 9
```


```python
# copy
def digitsum(n):
    ans = 0
    while n:
        ans += n % 10
        n //= 10
    return ans

class Solution:
    def movingCount(self, m: int, n: int, k: int) -> int:
        from queue import Queue
        q = Queue()
        q.put((0, 0))
        s = set()
        while not q.empty():
            x, y = q.get()
            if (x, y) not in s and 0 <= x < m and 0 <= y < n and digitsum(x) + digitsum(y) <= k:
                s.add((x, y))
                for nx, ny in [(x + 1, y), (x, y + 1)]:
                    q.put((nx, ny))
        return len(s)
        
```


```python
solution = Solution()
solution.movingCount(m,n,k)
```

### ✅(10m)[18. 删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

难度简单97

给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

**注意：**此题对比原题有改动

**示例 1:**

```
输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
```

**示例 2:**

```
输入: head = [4,5,1,9], val = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.
```



#### 🚩[20. 表示数值的字符串](https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/)

难度中等154

请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100"、"5e2"、"-123"、"3.1416"、"-1E-16"、"0123"都表示数值，但"12e"、"1a3.14"、"1.2.3"、"+-5"及"12e+5.4"都不是。

### ✅(20m) [21. 调整数组顺序使奇数位于偶数前面](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)

### ✅(15m) [22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

### ✅(10m) [24. 反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)

### ✅(15m) [25. 合并两个排序的链表](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

核心代码：

```python
        while l1 and l2:
            if l1.val <= l2.val:
                cur.next = ListNode(l1.val)
                l1 = l1.next
            else:
                cur.next = ListNode(l2.val)
                l2 = l2.next
            cur = cur.next  # 注意要往下走了！
```



### 🚩(30m)[剑指 Offer 26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

### ✅(10m) [剑指 Offer 27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

### 🚩(60m) [剑指 Offer 29. 顺时针打印矩阵](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)

### ✅(30m) [剑指 Offer 30. 包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)

难度简单102

定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。

**示例:**

```
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.min();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.min();   --> 返回 -2.
```

**提示：**

1. 各函数的调用总次数不超过 20000 次

### ✅(10m) [剑指 Offer 32 - I. 从上到下打印二叉树](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)

### ✅(10m) [剑指 Offer 32 - II. 从上到下打印二叉树 II](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

### ✅(10m) [剑指 Offer 32 - III. 从上到下打印二叉树 III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

注意：

1. ​      temp = collections.deque()

​      res.append(list(temp))  *# 注意要先转化为list*

2. 双端队列

   1.  if len(res)%2==0: temp.appendleft(node.val)

   ​        else: temp.append(node.val)

   2. ​        node = deque.popleft(0) *# 注意*

### ✅(20m) [剑指 Offer 42. 连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)

### ✅(20m) [剑指 Offer 46. 把数字翻译成字符串](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)

### ✅(15m) [剑指 Offer 47. 礼物的最大价值](https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/)

### ✅(15m) [剑指 Offer 50. 第一个只出现一次的字符](https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)

字典有序且效率高

[为什么Python 3.6以后字典有序并且效率更高？](https://www.cnblogs.com/xieqiankun/p/python_dict.html)

```
for key in 字典

for value in 字典.values()

for key, value in 字典.items()
```

### ✅(30m) [剑指 Offer 52. 两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

### ✅(15m) [剑指 Offer 53 - I. 在排序数组中查找数字 I](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)







# Reference

1. labuladong的算法小抄pdf
2. [九章算法视频](https://www.bilibili.com/video/BV1i64y1u7Me/)



